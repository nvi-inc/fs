""
                   HAYSTACK COMPOSITE LIBRARY 
  
The routines in the relocatable file $LIBHS are a set of utility routines 
which are collectively referred to as the "Haystack library", and are used
in many programs written there and at a sister facility at NASA Goddard Space 
Flight Center.  The $LIBHS file should normally be searched when loading
programs contained on the 'Haystack Export Software' tape.  Most, but not all,
of the routines in this library were written at Haystack or GSFC. 
Those not in this category are noted in the descriptions below. 
    
Note: ALL routines in $LIBHS are compatible with RTE-II/III/IV/IVB/6VM. 
      Almost all routines have been upgraded to RTE-A compatibility.
      Those that are not RTE-A compatible are noted.
      In addition, ALL routines are LB/EB compatibile.
  
Note: Two dummy libraries, $DUMY6 and $DUMYA are provided to satisfy
      possible undefined externals under RTE-6VM and RTE-A, respectively. 
      $DUMY6 contains dummy entry points $LUTA and $LUT# (RTE-A entry points).
      $DUMYA contains dummy entry points $RNTB and $IDEX (RTE-6 entry points).
  
Note: All FORTRAN compilation of routines in $LIBHS has been done with FTN7X. 
      Transfer file *LIBHS may be used to re-create $LIBHS from source files; 
      *LIBHS uses the compiler manager program COMPC, which may be
      obtained from elsewhere on this CSL/1000 tape.
  
Note: The following file-naming conventions are used -
          &xxxxx - Source text file for program or routine(s) xxxxx 
          %xxxxx - Relocatable file 
          ^xxxxx - LOADR command file to load program xxxxx 
          #xxxxx - LINK command file to load program xxxxx  
          *xxxxx - Transfer to compile (sometimes), load, and save program xxxxx
          "xxxxx - Informational file 
          'xxxxx - Cross reference listing generated by program QXREF 
  
Note: This file ("LIBHS) is provided in the HELP format so that it information
      may be easily accessed using the program HELP, either that provided 
      by HP, or the version included in Save#5 of this tape.
  
----------------------------------------------------------------------------
""
LIBHS 
Summary of modules and entry points within Haystack Library 
  Module  Entry Points
  AFILL   AFILL  Fill array with specified value,increment & word increment 
  APPEND  APPEND Append string to another 
  BKRED   BKRED  General-purpose disc block-read routine
  BKWRT   BKWRT  General-purpose disc block-write routine 
  CINFO   CINFO  Get FMGR cartridge information 
  CLNDR   CLNDR  Converts year/month/day into printable month and day-of-week 
  CMDST   CMDST  Creates command stack just like CI (from Don Wright) 
  CMOVE   CMOVE  Block character move 
  CN21    CN21   Forcefully issues a :CN,lu,21B request to disable a terminal 
  CNVRT          Conversion package between 2,3,4-word FP and double integer
          DI2DF  Double-integer to double (4-word) floating 
          DI2SF  Double-integer to single (2-word) floating 
          DI2XF  Double-integer to extended (3-word) floating 
          DF2DI  Double-floating to double-integer
          DF2XF  Double-floating to extended-floating 
          SF2DI  Single-floating to double-integer
          XF2DI  Extended-floating to double-integer
          XF2DF  Extended-floating to double-floating 
  CNVT    CNVT   Convert a 16-bit word to printable integer/ASCII format, 
                 as appropriate, either left or right-justfied in 6-char field
  CRCC    CRCC   Generate cyclic redundancy check code
  CRLOK   CRLOK  Lock/unlock FMP cartridges 
  CSPCE   CSPCE  Determine amount of remaining space on an FMP cartridge
  DATER   DATER  Prints Date/Time header on specified LU
  DCOPY   DCOPY  General-purpose disc copy routine
  DL      DL     Powerful FMP Directory search routine
  EQLUF   EQLUF  Get LU from EQT word 4 address 
  EQUAL   EQUAL  Compare byte strings 
  EXECX   EXECX  Modify father/son relationships of programs
  EXEK4   EXEK4  Allocate specified #blocks on system tracks
  GETSX   GETSX  Just like RTE GETST, except will return more than 80 chars.
  GREQU   GREQU  Byte string compare function 
  HEX     HEX    Convert from binary to printable hex format
  HEXI    HEXI   Convert from ASCII hex to binary 
  ICOMP   ICOMP  Word compare.  Uses hi-speed word compare instruction. 
  IDATE   IDATE  Return current YMDHMS either integer or ASCII format 
  IDAY0   IDAY0  Returns # of elapsed days in year to end of specified month
  IDGT    IDGT   Get ID segment of specified program
  IDTKX   IDTKX  Get cartridge label, sectors/track, directory track, etc.
  IDTYP   IDTYP  Get driver type for specified LU 
  IDXGT   IDXGT  Get ID segment extension address of specified program
  IEQTF   IEQTF  Get EQT#, manage device buffer/unbuffer status 
  IFERR   IFERR  FMP error reporter 
  IFNAM   IFNAM  Get namr from LU and parse it
  IGETC   IGETC  Get a specified character from a buffer
  IGETS   IGETS  Get a word from the System Map 
  IN2A2   IN2A2  Convert 2-digit integer to A2 format with leading zero 
  IOF     IOF    Delete specified ID segment (equiv to :RP,,PROG) 
  IOPSY   IOPSY  Get host system type 
  IPAPA   IPAPA  Get name of father for any program 
  IPRTY   IPRTY  Get/change priority of program 
  IPST    IPST   Get status of specified program
  IROT    IROT   Rotate bits left/right within word (obsolete-use LROT) 
  IRP     IRP    Restore ID segment of SP'ed program (equiv to :RP,PROG)
  ISHFT   ISHFT  Left/right bit shifter within word 
  ITO     ITO    Get/change time-out value of specified device
  IUNLK   IUNLK  Close a spuriously open FMP file 
  IWTL    IWTL   Allows writing/reading from a 'locked' lu
  JSHFT   JSHFT  Left/right bit shifter within word (obsolete-use ISHFT)
  LCHEK   LCHEK  Check integrity of data in Type 3,4,5 variable-length
                 record files 
  LEFTJ   LEFTJ  Left justify character string in FTN77 (from Don Wright) 
  LIBER   LIBER  Set LU for FTN4 STOP, PAUSE, and error messages  
  LINC           General segment controller package 
          LINCA 
          LINCB 
  LINK    LINK   Link from main program to segment
          RETRN  Return from segment to main program
  LINQ           OBSOLETE general segment controller package (replaced by LINC) 
          LINQA 
          LINQB 
          LINQC 
          LINQD 
  LOC     LOC    Get absolute address of specified parameter
  LUOPR   LUOPR  Get lu from which calling program was initiated
  LROT    LROT   Left/right bit rotater within word 
  MSCHK   MSCHK  Check system master security code
  NAMOK   NAMOK  Verify that 6-character name is valid NAMR format
  NARG    NARG   Get # of arguments with which ASMB/FTN4 routine was called.
                 WARNING: NARG not FTN4X/7X compatible -- use PCOUNT  
  NEXTX   NEXTX  Find and open next extent, if any, of FMP file 
  PUTC    PUTC   Put character into specified location in buffer
  PUTINCOMMAS    put commas into command line just like CI (from Don Wright)
  PUTS    PUTS   Put word into specified location in System Map 
  QSUBS          Comprehensive package of ASCII string-handling routines
                 See "QSUBS for details.
  QSUB1   .MBT   Software replacements for .MBT & .CBT (assembly language 
          .CBT   instructions MBT & CBT on 21MX machines) for older 2100 machines.
                 NOT included in $LIBHS, but provided as separate relocatable.
  RMAN    RMAN   Inverse NAMR.  Reconstruct namr from 10-word parsed buffer.
  SORT    SORT   General-purpose direct-replacement sort routine
  SORTR   SORTR  General-purpose Shell sort routine 
  SQZEM   SQZEM  Squeeze out spaces in ASCII buffer 
  SSWCH   SSWCH  Display-register handler routine 
  STRAK          General-purpose expandable fixed-record-length scratch-file handler
          STOPN  Open/close scratch file
          STWRT  Write specified record# into file
          STRED  Read specified record# from file 
          ISTLC  Get current position in file 
  SUBCH   SUBCH  Get/set lu subchannels 
  SUSP    SUSP   Suspend self for specified period of time
  TIMR    TIMR   General-purpose timing routine 
  UCASE   UCASE  Change characters in buffer to all upper-case
  UNAME   UNAME  Create unique scratch file name
  WCSF    WCSF   Load 12789/13197 WCS without DVR36 
  WMOVE   WMOVE  Hi-speed word mover.  Uses block word move instruction.
  XTNTS          Package of FMP file-extent handling routines 
          CRETX  Create extent of specified number, type, and size
          OPENX  Open specified extent
          PURGX  Purge specified extent 
          LISTX  Get list of extents for existing file
  YMDAY   YMDAY  Converts day-of-year into month and day
  
Note: A cross-reference listing of all the modules and entry points in
      $LIBHS is contained in file 'LIBHS (created by program QXREF).
  
------------------------------------------------------------------------
Other Required Software:
  The following 3 programs are required to support the Haystack library 
  and many of the Haystack utility programs:
   1. RP    - Program RP is used to restore ID segments from Type 6 files 
              under RTE-6VM/A. RP is scheduled by a call to subroutine IRP
              (in $LIBHS) and avoids all the overhead of FmpRpProgram.
              RP may also be run as a stand-alone program to perform the
              same function.  See file &RP for details. 
   2. OF    - Program OF is used to delete ID segments under RTE-6VM/A. 
              OF is scheduled by a call to subroutine IOF (in $LIBHS).
              OF may also be run as a stand-alone program to perform the
              same function.  See file &OF for details. 
   3. UNLOK - Program UNLOK is used to unlock FMGR files and/or cartridges. 
              UNLOK is scheduled by a call to subroutine IUNLK (in $LIBHS). 
              UNLOK may also abe run as a stand-alone program to perform the
              same function.  See file &UNLOK for details.
  
These program may be loaded using the LINK command files #RP, #OF, and  
#UNLOK, respectively. For proper usage, they should be loaded as permanent
programs (RTE-6VM) or as System-Utility under RTE-A and RP'ed in the
WELCOM file.
------------------------------------------------------------------------
Detailed descriptions of routines in $LIBHS:
  
""
AFILL 
------
      Fill array with a specified value,increment & specified word increment. 
  
      Calling sequence: 
        CALL AFILL(IWD1,WINC,VALUE,INC,N,[MODE])
             where MODE=0 or absent:
                        IWD1    first word of array 
                        WINC    word increment
                        VALUE   starting value with which to fill array 
                        INC     increment to be applied to each word written
                        N       #words to be written
                                (NOT necessarily same as array length)
                   MODE<>0: 
                        IWD1    ADDRESS of first word of array
""
APPEND
------
      SUBROUTINE APPEND (STR1, STR2, NBLANKS) 
  
   APPEND appends STR2 to the characters in STR1 by finding the last
   non-blank character in STR1, adding the specified number of spaces,
   and inserting STR2 there.  No action if the resulting start position 
   exceeds the length of STR1.  The result is put in STR1.
  
""
BKRED 
------
  
      SUBROUTINE BKRED(IBUF,LBUF,LU,ITRK,ISEC,NSEC) 
  
      ROUTINE TO DO BLOCK READS FROM DISC LU. 
      EACH READ MUST BE A MULTIPLE OF 128 WORDS.
      AUTO-TRACK SWITCHING SUPPORTED UNDER RTE-6VM. 
  
      ON ENTRY: 
        IBUF   - BUFFER TO BE READ
        LBUF   - LENGTH OF BUFFER TO BE READ (WORDS)
        LU     - DISC LU
        ITRK   - TRACK # FOR READ 
        ISEC   - SECTOR # FOR READ
        NSEC   - # 64-WORD SECTORS/TRACK ON DISC
  
      ON RETURN:
        ITRK AND ISEC ARE UPDATED TO POINT TO THE NEXT TRACK
        AND SECTOR. 
  
""
BKWRT 
------
  
      SUBROUTINE BKWRT(IBUF,LBUF,LU,ITRK,ISEC,NSEC) 
  
      ROUTINE TO DO BLOCK WRITES TO DISC LU.
      EACH WRITE MUST BE A MULTIPLE OF 128 WORDS. 
      AUTO-TRACK SWITCHING SUPPORTED UNDER RTE-6VM. 
      WILL WRITE TO LU 2/3 SO BE CAREFUL!!! 
  
      ON ENTRY: 
        IBUF   - BUFFER TO BE WRITTEN 
        LBUF   - LENGTH OF BUFFER TO BE WRITTEN (WORDS) 
        LU     - DISC LU
        ITRK   - TRACK # FOR WRITE
        ISEC   - SECTOR # FOR WRITE 
        NSEC   - # 64-WORD SECTORS/TRACK ON DISC
  
      ON RETURN:
        ITRK AND ISEC ARE UPDATED TO POINT TO THE NEXT AVAILABLE TRACK
        AND SECTOR. 
  
""
CINFO 
------
      INTEGER*2 FUNCTION CINFO
     .         (IBUF,LBUF,ICR,IDTRK,[LUCR],[LABEL],[NSECT],[LOCK],[ID],[IAV]) 
  
      Returns information about specified FMGR cartridge
  
      On entry: 
         IBUF,   scratch buffer 
         LBUF,   length of IBUF (words); should be at least 
                 256 words to read full length cartridge list 
         ICR,    cartref on which information is desired (-lu,+label) 
      On return:
         CINFO, =0 if ICR not found in System Cartridge List (SCL), 
               =-1 if specified cartridge is CI volume
               else =first directory track# 
         IDTRK,  same as CINFO
         LUCR,   (optional) lu of specified cartridge 
         LABEL,  (optional) cartridge label of specified cartridge
         NSECT,  (optional) #64-word sectors/track of specified cartridge;
                 available only if LUCR is in user's SST, if any. 
         LOCK,   (optional) ID seg address of locking program, if locked. 
                            Returns =0 if not locked. 
         ID,     (optional) ID of user to whom cartridge is mounted 
                       0    - non-session (or non-RTEIVB/6VM) 
                   7777B    - system cartridge
                   1-7776B  - Session Monitor (group or private)
         IAV,    (optional) flag indicating if cartridge is accessible to 
                 caller through FMGR or FMP calls 
                       0 - mounted to SCL, but not accessible to caller 
                           for either read or write.
                       1 - mounted to SCL, but not in user's cartridge list 
                           or SST.  Would be accessible to user if placed 
                           in user's SST. 
                       2 - accessible for read only (i.e. lu2 or lu3 under
                           Session, but not System Manager) 
                       3 - accessible for read or write 
  
      Note: LUCR,LABEL,NSECT,LOCK,ID,IAV are meaningless if CINFO is
            returned <=0. 
      Note: The routines GTSCB and LUSES are called if executing
            under RTE-IVB/6VM.
            If not operating under RTE-IVB/6VM/A, the user must supply dummy
            routines named GTSCB and LUSES. 
  
""
CLNDR 
------
  
      SUBROUTINE CLNDR ( IYEAR , MONTH , IDAY , IPMON , IPDAY ) 
  
      CLNDR IS A CALENDER CONVERSION PROGRAM WHICH CONVERTS YEAR- 
      MONTH-DAY DATES INTO PRINTABLE MONTH AND DAY-OF-WEEK: 
          IPMON = 'PRINTABLE' MONTH ( e.g. "JAN." ) 
          IPDAY = 'PRINTABLE' DAY OF WEEK ( e.g. "MON." ) 
               ( IPMON AND IPDAY BOTH IN <2A2>  OR <A2,A1> FORMATS) 
  
      NOTE THAT IF MONTH = 0 ON ENTRY ( AND HENCE THE INPUT IS IN YEAR
      AND DAY-OF-THE-YEAR FORMAT ), MONTH WILL BE CHANGED TO THE
      CORRECT MONTH AND IDAY WILL BE CHANGED TO THE DAY-OF-THE-MONTH
      PRIOR TO RETURN. IF THE IDAY IS 'INVALID' ( E.G.  33 DEC 1976 ),
      IT WILL BE 'CORRECTED' ( E.G.  02 JAN 1977 ) PRIOR TO RETURN. 
      YOU SHOULD THEREFORE BE VERY CAUTIOUS OF INSERTING INTEGERS 
      (RATHER THAN VARIABLES) INTO YOUR CALL. 
      E.G.      CALL CLNDR [ 1976 , 12 , 33 ... ]      MIGHT CAUSE
                       DISASTROUS RESULTS ) !!!!!!!!!!!!!!!!!!! 
  
""
CMDST    (from Don Wright)
------
      SUBROUTINE CMDSTACK (LOG, STRING, STACK)
      Manage Command Stack just like CI 
  
   CMDSTACK handles the command-stack for an interactive program.  It is
   passed a character variable containing the new command and another 
   character variable holding previous commands.  It saves as many
   commands in that buffer as will fit.  It trims commands to minimum 
   nonblank length and left-justifies, but does not casefold. 
  
   It accepts three forms of Stack-Display Command: 
  
    * /   List the default number of 20 commands, read one line.
    * /n  List n commands, read one line. 
    * //- -/  Here the number of extra slashes has the same effect as n 
          in the previous form. 
  
   CMDSTACK is called as follows from Fortran:
  
      CALL CMDSTACK (LOG, STRING, STACK)
  
   Where: 
  
      LOG is the interactive LU, integer*2. 
  
      STRING is a character variable at least 3 characters in length
         containing the keyboard-input command.  If it is one of the
         forms above, then it will return the output command after the
         stack has been displayed and operator input received.  Other-
         wise it will return the left-justified original command.  If 
         the nonblank length of the input string exceeds 255 or the 
         length of STACK, it will not be saved in the stack.  STRING is 
         usually sized to about 80 characters.
  
      STACK is a character variable passed by the calling program which 
         CMDSTACK will use for storage of the stack and its command-
         length bytes.  It is to be passed unchanged to CMDSTACK each 
         call.  It will be cleared and re-initialized by CMDSTACK if its
         first character is found to be a nul, or the second a blank, or
         if it does not have internal integrity.  The calling program 
         should blank it out before the first call.  A typical length 
         for STACK would be at least 200 characters.
  
  
   CMDSTACK follows this sequence:
  
      Left-justify the command in STRING. 
      Exit with no further action if not driver type 05.
      Verify integrity of stack, clear it if none.
      If blank, exit with no action.
      If not one of the two Stack-Display forms, then:
         Delete identical command from stack, if any. 
         Delete lines from stack as required to make rooom. 
         Add new command on top of stack. 
         Exit with command. 
      Else: 
         Compute the number of commands to display. 
         Display those commands, one by one.
         If not the default (20), position cursor.
         Wait for carriage-return.
         Read the input line. 
         Go back up to blank-check, above.
  
""
CMOVE 
------
  
      SUBROUTINE CMOVE(IX,I,IY,J,N) 
  
      USES HIGH-SPEED MOVE-BYTE INSTRUCTION TO MOVE N CHARACTERS FROM 
      IX TO IY, STARTING AT THE I-th CHARACTER OF IX AND THE J-th 
           CHARACTER OF IY. 
      IF N<=0, NO CHARACTERS WILL BE MOVED. 
      FIRST CHARACTER IS #1.
      DOES NOT CHECK OR MODIFY THE VALUES OF I AND J. 
      CHARACTERS ARE MOVED IN ORDER FROM LEFT TO RIGHT. 
  
""
CN21
------
  
      SUBROUTINE CN21(LU) 
  
      ROUTINE TO POSITIVELY DISABLE A TERMINAL. 
      THIS ROUTINE WAS WRITTEN BECAUSE THE NORMAL ":CN,LU,21B"
      WILL NOT DISABLE A TERMINAL IF A PROMPT IS PENDING, 
      ALTHOUGH NO NOTICE IS GIVEN THAT THE COMMAND WAS INEFFECTIVE! 
  
""
CNVT
------
      SUBROUTINE CNVT(IN,OUT,IJUST) 
  
      Convert single-word quantity 'IN' to 3-word ASCII in 'OUT'. 
      Will convert to alpha-numeric if either character in 'IN' is printable. 
      IJUST=0 ---> left-justify in 'OUT'
      IJUST=1 ---> right-justify in 'OUT' 
  
""
CNVRT 
------
      A package of routines for doing conversions between various combinations
      of I*4,R*4,R*6,R*8.  Rather OBSOLETE with the advent of FTN4X/7X. 
             DI2SF   I*4 to R*4 
             SF2DI   R*4 to I*4 
             DI2XF   I*4 to R*6 
             XF2DI   R*6 to I*4 
             DI2DF   I*4 to R*8 
             DF2DI   R*8 to I*4 
             DF2XF   R*8 to R*6 
             XF2DF   R*6 to R*8 
      See individual routines for further information.
  
""
DI2SF     (routine in CNVRT package)
      Convert I*4 to R*4
               ---------- 
      FUNCTION DI2SF(ARG) 
               ---------- 
  
      DI2SF PERFORMS A CONVERSION FROM DOUBLE-INTEGER TO SINGLE-FLOATING. 
  
""
SF2DI     (routine in CNVRT package)
      Convert R*4 to I*4
               -----------
      FUNCTION SF2DI(DARG)
               -----------
  
      IF B=SF2DI(DARG) AND DARG IS A SINGLE-FLOATING NUMBER,
      THEN B WILL BE A 32-BIT DOUBLE-INTEGER. 
  
      THE FRACTIONAL PART OF A FLOATING NUMBER IS TRUNCATED 
      IN THE USUAL WAY...THAT IS, 135556.223 IS CONVERTED 
      TO 135556 
  
      IF THE MAGNITUDE OF THE EXPONENT OF THE FLOATING POINT NUMBER IS >=32,
      REGARDLESS OF SIGN, 2**31-1 IS RETURNED AS THE RESULT AND THE OVERFLOW
      FLAG IS SET.
  
""
DI2XF     (routine in CNVRT package)
      Convert I*4 to R*6
                                ----------
      DOUBLE PRECISION FUNCTION DI2XF(ARG)
                                ----------
  
      DI2XF PERFORMS A CONVERSION FROM DOUBLE-INTEGER TO EXTENDED-FLOATING. 
      WHEN CALLED FROM FORTRAN, DI2XF MUST BE DECLARED 'DOUBLE-PRECISION'.
  
""
XF2DI     (routine in CNVRT package)
      Convert R*6 to I*4
               -----------
      FUNCTION XF2DI(DARG)
               -----------
  
      IF B=XF2DI(DARG) AND DARG IS A EXTENDED-FLOATING NUMBER,
      THEN B WILL BE A 32-BIT DOUBLE-INTEGER. 
  
      THE FRACTIONAL PART OF A FLOATING NUMBER IS TRUNCATED 
      IN THE USUAL WAY...THAT IS, 135556.223 IS CONVERTED 
      TO 135556 
  
      IF THE MAGNITUDE OF THE EXPONENT OF THE FLOATING POINT NUMBER IS >=32,
      REGARDLESS OF SIGN, 2**31-1 IS RETURNED AS THE RESULT AND THE OVERFLOW
      FLAG IS SET.
  
""
DI2DF     (routine in CNVRT package)
      Convert I*4 to R*8
                                ----------
      DOUBLE PRECISION FUNCTION DI2DF(ARG)
                                ----------
  
      DI2DF PERFORMS A CONVERSION FROM DOUBLE-INTEGER TO DOUBLE-FLOATING. 
      WHEN CALLED FROM FORTRAN, DI2DF MUST BE DECLARED 'DOUBLE-PRECISION'.
  
""
DF2DI     (routine in CNVRT package)
      Convert R*8 to I*4
               -----------
      FUNCTION DF2DI(DARG)
               -----------
  
      IF B=DF2DI(DARG) AND DARG IS A DOUBLE-FLOATING NUMBER,
      THEN B WILL BE A 32-BIT DOUBLE-INTEGER. 
  
      THE FRACTIONAL PART OF A FLOATING NUMBER IS TRUNCATED 
      IN THE USUAL WAY...THAT IS, 135556.223 IS CONVERTED 
      TO 135556 
  
      IF THE MAGNITUDE OF THE EXPONENT OF THE FLOATING POINT NUMBER IS >=32,
      REGARDLESS OF SIGN, 2**31-1 IS RETURNED AS THE RESULT AND THE OVERFLOW
      FLAG IS SET.
  
""
DF2XF     (routine in CNVRT package)
      Convert R*8 to R*6
                                ----------
      DOUBLE PRECISION FUNCTION DF2XF(ARG)
                                ----------
  
      DF2XF PERFORMS A CONVERSION FROM 4-WORD TO 3-WORD FLOATING-POINT
  
""
XF2DF     (routine in CNVRT package)
      Convert R*6 to I*4
                                ----------- 
      DOUBLE PRECISION FUNCTION XF2DF(DARG) 
                                ----------- 
  
      XF2DF PERFORMS A CONVERSION FROM 3-WORD TO 4-WORD FLOATING POINT. 
      WHEN CALLED FROM FORTRAN, XF2DF MUST BE DECLARED 'DOUBLE PRECISION'.
  
""
CRLOK 
------
  
      FUNCTION CRLOK(ICR,MODE,IERR) 
  
      ROUTINE TO LOCK/UNLOCK A CARTRIDGE SO THAT ONLY PROGRAM IN
      WHICH THIS ROUTINE RESIDES CAN ACCESS THE CARTRIDGE.
      D.RTR WILL BE LOCKED OUT FROM USING THIS CARTRIDGE UNTIL IT IS UNLOCKED.
  
      ICR,    +CARTRIDGE,-LU TO BE LOCKED 
      MODE,   Bit 0   0-Unlock
                      1-Lock
              Applicable in RTE-IVB/6VM systems only: 
                 A. If the caller is the system manager he may talk to any
                    disc on the system. 
                 B. If the caller is not under session control he may access
                    system discs and non-session discs. 
                 C. If the caller is under session control and no override is 
                    specified he may access his private and group discs and 
                    system "global" discs.  He may also have read-only access 
                    to lu2 and lu3. 
                 D. If the caller is under session control and MODE bit 14 is 
                    set, he may access his private and group discs and all
                    system discs (including write access to lu2 and lu3). 
                 E. If MODE bit 15 is set, the caller is treated like the 
                    system manager and may have access to any disc in the 
                    system. 
                 F. If MODE bit 13 is set, the caller may access only system
                    discs.
      IERR,   RETURNED >=0 FOR SUCCESSFUL LOCK
              RETURNED <0 FOR UNSUCCESSFUL LOCK (RETURNS STANDARD FMGR CODES) 
              IERR IS ALSO RETURNED IN A-REG. 
  
""
CSPCE 
------
  
      SUBROUTINE CSPCE(ICR,NTRKS,ABLKS) 
  
      SUBROUTINE TO RETURN THE NUMBER OF FREE TRACKS AND BLOCKS ON A DISK CART
  
         CALL CSPCE(ICR,NTRKS,ABLKS)
  
         ICR = CARTRIDGE REF (+LABEL/-LU) 
         NTRKS = NUMBER OF (WHOLE)TRACKS REMAINING OR -1 IF LU NOT MOUNTED
                 OR LOCKED
         ABLKS = NUMBER OF BLOCKS REMAINING OR -1 IF LU NOT MOUNTED 
                 OR LOCKED (single-precision) 
  
""
DATER 
------
      SUBROUTINE DATER ( LU ) 
  
      THIS SUBROUTINE PRINTS A DATE/TIME HEADER ON UNIT = LU
  
      USES CLNDR , YMDAY , IDAY0 AND IN2A2 ROUTINES.
  
""
DCOPY 
------
  
      SUBROUTINE DCOPY(ILU,ITRK,ISEC,INSEC,JLU,JTRK,JSEC,JNSEC, 
     .                 NSEC,IBUF,LBUF)
  
      Routine to efficiently copy from one disc area to another.
  
      ILU,ITRK,ISEC specify lu,track,sector of source 
      INSEC specifies #sectors/track on source disc 
      JLU,JTRK,JSEC specify lu,track,sector of destination
      JNSEC specifies #sectors/track on destination disc
      NSEC specifies # of sectors to be copied (MUST BE EVEN#!!)
      IBUF is a scratch buffer of length LBUF words.  Faster copy for 
           larger LBUF.  LBUF>=128. 
  
      On return:
        ITRK,ISEC and JTRK,JSEC point to the next sector on the source
        and destination cartridges, respectively. 
  
""
DL
------
  
      SUBROUTINE DL(IPBUF,NP,NMAX,N,NAMES,N1,ICR,N2,ISC,N3, 
     .              ITYPE,N4,ISIZE,N5)
  
      ROUTINE TO RETURN ALL FILE NAMES ON SPECIFIED CARTRIDGE THAT MATCH
      THE SELECTIVE NAMR's IN IPBUF.
  
      ON ENTRY: 
         IPBUF,  ARRAY OF PARSED SELECTIVE NAMR's 
                 (SEE DESCRIPTION OF ROUTINE 'NAMR' IN RELOCATABLE LIBRARY
                  MANUAL FOR EXACT FORMAT OF IPBUF) 
         NP,     #ENTRIES IN IPBUF ARRAY (I.E. SECOND DIMENSION OF
                 IPBUF ARRAY) 
         NMAX,   MAX # OF NAMES,ETC THAT CAN BE RETURNED
                 (I.E. SIZE OF ARRAYS)
         NAMES,  DOUBLY-DIMENSIONED ARRAY FOR RETURNED FILE NAMES 
         N1,     FIRST DIMENSION OF NAMES ARRAY (N1>=3) 
         ICR,    ARRAY OF CARTRIDGE REFS CORESPONDING TO NAMES
         N2,     FIRST DIMENSION OF ICR ARRAY 
                 IF =0, ICR ARRAY WILL NOT BE RETURNED
         ISC,    SINGLY-DIMENSIONED ARRAY FOR RETURNED SECURITY CODES 
         N3,     FIRST DIMENSION OF ISC ARRAY  (N2>=1)
                 IF =0, ISC ARRAY WILL NOT BE RETURNED
                 CODES
         ITYPE,  SINGLY-DIMENSIONED ARRAY FOR RETURNED FILE TYPES 
         N4,     FIRST DIMENSION OF ITYPE ARRAY (N3>=1) 
                 IF =0, ITYPE ARRAY WILL NOT BE RETURNED
         ISIZE,  SINGLY-DIMENSIONED ARRAY FOR RETURNED FILE SIZES 
         N5,     FIRST DIMENSION OF ISIZE ARRAY (N4>=1) 
                 IF =0, ISIZE ARRAY WILL NOT BE RETURNED
  
      ON RETURN:
         N,      # OF RETURNED ENTRIES IN ARRAYS NAMES,ICR,ISC,ITYPE,ISIZE
         NAMES,  ARRAY OF DIMENSION (3,N) CONTAINING RETURNED NAMES 
         ISC,     ARRAY OF SECURITY CODES 
         ITYPE,   ARRAY OF FILE TYPES 
         ISIZE,   ARRAY OF RETURNED FILE SIZES
                 (+BLOCKS,-CHUNKS)
  
""
EQLUF   (not RTE-A compatible)
------
  
      ALU=EQLUF(IEQT4)
            where IEQT4  = EQT4 ADDRESS 
                  A-REG  RETURNS LU  (0 IF NONE FOUND)
                  B-REG  RETURNS ASCII LU 
  
""
EQUAL 
------
      LOGICAL FUNCTION EQUAL(IX,I,IY,J,N) 
  
      USES HIGH-SPEED COMPARE-BYTE INSTRUCTION TO COMPARE N CHARACTERS IN 
      IX AND IY, STARTING AT THE I-th CHARACTER OF IX AND THE J-th
           CHARACTER OF IY. 
      IF N<=0, COMPARISON IS UNEQUAL. (RETURNS .FALSE.) 
      FIRST CHARACTER IS #1.
      DOES NOT CHECK OR MODIFY THE VALUES OF I AND J. 
      TRUE RETURNED IFF THE BYTE STRINGS ARE IDENTICAL. 
  
""
EXECX   (not RTE-A compatible)
------
      SUBROUTINE EXECX(ABRTN,ICODE,NAME,IP1,IP2,IP3,IP4,IP5,IBUF,LBUF,*)  
  
      Routine to schedule a program in the same way as an EXEC(9/10/23/34,..) 
      request with the following differences: 
       1.Upon exit from EXECX, the scheduled program will appear as a 
         direct son to the father, if any, of the program in which the
         EXECX call was made (host program), instead of appearing as a
         son to the host program. Furthermore, it will appear as if the 
         father has scheduled the son with EXEC(ICODE,NAME,...).
       2.Return from EXECX will be immediate in any case.  Furthermore, 
         the host program will be left as a fatherless program. 
  
      The arguments and returns are the same as those in a
      EXEC(9/10/23/24,...) call, except that the A-B reg return is in 
      ABRTN and, if the no-abort bit (bit 15) of ICODE is set, the
      no-abort return is through the alternate return 1.
  
""
EXEK4   (not RTE-A compatible)
------
      FUNCTION EXEK4(ICODE,NBLKS,ISTRK,IDISC,ISECT) 
  
      Function designed to work around the chicken and egg problem posed
      by disk track allocation EXEC calls 4 and 15. 
  
      The following problem is faced by the user wishing to get use of a
      certain amount of space (i.e. number of blocks) from the system track 
      pool: 
         Since lu2 and lu3 may be on different physical discs with different
         #'s of sectors/track, and in the general case we can't predict whether 
         we will get tracks from lu2 or lu3,  we don't really know how many 
         tracks we should have asked for until after we have gotten them!!
  
      Function EXEK4 attempts to work around this problem by allowing 
      the user to specify the number of 128-word BLOCKS needed, then making 
      an intelligent guess as to the #sectors/track that will result in a 
      request for tracks.  If it turns out that the guess is wrong and too
      many tracks are allocated, any excess are immediately returned to the 
      system pool.
  
      EXEK4 may be used as either an EXEC(4,...) or EXEC(15,...) substitute 
      by specifying the appropriate value of ICODE.  The calling sequence is
      the same as the corresponding EXEC call except the user specifies the 
      # of 128-word blocks desired in the parameter NBLKS (instead of the 
      #tracks desired, as in a normal EXEC call).  Returned parameters
      ISTRK, IDISC, and ISECT are optional in the same way as a normal
      EXEC call.  The only restriction is that bit 15 of ICODE may not be 
      set as it may be in a normal EXEC call (to produce a so-called
      'no-abort call'). 
  
""
GETSX 
------
      SUBROUTINE GETSX(IBUF,ILEN,ILOG)
  
      GETST without buffer length restriction.
      Subroutine that operates identically to HP GETST except is not
      limited to retrieving a total of 80 characters in unparsed string.
  
""
GREQU 
------
  
      LOGICAL FUNCTION GREQU(IX,I,IY,J,N) 
  
      USES HIGH-SPEED COMPARE-BYTE INSTRUCTION TO COMPARE N CHARACTERS IN 
      IX AND IY, STARTING AT THE I-th CHARACTER OF IX AND THE J-th
           CHARACTER OF IY. 
      IF N<=0, COMPARISON IS MOOT.    (RETURNS .FALSE.) 
      FIRST CHARACTER IS #1.
      DOES NOT CHECK OR MODIFY THE VALUES OF I AND J. 
      TRUE RETURNED IFF THE BYTE STRING IX IS .GE. STRING IY. 
  
""
HEX 
------
  
      SUBROUTINE HEX(IBUF,IHEX,NW)
  
      ROUTINE TO CONVERT NW WORDS OF IBUF INTO ASCII HEX REPRESENTATIONS. 
      OUTPUT IS IN ARRAY IHEX, WHICH MUST BE OF LENGTH 2*NW WORDS.
  
  
""
HEXI
------
  
      HEXADECIMAL TO BINARY CONVERSION SUBROUTINE 
  
      CALL HEXI (IN,IOUT,NDIG,IERR) 
  
                 IN: ASCII ARRAY OF HEXADECIMAL DIGITS
                     TWO TO A WORD. 
                OUT: RESULTING ARRAY OF BINARY NUMBERS
               NDIG: NUMBER OF HEX DIGITS TO BE CONVERTED 
               IERR: 0=NO ERRORS, 1=ERROR (E.G., ATTEMPT
                     TO CONVERT A CHARACTER OUT OF THE RANGE
                     0-9,A-F) 
  
      NDIG DIGITS ARE CONVERTED, FILLING UP WORDS OF
      IOUT STARTING AT THE MSB. NOTE THAT IT IS IMPLIED 
      THAT THE DIMENSION OF IN IS TWICE THAT OF IOUT, 
      SINCE FOUR HEX DIGITS, OCCUPYING TWO WORDS, FILL
      ONE BINARY WORD.
      NOTE THAT AN IMMEDIATE RETURN OCCURS UPON DETECTION OF
      AN ERROR. 
  
""
IDATE 
------
  
      IDATE RETURNS THE MONTH, DAY, YEAR, HOUR, MINUTE AND SECOND TO THE
      USER. 
      CALL SEQUENCE:
      CALL IDATE (ITIME,[MODE]) 
        WHERE ITIME IS A 7-WORD BUFFER WHOSE RETURN FORMAT IS:
          ITIME(1)   YEAR (E.G. 77) 
          ITIME(2)   MONTH
          ITIME(3)   DAY OF MONTH 
          ITIME(4)   HOUR 
          ITIME(5)   MINUTE 
          ITIME(6)   SECOND 
          ITIME(7)   10MSEC 
      MODE[OPTIONAL]   0 OR UNSPECIFIED - ITIME IS INTEGER
                       <>0              - ITIME IS ASCII
""
IDAY0 
------
      INTEGER FUNCTION IDAY0 ( IYEAR , MONTH )
  
      THIRTY DAYS HATH SEPTOBER, APRIL, JUNE AND NO WONDER . . . . .
  
      IF 1<=MONTH<=12, THIS FUNCTION RETURNS THE NUMBER OF ELAPSED DAYS 
      ON DAY NUMBER ZERO OF A GIVEN MONTH........ 
               I.E., IF MONTH = 2 (FEB), IDAY0 = 31 ( = JAN 31) 
      WITH LEAP YEARS ACCOUNTED FOR PROPERLY. 
  
      IF MONTH <=0 OR IF MONTH >=13, IDAY0 = NUMBER OF DAYS IN IYEAR. 
  
""
IDGT    (not RTE-A compatible)
----- 
      FUNCTION IDGT(NAMIN,NAMOUT,ISTART,[IBUF]) 
  
      SEARCHES FOR FIRST ID SEGMENT NAME "NAMIN", WHERE "NAMIN" 
      MAY HAVE "-"'S AS "DON'T CARE" CHARACTERS EXACTLY THE SAME AS 
      A SELECTIVE FILE MANAGER DIRECTORY LIST.
      A "+" ALSO ACTS AS A "DON'T CARE" CHARACTER, EXCEPT THAT THE
      "DON'T CARE" CHARACTER MUST BE NUMERICAL (I.E. 0-9).
  
      On entry: 
         NAMIN - PROGRAM NAME UP TO 5 CHARACTERS LONG AND WITH "-"'S
                 OR "+"'S IN "DON'T CARE" POSITIONS 
         ISTART -ID SEG# WITH WHICH SEARCH IS TO START. 
                 NOTE: ISTART WILL BE UPDATED ON RETURN TO POINT TO 
                       THE ID SEGMENT FOLLOWING NAME MATCH, OR IF NO
                       MATCH FOUND, ISTART WILL BE RETURNED 
                       =#ID SEGS PLUS 1.
         IBUF   -(optional) Buffer in which ID segment itself is to be returned.
                 Must be at least 33 words long.
                 If omitted, ID segment will not be returned. 
  
      On return:
         IDGT - ID SEG ADDRESS OF FIRST ID SEGMENT FOUND WHICH MATCHES
                 "NAMIN", 0 IF NONE FOUND, OR -1 IF ISTART IS LARGER
                 THAN # OF ID SEGS. 
         NAMOUT- 5-CHAR NAME OF MATCHING NAME.
         IBUF  - (if specified) returned ID segment 
  
""
IDTYP          (original by M.C. Cote,HP) 
------
      FUNCTION IDTYP(LU)
  
      THIS ROUTINE IS A FORTRAN CALLABLE FUNCTION RETURNING THE 
      DEVICE TYPE CODE FROM WORD #5 OF THE EQT FOR A GIVEN LU#. 
      THE CODE WILL BE RETURNED AS AN OCTAL NUMBER IN THE A REG.
  
""
IDXGT   (not RTE-A compatible)
----- 
 Routine to return information about EMA area of a specified program
  
      CALL IDXGT(IDADD,[IBUF])
      CALL ABREG(IA,IB) 
         where on entry 
           IDADD,  ID seg address of program about which EMA info is desired
           IBUF,   (optional) 3-word buffer in which ID seg ext is returned 
         and on return
           IA,     ID seg ext address, if found (IB = EMA size in pages)
                or 0 if specified program does not use EMA (IB meaningless) 
                or -1 if IDADD is not valid ID seg address (IB meaningless) 
           IBUF,   returned ID seg extension
  
""
IEQTF 
------
      CALL IEQTF(LU,[UNBUF,PREV]) 
      CALL ABREG(IEQT,EQTAD)
  
      On entry: 
          LU,    lu# about which information is sought or buffer
                 status is to be set
          UNBUF, (optional) new buffer status to which LU is to be set
                     <>0   Buffered 
                       0   Unbuffered 
      On return:
          IEQT,  RTE-6:eqt# of device corresponding to LU 
                       or -1 if calling program is in session and LU
                       is not defined for the calling session 
                 RTE-A:-1 if illegal lu, otherwise 0
          IEQTAD,eqt address(RTE-6) or DVT address(RTE-A) 
          PREV,  (optional) previous buffer/unbuffer status 
                      <>0   Buffered
                        0   Unbuffered
  
      Note: The optional arguments UNBUF and PREV must both be present
            in the optional calling sequence. 
  
      Compatible with RTE-2,3,IV,IVB,6VM
  
""
IFERR 
----- 
  
      ERROR REPORTING ROUTINE FOR FMP ERRORS. DOES NOT USE FORMATTER. 
  
      USAGE:
         JFERR=IFERR(LU,IERR,[IPBUF],[IFUNC],[IERR1],[IERR2]) 
           where LU    = LU FOR ERROR REPORTING.
                         IF LU<0, WILL BE REPORTED ON SYSTEM CONSOLE AS WELL. 
                 IERR  = ERROR CODE RETURNED FROM FMP CALL
                 IPBUF = [optional] NAMR-STYLE BUFFER. IF ONLY FILE NAME
                         IS AVAILABLE, IPBUF(4) SHOULD =0 OR 77B. 
                 IFUNC = [optional] 6-CHAR ASCII IDENTIFICATION FIELD 
                         (i.e. 6HOPEN  )
                 IERR1,2 = [optional] ERROR CODES FOR WHICH NO MESSAGE
                           WILL BE REPORTED.
                           If either IERR1>0 or IERR2>0, an error will
                           be reported UNLESS IERR=IERR1 or IERR=IERR2. 
                 JFERR  =  RETURNED =0 IF NO ERROR REPORTED.
                           IF ERROR REPORTED, RETURNED WITH VALUE OF ERROR. 
  
""
IFNAM 
----- 
      FUNCTION IFNAM(LU,IPBUF), READ AND PARSE NAMR 
  
      FUNCTION TO READ NAMR FROM LU AND RETURN IPBUF IN NAMR STYLE. 
        RETURNS IFNAM=-1 IF NOTHING ENTERED.
                       0 IF "::" ENTERED
                      >0 # OF CHARACTERS ENTERED (NOT "::") 
  
  
""
IGETC 
------
      FUNCTION IGETC(IBUF,I)
  
      RETURNS ASCII VALUE OF I-th CHARACTER IN STRING IBUF. 
      THE FIRST CHARACTER IN IBUF IS CHARACTER #1.
      I MAY BE ANY VALUE POSITIVE OR NEGATIVE.
  
""
IGETS 
------
      IVALUE=IGETS(IADDRESS)
  
      RETURNS VALUE IN SPECIFIED ADDRESS IN SYSTEM MAP. 
      WORKS WITH ALL GARDEN VARIETIES OF RTE M/II/III/IV/6VM. 
  
  
""
IN2A2 
------
      INTEGER FUNCTION IN2A2 ( INPUT )
      THIS FUNCTION CONVERTS AN INPUT NUMBER IN I2 FORMAT INTO A
      PRINTABLE NUMBER IN A2 FORMAT, WITH LEADING ZEROES FILLED IN. 
      IN CASE THE NUMBER IS NEGATIVE, THE RETURNED VALUE = "--" 
      IN CASE THE NUMBER EXCEEDS 99 , THE RETURNED VALUE = "++" 
  
""
IOF 
------
  
      FUNCTION IOF (NAME,IERR,LUMESS) 
  
      SCHEDULES PROGRAM "OF" TO DELETE ID SEGMENT OF RESTORED 
      PROGRAM "NAME" FROM THE SYSTEM. 
      A-REG RETURNS ERROR CODE IERR (=0 IF SUCCESSFUL, STANDARD 
      FMGR ERROR CODES OTHERWISE).
      ERROR MESSAGES ARE WRITTEN ON LUMESS (OR SYSTEM CONSOLE IF
      LUMESS=0).  IF LUMESS<0, ALL ERROR MESSAGES ARE SUPPRESSED. 
      NOTE:PROGRAM "OF" MUST HAVE A CURRENT ID SEGMENT AND
           IS PREFERABLY INSTALLED AS A PERMANENT PROGRAM.
           IF, FOR ANY REASON, PROGRAM OF IS NOT EXECUTABLE, IERR 
           RETURNS =14 SO THAT CALLING PROGRAM IS AFFECTED IN A BENIGN
           WAY IF PROGRAM RP IS NOT INSTALLED ON THE SYSTEM; NO ERROR 
           MESSAGE IS PRINTED IN THIS CASE. 
  
""
IOPSY 
------
      FUNCTION IOPSY(IARG,[IDATE])
  
      Function to return type and (optionally) date code($DATC) of
      host operating system.
  
      On return-- 
           IOPSY  SYSTEM  IARG($OPSY)  BITS   $BMON 
                                      543 210 
             0     DOS      1  000001 000 001   0 
             0     RTEL   -31  177741 100 001   0 
             0     RTEXL  -29  177743 100 011   0 
             1     RTEM1   -7  177771 111 001   0 
             2     RTEM2  -15  177761 110 001   0 
             3     RTEM3   -5  177773 111 011   0 
             5     RTE2    -3  177775 111 101   0 
             6     RTE3    -1  177777 111 111   0 
             8     RTE4A   -9  177767 110 111   0 
             8     RTE4B   -9  177767 110 111   1 
             0     RTE4E  -13  177763 110 011   ? 
                                            ^------- 128-word disc
                                           ^-------- Mapped system
                                          ^--------- Disc-based system
                                        ^----------- Type(?)
                               ^-------------------- RTE
             9     RTE6   -17 to -28 (inclusive)
            10     RTE-A  -33 to -128 (inclusive) 
  
""
IPRTY 
------
      FUNCTION IPRTY(IPR,NAME), Get/change program priority 
  
      Calling sequence: 
              JPR=IPRTY(IPR,[NAME]) 
                   where  JPR  = CURRENT PROGRAM PRIORITY 
                                 or 0 if specified program does not exist 
                          IPR  = NEW PRIORITY 
                               = 0, DO NOT CHANGE PRIORITY
                          NAME,  (optional) name of program 
                                 whose priority is to be modified. If not 
                                 specified, calling program is assumed. 
  
    Note: Under RTE-A, only programs within local session are accessible. 
""
IPAPA 
------
      FUNCTION IPAPA(IDAD,IFNAM)  
    
      Routine to find father of specified program, and return name of 
      father program in IFNAM.
    
      On entry: 
          IDAD,  ID seg address of program whose father you wish to find, 
                 or IDAD=0 to find father of host program.
      On return:
          IFNAM, ASCII name of father program, if found,
                 or 0 if no father program, 
          IPAPA  ID seg address of father program, if found,
                 or 0 if no father program, 
    
""
IPST
------
      FUNCTION IPST(IPROG) 
  
      Routine to return current status of program IPROG.
      If no ID segment, returns IPST=-1, otherwise returns
      current status of program as follows: 
  
      RTE-2/3/4/6 
         0 - Dormant
         1 - Scheduled
         2 - I/O Suspend
         3 - General Wait 
         4 - Unavailable Memory Suspend 
         5 - Disc Allocation Suspend
         6 - Operator Suspend or Programmed Suspend (EXEC 7)
         9 - Background Segment 
       100B- Dormant but in Time List 
  
      RTE-A:
          0 - Dormant 
          1 - Program Abort In-Process
          2 - I/O Suspend 
          3 - Program Wait Suspend
          6 - Operator Suspend
          7 - Pause 
         47 - Time Suspend
         50 - Locked Device Suspend 
         51 - Resource Number Suspend 
         52 - Class Suspend 
         53 - Program Queue Suspend 
         54 - Down Device Suspend 
         55 - Device Buffer Limits Suspend
         56 - Load Suspend
         57 - Shared Subroutine Suspend 
         60 - Scheduled (SC or XQ)
         61 - Memory Suspend
       100B - Dormant but in Time List
  
""
IROT     (Obsolete-use LROT)
------
  
      FUNCTION TO ROTATE BITS WITHIN A 16-BIT WORD
  
      K=IROT(M,N) WILL ROTATE THE CONTENTS OF M BY N BITS (-LEFT,+RIGHT)
              AND SET THE RESULT INTO K  (-16<=N<=16) 
  
""
IRP 
------
      FUNCTION IRP(NAM,NUNAM,IERR,LUMESS,[ICR]) 
  
      Schedules program RP to restore ID segment from Type 6 file 
      "NAM" with new name "NUNAM". If NUNAM(1)=0, program 
      is restored with name "NAM".  
      The FMGR cartref upon which the Type 6 file resides may be specified
      in optional parameter ICR.  If ICR is not specified or ICR=0, 
      cartridges are searched according to the order specified in program RP
      (see file &RP). 
  
      Works under all revisions of RTE-II/III/IV/IVB/6VM/A. 
  
      A-reg returns error code IERR (=0 for successful restore, 
      standard FMGR or FMP error codes otherwise, depending on version
      of program RP being used) 
      Error messages are written on LUMESS (or system console if
      LUMESS=0).  If LUMESS<0, all error messages are suppressed. 
      NOTE:Program RP must have a current ID segment and
           is preferably installed as a permanent program.
           If, for any reason, program RP is not executable, IERR 
           returns =14 so that calling program is affected in a benign
           way if program RP is not installed on the system; no error 
           message is printed in this case. 
  
""
ISHFT 
------
  
      FUNCTION TO SHIFT BITS WITHIN A 16-BIT WORD 
  
      K=ISHFT(M,N) WILL SHIFT THE CONTENTS OF M BY N BITS (+LEFT,-RIGHT)
                   AND SET THE RESULT INTO K  (-16<=N<=16). 
                   BITS SHIFTED OFF EITHER END OF M ARE LOST. 
      ISHFT is functionally identical to the intrinsic function ISHFT in
                   FTN4X/7X.
  
""
ITO 
------
  
      FUNCTION ITO(LU,IVAL), MODIFY TIME-OUT ON SPECIFIED LU
  
      CHANGE TIME-OUT VALUE OF LU TO IVAL.
      ITO RETURNS VALUE OF TIME-OUT BEFORE CHANGE.
      IF IVAL<0, ITO RETURNS CURRENT TIME-OUT VALUE ONLY. 
      IF ILLEGAL LU, ITO RETURNS =-1. 
  
""
IUNLK 
------
  
      FUNCTION IUNLK(NAME,ICR,IERR,LUMESS),FORCE FMP FILE CLOSE 
  
      ROUTINE TO UNLOCK SPECIFIED FMGR FILE ON DISC.
      SCHEDULES PROGRAM TO UNLOK TO DO THE JOB, SO THIS ROUTINE 
      REQUIRES A MINIMUM OF SPACE. PROGRAM UNLOK MUST BE AVAILABLE
      AS A TYPE 6 FILE. 
  
      CALLING PARAMETERS: 
          NAME,        3-WORD ASCII ARRAY WITH FILE NAME
          ICR,         CARTRIDGE REF ON WHICH FILE RESIDES (0 IF UNKNOWN) 
                       (+CART LABEL/-CART LU) 
          IERR,IUNLK,  RETURN STANDARD FMGR ERROR CODES (0 IF SUCCESSFUL),
                       ALTHOUGH IERR=-6 MAY MEAN EITHER THAT THE SPECIFIED
                       FILE WAS NOT FOUND OR THAT PROGRAM UNLOK WAS NOT FOUND.
                       IF THE LATTER, A MESSAGE WILL BE PRINTED ON THE SYSTEM 
                       CONSOLE. 
          LUMESS,      LU FOR ERROR MESSAGES. 
                       IF <=0 NO ERROR MESSAGES WILL BE PRINTED.
  
""
IWTL    (not RTE-A compatible, see below) 
------
      KWTL=IWTL(LU)   Function to access an lu through an lu lock 
  
      Returns 'work through lu lock' word which may be used to force access 
      to a locked device.  The upper byte of this word is the index into the
      keyword table and identifies the owner of the resource number locking 
      the lu. 
        Non-RTE6: Bits 4-0 of KWTL are taken from bits 10-6 of DRT word 1.
                  Bits 7-5 are zeroes.
        RTE6:     Bits 7-0 of KWTL are taken from the appropriate byte of 
                  DRT word 3. 
      If lu is not locked, IWTL is returned =0. 
  
      KWTL may be used as the ninth parameter in an EXEC call in order to work
      through a lock on the lu.  This is useful in 'passing' the lu lock from 
      one program to another without threat of interference from an outside program.
      The form of the EXEC call is
  
               CALL EXEC(x,x,x,x,x,x,x,x,KWTL)
  
  Note: IWTL is NOT compatible with RTE-A. RTE-A provides its own means 
        to accomplish the same end by providing an optional parameter 
        in the LURQ call return the key to write-through-lock.
  
""
JSHFT    (Obsolete-use ISHFT) 
------
  
      FUNCTION TO SHIFT BITS WITHIN A 16-BIT WORD 
  
      K=JSHFT(M,N) WILL SHIFT THE CONTENTS OF M BY N BITS (-LEFT,+RIGHT)
                   AND SET THE RESULT INTO K  (-16<=N<=16). 
                   BITS SHIFTED OFF EITHER END OF M ARE LOST. 
  
""
LCHEK 
------
  
      Function to check integrity of variable-length record data as stored
      in FMP disc files.
  
      Parameters
        IBUF,   buffer to be checked
        LBUF,   length of IBUF (words)
        IREC,   record counter shows current record count; should be set=0
                on initial call to LCHEK, thereafter is updated by LCHEK. 
                If set <0 on entry, LCHEK simply returns with LCHEK=0.
        LRECL,  bookkeeping pointer for LCHEK; to be used for informational 
                purposes only; should not be initialized by user. 
        ICOUNT, bookkeeping pointer for LCHEK; to be used for informational 
                purposes only; should not be initialized by user. 
                When an EOF is encountered, ICOUNT is returned pointing 
                to the word in IBUF which contains the EOF marker, and IREC 
                returns the total record count in file. 
        IERR,   return =0 on successful check 
                return =1 on EOF detect 
                returns =-5 on corrupt file (ICOUNT returns pointer to error) 
        LCHEK,  returns =0 if data is to continue to next IBUF. 
                returns =-5 if corrupt data found 
                returns =1 if EOF found 
  
""
LEFTJ      (from Don Wright)
------
      CALL LEFTJUSTIFY (STRING)   Left-justify a string 
  
   If the first nonblank character of the input string is not in column 
   one, LEFTJUSTIFY moves the nonblank string left until it is, with
   blankfill on the right end.  The operation is done in place. 
  
   LEFTJUSTIFY is called as follows from Fortran: 
  
      CALL LEFTJUSTIFY (STRING) 
  
   Where STRING is the character variable which is to be justified. 
  
""
LIBER          (original stolen from Communicator of long ago)
------
      SUBROUTINE LIBER(LU)
  
      MODIFY LU FOR RTE FTN4 PAUSE, STOP, AND ERROR MESSAGES TO 'LU'. 
      WORKS (BUT IS NOT NEEDED) UNDER FTN4X/7X AS WELL. 
  
""
LINC
------
  
      LINC IS A GENERAL SEGMENT CONTROLLER WHICH ALLOWS THE USER TO CALL
      SPECIFIC SUBROUTINES IN A SEGMENT AND TO PASS AN ARGUMENT LIST BY 
      ADDRESS TO THE SUBROUTINE IN THE SEGMENT.  A SEGMENT IS RETAINED IN CORE
      UNTIL IT IS NECESSARY TO GET A DIFFERENT SEGMENT.  SUBROUTINES IN ONE 
      SEGMENT MAY BE CALLED FROM ANOTHER SEGMENT.  ON RETURNING TO A SEGMENT
      OR THE ROOT, EXECUTION PROCEEDS AT THE STATEMENT FOLLOWING THE INITIAL
      CALL. 
  
      THE USER CALL TO LINC IS AS FOLLOWS:
  
                ----- 
           CALL LINCA(6Hsgmnm ,6Hsbrnm ,arg1,arg2,...)
                ----- 
  
      WHERE sgmnm = SEGMENT NAME (NAME MUST BE FILLED TO 6 CHAR. BY BLANKS) 
            sbrnm = SUBROUTINE NAME (NAME MUST BE FILLED TO 6 CHAR. BY BLANKS)
            arg1,arg2,... = ARGUMENTS FOR SUBROUTINE sbrnm (<=30) 
  
      THE MAIN PROGRAM IN A SEGMENT HAS THE FOLLOWING FORM: 
  
           PROGRAM sgmnm,5
           EXTERNAL subr1,subr2,... 
           QDATA LS /subr1 subr2 .../ 
                ----- 
           CALL LINCB(LS,subr1,subr2,...) 
                ----- 
           END
  
      WHERE sgmnm = NAME OF SEGMENT 
            subr1, subr2, ... = SUBROUTINES IN SEGMENT WHICH CAN BE CALLED (<=20) 
                                THE ORDER IN ARRAY LS AND IN THE CALL TO LINCB
                                MUST BE IDENTICAL.  IN ARRAY LS EACH NAME MUST
                                OCCUPY 6 CHARACTERS LEFT-ADJUSTED WITH TRAILING 
                                BLANKS. 
  
      ENTRY LINCA SAVES THE ARGUMENT VECTOR AND OTHER INFORMATION INTERNALLY
      BEFORE GETTING THE SEGMENT (IF IT IS NOT IN CORE) OR TRANSFERRING DIRECTLY
      TO THE SEGMENT (IF IT IS ALREADY IN CORE).  AN ERROR MESSAGE (FORMAT BELOW) 
      IS PRINTED ON THE SYSTEM CONSOLE IF MORE THAN 30 ARGUMENTS ARE PASSED.
  
      ENTRY LINCB SEARCHES FOR THE CORRECT SUBROUTINE USING THE LIST GIVEN IN 
      ARRAY LS.  WHEN THE PROPER ENTRY IS FOUND, CONTROL IS TRANSFERRED.  IF THE
      PROPER ENTRY IS NOT FOUND, THE PROGRAM IS ABORTED.  AN ERROR MESSAGE IS 
      PRINTED ON THE SYSTEM CONSOLE WITH THE SEGMENT AND SUBROUTINE CALLED.  THE
      RETURN ADDRESS FOR THE LINCA CALL IS IN THE A REGISTER AND THE NUMBER OF
      ARGUMENTS TO THE SUBROUTINE IS IN THE B REGISTER. 
  
      AT LEAST 3 LEVELS OF SEGMENTS MAY BE CALLED, I.E., THE ROOT CALLS SUBR1 IN
      SGMN1 WHICH CALLS SUBR2 IN SGMN2 WHICH CALLS SUBR3 IN SGMN3.  MORE LEVELS 
      CAN BE CALLED IF FEWER THAN 30 ARGUMENTS ARE PASSED.  AN ERROR MESSAGE IS 
      PRINTED ON THE SYSTEM CONSOLE IF THE STACK OVERFLOWS. 
  
      IF NESTING IS USED, ALL THE ROUTINES IN THE CHAIN MUST BE CALLED USING
      LINCA.  ONCE IN A SEGMENT, LINCA CAN BE USED TO CALL ANOTHER SUBROUTINE 
      WITHIN THE CURRENT SEGMENT IF THAT SUBROUTINE IS EXPECTED TO CALL A 
      SUBROUTINE IN ANOTHER SEGMENT.  LOCAL VARIABLES ARE PRESERVED AS LONG AS
      THE SAME SEGMENT IS CONTINUOUSLY IN CORE. 
  
      SINCE SEGMENTS ARE RE-INITIALIZED EACH TIME THEY ARE RECALLED FROM DISK, IT 
      IS THE RESPONSIBILITY OF THE USER TO ASSURE THAT THE NECESSARY LOCAL
      VARIABLES ARE RESTORED AND THAT ARGUMENTS ARE PRESENT IN CORE WHEN NEEDED.
      ARGUMENTS PASSED MUST BE IN THE ROOT OR IN SAVED/RESTORED LABELED COMMON. 
      IN THE LATTER CASE, THE ORDER OF LABELED COMMON MUST BE IDENTICAL IN THE
      CALLING AND CALLED SEGMENTS SO THAT THE ARGUMENTS WILL HAVE THE SAME
      ADDRESSES.  ARGUMENTS MAY BE PASSED FROM THE ROOT TO ANY LEVEL OF 
      SUBROUTINE. 
  
""
LINK           (original by M.C. Cote,HP) 
------
  
      LINKS FROM MAIN PROGRAM TO SEGMENT AND RETURNS BACK TO MAIN PROGRAM.
  
      CALLING SEQUENCE: 
  
           ---------- 
      CALL LINK(ISEG) 
           ---------- 
  
           WHERE ISEG IS THE ARRAY CONTAINING THE DESIRED SEGMENT NAME. 
  
        LINK SCHEDULES THE SEGMENT AND THE SEGMENT SHOULD THEN RETURN 
        TO THE MAIN BY A
  
                    ----- 
               CALL RETRN 
                    ----- 
  
          WHERE RETRN IS AN ENTRY POINT IN LINK AND RETURNS CONTROL 
                      TO THE ORIGINAL CALLING POINT IN THE MAIN 
  
""
LINQ           (now superseded by LINC package - included here for completeness)
------
      LINQ IS A GENERAL SEGMENT CONTROLLER WHICH ALLOWS THE USER TO CALL
      SPECIFIC SUBROUTINES IN A SEGMENT AND TO PASS AN ARGUMENT LIST BY 
      ADDRESS TO THE SUBROUTINE IN THE SEGMENT.  A SEGMENT IS RETAINED IN 
      CORE UNTIL IT IS NECESSARY TO GET A DIFFERENT SEGMENT.
  
      THE USER CALL TO LINQ IS AS FOLLOWS:
  
        IN THE ROOT:
  
           CALL LINQA(NSEG,NAMSEG,NSUB,NARG,ARG1,ARG2,...)
  
        IN A SEGMENT: 
  
           CALL LINQS(NSEG,NAMSEG,NSUB,0) 
  
      WHERE NSEG = SEGMENT NUMBER (ARBITRARY, ASSIGNED BY USER) 
            NAMSEG = SEGMENT NAME (ASSIGNED BY USER)
            NSUB = SUBROUTINE NUMBER (ARBITRARY, ASSIGNED BY USER)
            NARG = NUMBER OF ARGUMENTS (PRESENTLY <= 15, CHANGE THE LINE
                                        IARGS BSS  15 FOR DIFFERENT LIMIT)
            ARG1,ARG2,... = ARGUMENTS FOR SUBROUTINE
  
      THE MAIN PROGRAM IN A SEGMENT HAS THE FOLLOWING FORM: 
  
           PROGRAM SEGNN,5
           CALL LINQB(NSUB) 
           IF(NSUB.EQ.1) GO TO 100
           IF(NSUB.EQ.2) GO TO 200
           ...
     100   CALL LINQC 
           CALL SUBR1(ARG1,ARG2,...)
           CALL LINQD 
     200   CALL LINQC 
           CALL SUBR2(ARG1,ARG2,...)
           CALL LINQD 
           ...
           END
  
      ENTRY LINQA SAVES THE ARGUMENT VECTOR AND OTHER INFORMATION INTERNALLY
      BEFORE GETTING THE SEGMENT (IF IT IS NOT IN CORE) OR TRANSFERRING DIRECTLY
      TO THE SEGMENT (IF IT IS ALREADY IN CORE).  THE SEGMENT NUMBER IS USED
      TO CHECK IF THE SEGMENT IS ALREADY IN CORE.  THE USER MUST MAKE SURE
      THAT THE SEGMENT NUMBER AND SEGMENT NAME CORRESPONDENCE IS MAINTAINED.
  
      ENTRY LINQS IS IDENTICAL TO LINQA EXCEPT THAT IT IS USED TO CALL A
      DIFFERENT SEGMENT FROM A LOADED SEGMENT AND NO ARGUMENTS (CURRENTLY)
      CAN BE PASSED.  LINQA MUST NOT BE USED WITHIN A SEGMENT!!!
  
      ENTRY LINQB PASSES THE SUBROUTINE NUMBER TO THE SEGMENT MAIN PROGRAM AND
      SETS UP THE ADDRESS FOR DIRECT TRANSFER TO THE SEGMENT.  ENTRY LINQB
      SHOULD BE CALLED AS THE FIRST EXECUTABLE STATEMENT OF THE SEGMENT MAIN. 
      ANY STATMENTS WHICH PRECEDE THE CALL TO LINQB WILL ONLY BE EXECUTED 
      IMMEDIATELY AFTER THE SEGMENT IS LOADED.  THE SUBROUTINE NUMBER IS USED 
      TO SELECT WHICH OF SEVERAL SUBROUTINES IS TO BE EXECUTED. 
  
      ENTRY LINQC TRANSFERS THE SAVED ARGUMENT LIST TO THE REAL CALL TO THE 
      ACTUAL EXECUTED SUBROUTINE.  THE CALL TO THE SUBROUTINE MUST HAVE THE 
      CORRECT NUMBER OF ARGUMENTS AND MUST IMMEDIATELY FOLLOW THE CALL TO 
      LINQC.
  
      ENTRY LINQD RETURNS TO THE USER ROOT PROGRAM AT THE POINT FOLLOWING THE 
      CALL TO LINQA.
  
""
LOC 
------
  
      FUNCTION LOC(I) 
  
      FUNCTION TO RETURN THE ABSOLUTE LOCATION OF I IN USER MAP.
  
""
LROT     (Obsolete) 
------
  
      FUNCTION TO ROTATE BITS WITHIN A 16-BIT WORD
  
      K=LROT(M,N) WILL ROTATE THE CONTENTS OF M BY N BITS (+LEFT,-RIGHT)
              AND SET THE RESULT INTO K  (-16<=N<=16) 
  
""
LUOPR 
----- 
      INTEGER FUNCTION LUOPR(IDUM)
  
      This routine returns the session lu to which the calling
      program is attached.
      This routine performs a function identical to HP function LOGLU 
      except that there is no return in IDUM and hence LUOPR may
      be called 'LUOP=LUOPR()'. 
  
""
MSCHK 
------
      LOGICAL FUNCTION MSCHK(ISC) 
  
      Checks that ISC is system master security code. 
         MSCHK=.TRUE.  if ISC is same as system master security code
         MSCHK=.FALSE. if ISC is not same as system master security code
  
""
NAMOK          (from C. Boozer, UCSD) 
------
        Verifies that 6-character name is valid NAMR format 
  
      CALLING SEQUENCE: 
        IRTN = NAMOK(INAME) 
  
      PARAMETERS OR ARGUMENTS: (TYPE) 
        IRTN......Return code (0=is NAMR, -1=is not NAMR) 
        INAME.....6-character name to check 
  
""
NARG
------
       When called as the FIRST EXECUTABLE STATEMENT in a host FORTRAN
       routine, returns # of arguments in call to host routine. 
  
            NARGS=NARG(IDUMY) 
                   where IDUMY= dummy argument (must be present)
                         NARGS= # of arguments in call to host routine
                         B-reg return: Direct address of 1st DEF in parameter list
                                       of the routine CALLING the host routine. 
  
       *****WARNING!!!  NARG will not work if any arrays in the FTN4 host routine 
                        are dimensioned with dummy values which are passed
                        through as parameters to the routine. 
       *****WARNING!!!  NARG works unpredictably under an FTN4X host routine and
                        its use is not recommended.  Use the intrinsic function 
                        PCOUNT instead. 
  
       May be called in an ASMB routine immediately following JSB .ENTR as follows: 
                            ENT SUBR
                            EXT NARG
                      ARGS  BSS n 
                      SUBR  NOP 
                            JSB .ENTR 
                            DEF ARGS
                            JSB NARG         Get # of calling arguments-- 
                            NOP              (Must include this NOP)
                            NOP              (Must include this NOP)
                            etc...
                                             B-reg returns direct address of 1st
                                                DEF in parameter list of the routine
                                                CALLING the host routine. 
  
""
NEXTX 
----- 
      Routine to force FMP to search out and open the next extent, if any.
  
      Calling sequence: 
        IERR=NEXTX(IDCB)
  
      The error returns are:
             0  No error
            -1  Disc error
            -5  No more extents 
           -11  DCB not open
  
""
PUTC
------
      SUBROUTINE PUTC(IBUF,I,IASC)
  
      PUTS CHARACTER WITH ASCII VALUE IASC INTO THE I-th POSITION OF IBUF.
      THE FIRST CHARACTER IN IBUF IS CHARACTER #1.
      I MAY HAVE ANY VALUE POSITIVE OR NEGATIVE.
      USES ONLY LOWER ORDER EIGHT BIT OF IASC.
  
""
PUTINCOMMAS 
----------- 
      CALL PUTINCOMMAS (STRING)     Make spaces into commas 
  
   PUTINCOMMAS is intended to work exactly as the RTE subroutine by the 
   same name.  It deletes spaces on either side of existing commas, 
   packs strings of spaces to one space, and converts those to commas.
   Trailing blanks remain blank.  The conversion is done in place, and
   the resulting string is never longer than the original.
  
   This version was developed to save space and time, and to eliminate
   the 256-character limitation of the RTE version. 
  
   PUTINCOMMAS is called as follows from Fortran: 
  
      CALL PUTINCOMMAS (STRING) 
  
   Where STRING is the character variable which is to be altered. 
  
""
PUTS
------
      CALL PUTS(ADDRESS,VALUE)
  
      MODIFIES SPECIFIED LOCATION IN SYSTEM MAP TO SPECIFIED VALUE. 
      WORKS WITH ALL GARDEN VARIETIES OF RTE II/III/IV/M. 
  
""
RMAN           (original by R.J. Niland,HP) 
------
      ROUTINE PURPOSE:
      INVERSE OF LIBRARY ROUTINE NAMR, I.E. 
      FORMATS 10 WORD PARSED NAMR ARRAY INTO 1-48 BYTE
      ASCII NAMR BUFFER OF THE FORM:
      name:security:crlu:type:filesize:recsize:future 
      THERE WILL BE NO LEADING, EMBEDDED OR TRAILING BLANKS 
      IN THE OUTPUT namr. 
  
      ENTRY PROTOCOL-PARAMETERS:
      CALL RMAN (IPBUF,IASCII,LENGTH,ISTRC) 
      CALL ABREG (IA,IB)
      where: IA&IB  = A&B RETURNS.
             IPBUF  = 10-WORD NAMR COMPONENTS ARRAY.
             IASCII = BUFFER IN WHICH ASCII NAMR WILL GO. 
             LENGTH = SIZE OF [IASCII] IN +BYTES. 
                      RMAN WILL STOP AT LAST BYTE.
             ISTRC  = BYTE# IN [IASCII] AT WHICH [RMAN ]
                      WILL STORE ASCII NAMR.
      note: ISTRC MUST BE A VARIABLE, AND MUST BE 
            INITIALIZED PRIOR TO CALLING [RMAN ]. 
            [RMAN ] WILL UPDATE ISTRC.
  
      EXIT: REGISTER STATUS:
      A  : LENGTH OF RETURNED ASCII NAMR IN +BYTES. 
      B  : ADDRESS OF NEXT BYTE AFTER RETURNED namr.
      E,O: UNDEFINED. 
      S  : UNCHANGED. 
      X,Y: SAVED & RESTORED.
      ISTRC: ENTRY VALUE + #BYTES IN OUTPUT namr. 
  
      ERROR HANDLING: 
      -BITS 14,15 OF IPBUF(04) IGNORED. 
      -FILE NAME IPBUF(1-3) PROCESSED EVEN IF (04)=0 OR (04)=2H  .
      -1ST 3 WORDS OF IPBUF PRESUMED TO BE ASCII. 
      -IF THERE ARE INSUFFICIENT BYTES IN [IASCII] FOR
       THE OUTPUT namr, [RMAN ] MAY TERMINATE IN
       MID-PARAMETER. 
  
""
SORT
------
      SUBROUTINE SORT(IDATA,NREC,LREC,IOFST,LEN,IBUF) 
  
      General-purpose sort routine
  
      IDATA      = array of words to be sorted (in place) 
      NREC       = total # records to be sorted 
      LREC       = length (words) of each record
      IOFST      = offset of key field in words (0=beginning) 
      LEN        = length (words) of key field
      IBUF       = scratch buffer of length >=LREC  
  
      Note: This sorting routine is stable in the sense that identical
            entries will not be interchanged on return.  It is generally
            somewhat slower than a Shell sort, particularly for large 
            arrays of data. 
  
""
SORTR 
------
  
      SUBROUTINE SORTR (idata,numrec,lenrec,keyoff,keylen,ibuf) 
      SORTR sorts an array of character data via the Shell sort algorithm 
      from Knuth's sorting & searching volume, p.85, Algorithm D. 
      This algorithm runs in N log N time.
      Parameters: 
          idata  - array of character records to be sorted (in place) 
          numrec - total number of records
          lenrec - length in bytes of each record 
          keyoff - offset of key field in columns (0=record beginning)
          keylen - key length in bytes
          ibuf   - scratch buffer of length lenrec
  
      Usage note: This sorting routine is unstable, i.e. - records having 
                  identical keys may be interchanged. This might be a problem 
                  for a multiple-pass (least to most significant) sort. This
                  unwanted scrambling may be avoided simply by including the
                  record number at entry as the least significant field in
                  the sort keys.
  
""
SQZEM 
------
      INTEGER FUNCTION SQZEM(IBUF,N)  
     .,Squeeze out spaces in ASCII buffer  ARW 820208 
  
      Routine to squeeze out all ASCII spaces (40B) from IBUF, where
      N = +words/-chars in IBUF.
      IBUF is returned with all non-space characters left-justified, and
      is filled with spaces to the right. 
      SQZEM returns # of non-space characters processed.
  
""
SSWCH          (by M.C. Cote,HP)
------
      SSWCH is Fortran-callable routine used to output bit patterns to the
      display register.  It may be called as a subroutine or a function.
      When used as a function, the configuration of the display of the register 
      is returned in the A-reg and the status is returned in the B-reg. 
  
      FORM OF CALL: 
           DIMENSION IDUMY(2) 
           EQUIVALENCE (IDUMY,SWITCH),(IDUMY(2),ISTAT)
           .
           .
           .
           SWITCH = SSWCH(MODE,NUMBR) 
  
      IDUMY(1) NOW CONTAINS THE DISPLAY REGISTER CONFIGURATION AND
      ISTAT CONTAINS A COMPLETE STATUS (B=0) OR AN ERROR (B<0)
  
      PARAMETERS ARE: 
      MODE ; NUMBR ;         FUNCTION 
  
       -1    ANY    CLEAR THE DISPLAY REGISTER
        0    0-15   DISPLAY REGISTER BIT NUMBER TO BE SET 
        1    0-15   DISPLAY REGISTER BIT NUMBER TO BE CLEARED 
        2    ANY    INTEGER BIT PATTERN TO BE SET 
        3    ANY    INTEGER BIT PATTERN FOR INCLUSIVE OR WITH 
                      THE CURRENT DISPLAY REGISTER PATTERN. 
        4    ANY    INTEGER BIT PATTERN FOR LOGICAL AND WITH
                      THE CURRENT DISPLAY REGISTER PATTERN. 
        5    ANY    INTEGER BIT PATTERN FOR EXCLUSIVE OR WITH 
                      THE CURRENT DISPLAY REGISTER PATTERN. 
  
""
STRAK 
------
      EXPANDABLE FIXED-RECORD-LENGTH FILE HANDLER 
  
      THIS PROGRAM PROVIDES DISK STORAGE HANDLING ON THE SYSTEM TRACKS. 
      IT ALLOWS THE USER TO WRITE FIXED LENGTH RECORDS TO THE SYSTEM
      TRACKS WITHOUT WORRYING ABOUT ULTIMATE FILE SIZE. "STRAK" ALLOCATES 
      STORAGE ON AN AS NEEDED BASIS UP TO A LIMIT DEFINED IN ITS INTERNAL 
      TRACK TABLE. CURRENTLY, A MAXIMUM OF 50 TRACKS MAY BE ALLOCATED.
  
      For details, see routines STOPN, STRED, STWRT, ISTLC. 
  
""
STOPN     (routine in STRAK package)
             -----
        CALL STOPN(N):
             -----
          N <= 0 MEANS RELEASE ALL TRACKS ASSIGNED TO PROGRAM.
          N >  0 MEANS DEFINE RECORD SIZE AS "N" WORDS IF IT HAS NOT
                 ALREADY BEEN DEFINED AND RESET THE SEQUENTIAL ACCESS 
                 POINTER. 
  
        CALL STOPN(0) SHOULD BE DONE AT PROGRAM TERMINATION.
        TRACK ALLOCATION REQUESTS TO THE SYSTEM BY "STRAK" MAY CAUSE THE
        PROGRAM TO BE SUSPENDED IF THERE ARE NO TRACKS LEFT.
  
""
STRED     (routine in STRAK package)
             -----
        CALL STRED(IER,IBUF,IREC):
             -----
          IER = ERROR CODE, ALSO RETURNED IN A REGISTER. CODES LISTED BELOW.
          IBUF = BUFFER TO READ INTO. 
          IREC = RECORD #. 0 OR NOT GIVEN MEANS USE NEXT SEQUENTIAL RECORD. 
  
          A RECORD MAY BE READ BEFORE IT IS WRITTEN.
  
""
STWRT     (routine in STRAK package)
             -----
        CALL STWRT(IER,IBUF,IREC):
             -----
          SAME AS STRED EXCEPT ITS A WRITE OPERATION. 
  
""
ISTLC     (routine in STRAK package)
             -----
        IREC=ISTLC(IDUM)
             -----
          RETURNS CURRENT POSITION IN FILE (=1 WHEN REWOUND)
  
  
      ERROR CODES RETURNED IN IER AND THE A REGISTER: 
  
        0 = O.K.
       -4 = UNDEFINED RECORD SIZE 
       -6 = NO ROOM.
  
""
SUBCH 
------
      Get/set lu subchannels
      
      CALL SUBCH(LU,IPREV,[ISUB]) 
  
      On entry: 
          LU,    lu# about which information is sought or 
                 subchannel# is to be set 
          ISUB,  (optional) subchannel# to which LU is to be set
*     On return:
          IPREV, current subchannel# to which lu is set (before any change) 
  
      Compatible with RTE-2,3,IV,IVB,6VM. 
      Do-nothing with RTE-A.
  
""
SUSP           (originally written for DOS by author unknown) 
------
      PROGRAM PURPOSE:  SELF SUSPEND FOR A GIVEN TIME.
                        IF PROGRAM IS IN TIME LIST, IT WILL BE RESTORED 
                        TO TIME LIST AFTER SELF-SUSPEND.
  
      INPUTS:  RESOLUTION CODE
                 1  TENS OF MILLISECONDS
                 2  SECONDS 
                 3  MINUTES 
                 4  HOURS 
               MULTIPLE--THE NUMBER OF HOURS, MINUTES,ETC TO BE SUSPENDED 
                         AS INDICATED BY THE RESOLUTION CODE. 
  
      OUTPUT:  NONE 
  
      FORTRAN CALL: 
         CALL SUSP (IRSL,IMULT) 
  
                    WHERE IRSL IS THE RESOLUTION CODE AND IMULT IS THE
                          MULTIPLE OF THE RESOLUTION CODE.
                          E.G.  IF IMULT=20  & IRSL=1  THEN SUSPENSION
                                TIME IS 200MSEC.
                          IMMEDIATE RETURN IF IMULT<=0
  
""
TIMR
------
      REAL FUNCTION TIMR (INDEX)  
  
      THIS FUNCTION MEASURES ELAPSED TIME UNDER PROGRAM CONTROL 
                    IF INDEX = 0 , THE "TIMER" IS STARTED 
                                   AND THE RETURNED VALUE IS THE
                                   CURRENT TIME IN SECONDS IN THE DAY.
                    IF INDEX = 1 , THE ELAPSED TIME SINCE THE LAST
                                   RESET IS RETURNED, AND THE TIMER 
                                   IS RESET.
                    IF INDEX =-1 , THE ELAPSED TIME IS RETURNED 
                                   JUST LIKE INDEX = 1, BUT THE 
                                   TIMER IS NOT RESET.
  
      DOUBLE PRECISION ARITHMETIC IS USED INTERNALLY TO MINIMIZE
      ROUND-OFF ERRORS IN THE CALCULATION OF ELAPSED TIMES. 
  
""
UCASE 
------
      SUBROUTINE UCASE(IBUF,LBUF) 
  
      Change contents of buffer IBUF to all upper-case. 
      LBUF is length of buffer (+words, -chars).
  
""
UNAME 
------
      SUBROUTINE UNAME(NAME,N)
     .,Create unique scratch-file name   ARW 861219 
  
      Return (hopefully) unique 6-char file name that can be used 
      as a scratch-file name. 
  
      On entry: 
          N,     n'th scratch file (1-26) 
  
      On return:
          NAME,  6-char ASCII name in following format: 
                     chars 1-3  first 3-chars of calling program name 
                           4-5  last 2 digits of operator (system) lu 
                             6  A-Z (corresponding to N=1-26, respectively) 
  
""
WCSF    (not RTE-A compatible)
------
  
      SUBROUTINE WCSF(ISC,IBLOCK,NAME,ISECR,ICR,IERR) 
  
      ROUTINE TO WRITE AND VERIFY DATA TO 12978A/13197A CONTROL STORE.
      MICROCODE INPUT IS FROM STANDARD FILE MANAGER FILE OF ASSEMBLED 
         MICROCODE. 
  
      CALLING PARAMETERS: 
      ISC   - SELECT CODE OF 12978A/13197A CONTROL STORE CARD 
      IBLOCK=IBLK2*100B+IBLK1 (FOR 13197A CARD) 
              WHERE IBLK1=LOGICAL BLOCK# ASSIGNED TO FIRST PHYSICAL BLOCK 
                    IBLK2=LOGICAL BLOCK# ASSIGNED TO SECOND PHYSICAL BLOCK
            =0 FOR 12978A WCS CARD
      NAME  - ASCII NAME OF FILE CONTAINING ASSEMBLED MICROCODE 
      ISECR - SECURITY CODE OF FILE "NAME" (0 IF NONE)
      ICR   - CARTRIDGE LU OF FILE "NAME" (0 IF DON'T KNOW) 
      IERR  - RETURNED ERROR CODE 
              0-NORMAL COMPLETION 
             <0-SEE CORRESPONDING FMGR ERROR CODE 
              1-BLOCK NUMBER ERROR
              2-PREMATURE EOF IN FILE "NAME"
              3-RECORD LENGTH ERROR IN FILE "NAME"
              4-MICROCODE ORG INCONSISTENT WITH BLOCK ASSIGNMENT
              5-INTERNAL INCONSISTENCY IN RECORD
              6-VERIFY ERROR
              7-WCS OVERFLOW
  
""
ICOMP 
------
  
      INTEGER FUNCTION ICOMP(IX,IY,N) 
  
      Uses high-speed compare-word instruction to compare N words in
      of buffers IX and IY. 
      If the buffers are identical, ICOMP returns =0. 
      If the buffers are not identical, ICOMP returns the word# on  
         which the compare failed.
      First word is #1. 
  
""
WMOVE 
------
      USES FIRMWARE MVW INSTRUCTION TO QUICKLY MOVE ARRAYS OF WORDS FROM
      ONE LOCATION TO ANOTHER.
  
      CALLING SEQUENCE: 
             REG=WMOVE(IWD1,IWD1,NWDS,[MODE]) 
                 where MODE=0 OR ABSENT:
                                IWD1=FIRST WORD OF SOURCE ARRAY 
                                IWD2=FIRST WORD OF DESTINATION ARRAY
                                NWDS=#WORDS TO BE MOVED 
                       MODE<>0: 
                                IWD1=ADDRESS OF FIRST WORD OF SOURCE ARRAY
                                IWD2=ADDRESS OF FIRST WORD OF DESTINATION ARRAY 
                                NWDS=#WORDS TO BE MOVED 
  
             ON RETURN: 
                 (A)=(ADDRESS OF FIRST WORD OF SOURCE ARRAY)+NWDS 
                 (B)=(ADDRESS OF FIRST WORD OF DESTINATION ARRAY)+NWDS
  
      WORDS ARE MOVED STARTING AT TOP OF ARRAY
  
      TIMING ON 21MX-M   -- APPROXIMATELY (70+NWDS*3.25) MICROSECONDS 
      TIMING ON 21MX-E/F -- APPROXIMATELY (40+NWDS*1.68) MICROSECONDS 
  
""
XTNTS 
----- 
      XTNTS is a package of FMP file extent-handling routines.
      Extents to a file may be created with arbitrary sizes and managed 
      individually.  Very useful for certain types of problems where HP's 
      restrictions on extent sizes and usage are inadequate.
      See CRETX, OPENX, PURGX, and LISTX for details. 
  
""
CRETX     (routine in XTNTS package)
               -----
      FUNCTION CRETX(IDCB,IERR,NAME,IXTNT,ISIZE,ITYPE,ICR,[ISC])
               -----
  
      ROUTINE TO FORCE CREATION OF EXTENT OF ARBITRARY SIZE, TYPE, AND NUMBER.
      ROOT EXTENT MAY BE CREATED. 
      IXTNT MUST BE IN RANGE 1 TO 255 INCLUSIVE 
      ISIZE IS A 2-WORD INTEGER ARRAY.
         WORD 1 SPECIFIES THE FILE SIZE IN BLOCKS.
         WORD 2 SPECIFIES THE VALUE TO BE PLACED IN THE RECORD-LENGTH 
                PARAMETER OF THE FILE DIRECTORY ENTRY (ALTHOUGH RECORD
                LENGTH HAS NO FUNCTIONAL SIGNIFICANCE FOR THIS TYPE 
                OF FILE)
      ICR IS CARTRIDGE REF, MUST BE SPECIFIED (I.E. NOT ZERO), AND MAY
          NOT REFER TO LU 2 OR 3. 
      IDCB MUST BE AT LEAST 144 WORDS LONG. 
      ISC (OPTIONAL) IS ASSIGNED SECURITY CODE. 
          IF OMITTED WHEN CREATING AN EXTENT, EXTENT SECURITY CODE IS 
          ASSIGNED TO BE SAME AS ROOT SECURITY CODE.
          IF OMITTED WHEN CREATING ROOT, SECURITY CODE =0 IS ASSIGNED.
          EXTENTS ARE ALWAYS ASSIGNED SAME SECURITY CODE AS ROOT. 
      IERR RETURNS STANDARD FMGR ERROR CODES
  
      A-REG RETURN: IERR
      B-REG RETURN: #FULL TRACKS REMAINING ON CARTRIDGE ON RETURN 
  
      ADDED FEATURE: IF IXTNT<=0 ON ENTRY, AN EXTENT WILL BE CREATED
                 WITH AN EXTENT# ONE GREATER THAN THE LARGEST EXISTING EXTENT.
      ADDED FEATURE: IF ISIZE(1)=0 ON ENTRY, CRETX WILL SEARCH FOR EXISTING 
                     EXTENT IXTNT AND CHANGE ITS RECORD LENGTH TO ISIZE(2). 
  
""
OPENX     (routine in XTNTS package)
               -----
      FUNCTION OPENX(IDCB,IERR,NAME,IXTNT,ICR)
               -----
  
      ROUTINE TO OPEN SPECIFIED EXTENT OF A FILE. 
      IDCB IS RETURNED OPEN FOR USE AS A TYPE 1 FILE
      ICR IS CARTRIDGE REF, MUST BE SPECIFIED (I.E. NOT ZERO), AND MAY
          NOT REFER TO LU 2 OR 3. 
      IDCB MUST BE AT LEAST 144 WORDS LONG. 
      ON SUCCUSSFUL OPEN, IERR RETURNS ACTUAL FILE TYPE.
      OTHERWISE, IERR IS SAME AS FMGR CODES.
      IERR IS ALSO RETURNED IN A-REG. 
      SECURITY CODE IS RETURNED IN B-REG. 
  
""
PURGX     (routine in XTNTS package)
               -----
      FUNCTION PURGX(IDCB,IERR,NAME,IXTNT,ICR)
               -----
  
      ROUTINE TO PURGE SPECIFIED EXTENT OF A FILE.
  
      IDCB MUST BE AT LEAST 144 WORDS LONG. 
      IERR RETURN STANDARD FMGR ERROR CODES, WHICH ARE ALSO RETURNED IN A-REG.
      NAME IS NAME OF FILE. 
      IXTNT IS EXTENT# TO BE PURGED AND CANNOT BE <=0, EXCEPT 
          IF IXTNT=-999, THE ROOT WILL BE PURGED (CAUTION!!!!!!!!!!)
      ICR IS CARTRIDGE REF, MUST BE SPECIFIED (I.E. NOT ZERO), AND MAY
          NOT REFER TO LU 2 OR 3. 
  
""
LISTX     (routine in XTNTS package)
                 -----
      SUBROUTINE LISTX(IDCB,IERR,NAME,ICR,MXTNT,N,LXTNT,LTYPE,LRECL,
                 -----
     .                 LSIZE,LSC,LTRK,LSEC,IARGS) 
  
      ROUTINE TO RETURN LIST OF EXTENTS, TYPES AND SIZES FOR A SPECIFIED FILE 
  
      IDCB MUST BE AT LEAST 144 WORDS LONG. 
      NAME IS THE NAME OF THE FILE. 
      ICR IS CARTRIDGE REF, MUST BE SPECIFIED (I.E. NOT ZERO), AND MAY
          NOT REFER TO LU 2 OR 3. 
      MXTNT RETURNS HIGHEST EXTENT# FOUND. RETURN=-1 IF NONE FOUND. 
      N - ON ENTRY, INDICATES MAXIMUM SIZE OF ARRAYS LXTNT,LTYPE,LRECL, 
                    LSIZE,LSC,LTRK,LSEC 
          ON RETURN, INDICATES # OF EXTENTS FOUND (INCLUDING ROOT), 
                     OR RETURNS # OF ENTRIES IN ARRAYS LXTNT,ETC IF 
                     ARRAYS TOO SMALL.
      LXTNT IS AN ARRAY RETURNED WITH EXISTING EXTENT #'S 
            (INCLUDES ROOT EXTENT)
      LTYPE IS AN ARRAY RETURNED WITH EXTENT TYPES. 
      LRECL IS AN ARRAY RETURNED WITH EXTENT RECORD LENGTHS.
      LSIZE IS AN ARRAY RETURNED WITH EXTENT SIZES (IN BLOCKS). 
      LSC IS AN ARRAY RETURNED WITH EXTENT SECURITY CODES.
      LTRK IS AN ARRAY RETURNED WITH STARTING TRACK #'s.
      LSEC IS AN ARRAY RETURNED WITH STARTING SECTOR #'s. 
      IARGS - INDICATES WHICH ARRAYS LXTNT,ETC ARE TO BE RETURNED.
              BIT 0 - RETURN ARRAY LXTNT
                  1 - RETURN ARRAY LTYPE
                  2 - RETURN ARRAY LRECL
                  3 - RETURN ARRAY LSIZE
                  4 - RETURN ARRAY LSC
                  5 - RETURN ARRAY LTRK 
                  6 - RETURN ARRAY LSEC 
  
""
YMDAY 
------
      SUBROUTINE YMDAY ( IYEAR, IDAYR, MONTH, IDAY )
  
      IF IDAYR>0, 
          THIS ROUTINE WILL CONVERT IDAYR = ELAPSED DAY-OF-THE-YEAR 
          INTO MONTH AND IDAY. IF IDAYR>365 (OR >366 FOR A LEAP YEAR) 
          THE YEAR WILL BE INCREMENTED ACCORDINGLY, AND IDAYR WILL BE 
          'CORRECTED'.
  
      IF IDAYR <=0, 
          THE MONTH AND IDAY FIELDS WILL BE CONVERTED INTO DAY-OF-THE-
          YEAR AND RETURNED IN IDAYR. 
  
      THIS ROUTINE CALLS IDAY0 ( IYEAR , 0 ) TO GET NUMBER OF DAYS
      IN IYEAR AND IDAY0 ( IYEAR , MONTH ) TO GET THE DAY NUMBER OF 
      THE ZEROTH DAY OF THE MONTH.
  
