FTN4,X
C@NEWPR 
C 
      SUBROUTINE NEWPR(IDCBP1,IDCBP2,ISTACK,INDEX,
     .LPARM,NPARM,LSTACK,LPROC1,LPROC2, 
     .ITMLOG,IBUF,IBLEN,IERR),NEW PROCEDURE C#870115:04:19# 
C 
C     NEWPR - initializes a new procedure by manipulating the stacks
C 
C     DATE   WHO CHANGES
C     810907 NRV Modified for new procedure management
C     840217 MWH Modified stack structure 
D     INCLUDE #FSCOM::FS,1,999
C 
C  INPUT: 
C 
C     IDCBP1,IDCBP2 - DCBs for the two procedure files
C     ISTACK - stack of procedure information 
C              (1) = total number of words available
C              (2) = last word used, if 2 then empty
C              Items are pushed onto the stack in the order:
C              - index into LPROC1,2 array (>0=1,<0=2)
C              - next line number when pushed down
C     INDEX - index into LPROC1,LPROC2 arrays 
C             >0 is LPROC1, <0 is LPROC2
C     LPARM - parameter string specified with this proc 
C     NPARM - number of characters in LPARM 
C     LSTACK - stack of parameters
C              (1) = total number of words
C              (2) = last word used, =2 means empty 
C              The parameter string is pushed first, then 
C              the number of characters in it.
C     LPROC1,2 - procedure directories
C     ITMLOG - time this log file was started 
C     IBUF - buffer for reading 
C     IBLEN - length of IBUF
      DIMENSION ISTACK(1),LSTACK(1),LPARM(1)
      DIMENSION IDCBP1(1),IDCBP2(1),ITMLOG(1),IBUF(1) 
      DIMENSION LPROC1(5,1),LPROC2(5,1) 
C 
C  OUTPUT:
C 
C     IERR - error return.  -1 for stack error, <0 for FMP error. 
C 
C 
C  LOCAL: 
C 
C     LPROCN - procedure name, for logging
C     NREC - next record number in current file, from LOCF
C     ITIME - holds the current system time, for comparing with ITMLOG
C     IREC,IRB,IOFF - position information for current procedure
      DIMENSION ITIME(6),LPROCN(6)
C 
C 
C  INITIALIZED: 
C 
C 
C 
C     1. Determine position information for the new procedure 
C 
      IF(INDEX.GT.0)GOTO 100
        IREC = LPROC2(2,IABS(INDEX))
        IRB = LPROC2(3,IABS(INDEX)) 
        IOFF = LPROC2(4,IABS(INDEX))
        GO TO 200 
100   CONTINUE
      IREC = LPROC1(2,INDEX)
      IRB = LPROC1(3,INDEX) 
      IOFF = LPROC1(4,INDEX)
C 
C 
C     2. Position to the new location in the procedure file.
C     If there are errors, or DEFINE is not on this line, then quit.
C 
200   CONTINUE
D     WRITE(LU,9701) INDEX,(LPROC2(I,IABS(INDEX)),I=1,5)
D9701 FORMAT("INDEX,LPROC2="6I6)
      IF (INDEX.GT.0) CALL APOSN(IDCBP1,IERR,IREC,IRB,IOFF) 
      IF (INDEX.LT.0) CALL APOSN(IDCBP2,IERR,IREC,IRB,IOFF) 
D     WRITE(LU,9702) IERR 
D9702 FORMAT("IERR FROM APOSN="I5)
      IF (IERR.LT.0) GOTO 800 
      IF (INDEX.GT.0) CALL READF(IDCBP1,IERR,IBUF,IBLEN,ILEN) 
      IF (INDEX.LT.0) CALL READF(IDCBP2,IERR,IBUF,IBLEN,ILEN) 
D     WRITE(LU,9703) IERR,(IBUF(I),I=1,ILEN)
D9703 FORMAT("IERR,IBUF FROM READF="I5,1X,20A2) 
      IF (IERR.LT.0) GOTO 800 
C     IF (ILEN.LT.0) GOTO ??
      IF (ICHCM(IBUF,1,6HDEFINE,1,6).NE.0.OR.ILEN.NE.17) GOTO 800 
C 
C 
C     3. Get the time field from the first line and check it against
C     the time the log was opened.
C     If the time the procedure was last logged is later than 
C     the time the log file was started, then we are finished here. 
C     Otherwise, drop through to the logging of this procedure. 
C 
300   CONTINUE
      IF (IAS2B(IBUF,23,2).GT.ITMLOG(6)-1900) GOTO 600
      IF (IAS2B(IBUF,23,2).LT.ITMLOG(6)-1900) GOTO 400
C                   First check the year
      IF (IAS2B(IBUF,25,3).GT.ITMLOG(5)) GOTO 600 
      IF (IAS2B(IBUF,25,3).LT.ITMLOG(5)) GOTO 400 
C                   Then check the day number 
      TIMLOG = ITMLOG(4)*3600.0+ITMLOG(3)*60.0+ITMLOG(2)
      TIMPRC = IAS2B(IBUF,28,2)*3600.0+IAS2B(IBUF,30,2)*60.0+ 
     .         IAS2B(IBUF,32,2) 
      IF (TIMPRC.GT.TIMLOG) GOTO 600
C                   Finally check the time of day, if the dates are equal 
C 
C 
C     4. This procedure needs logging.  Read/log each record. 
C     First pull off the procedure name.
C 
400   CALL ICHMV(LPROCN,1,IBUF,9,12)
D     WRITE(LU,9902) LPROCN 
410   IF (INDEX.GT.0) CALL READF(IDCBP1,IERR,IBUF,IBLEN,ILEN) 
      IF (INDEX.LT.0) CALL READF(IDCBP2,IERR,IBUF,IBLEN,ILEN) 
      IF (ILEN.LT.0.OR.ICHCM(IBUF,1,6HDEFINE,1,6).EQ.0.OR.
     .    ICHCM(IBUF,1,6HENDDEF,1,6).EQ.0) GOTO 500 
      IF (IERR.LT.0) GOTO 800 
D9902 FORMAT("LOGGING PROC="6A2)
      CALL LOGIT(IBUF,ILEN*2,2H&&,LPROCN) 
      GOTO 410
C 
C 
C     5. Finally, update the first line of the procedure with 
C     the current time, to indicate the last time we logged it. 
C 
500   IF (INDEX.GT.0) CALL APOSN(IDCBP1,IERR,IREC,IRB,IOFF) 
      IF (INDEX.LT.0) CALL APOSN(IDCBP2,IERR,IREC,IRB,IOFF) 
      IF (IERR.LT.0) GOTO 800 
      IF (INDEX.GT.0) CALL READF(IDCBP1,IERR,IBUF,IBLEN,ILEN) 
      IF (INDEX.LT.0) CALL READF(IDCBP2,IERR,IBUF,IBLEN,ILEN) 
      CALL EXEC(11,ITIME,ITIME(6))
      CALL IB2AS(ITIME(6)-1900,IBUF,23,2) 
      CALL IB2AS(ITIME(5),IBUF,25,40000B+400B*3+3)
      CALL IB2AS(ITIME(4),IBUF,28,40000B+400B*3+2)
      CALL IB2AS(ITIME(3),IBUF,30,40000B+400B*3+2)
      CALL IB2AS(ITIME(2),IBUF,32,40000B+400B*3+2)
      CALL IB2AS(ITIME(2),IBUF,32,40000B+400B*3+2)
      CALL IFILL(IBUF,34,1,2HXX)
C                   Pad with character to fill in last byte 
      IF (INDEX.GT.0) CALL POSNT(IDCBP1,IERR,-1)
      IF (INDEX.LT.0) CALL POSNT(IDCBP2,IERR,-1)
      IF (INDEX.GT.0) CALL WRITF(IDCBP1,IERR,IBUF,17) 
      IF (INDEX.LT.0) CALL WRITF(IDCBP2,IERR,IBUF,17) 
C 
C 
C     6. Push location information on the stack first.  Then push the       
C     new name onto the stack for retrieval by READP. 
C     Push parameter string and number of character, if any onto stack. 
C 
600   CONTINUE
      IF(INDEX.GT.0)CALL LOCF(IDCBP1,IERR,IREC,IRB,IOFF)
      IF(INDEX.LT.0)CALL LOCF(IDCBP2,IERR,IREC,IRB,IOFF)
      IF(IERR.LT.0)GOTO 800 
      CALL PRPUT(ISTACK,IREC,1,IERR)
      IF(IERR.NE.0)GOTO 800 
      CALL PRPUT(ISTACK,IRB,1,IERR) 
      CALL PRPUT(ISTACK,IOFF,1,IERR)
      CALL PRPUT(ISTACK,INDEX,1,IERR) 
D     WRITE(LU,9921) INDEX,IERR,IREC,IRB,IOFF 
D9921  FORMAT("NEWPR - PUSHING INDEX,IERR,IREC,IRB,IOFF="5I5)   
      IF (NPARM.NE.0) CALL PRPUT(LSTACK,LPARM,(NPARM+1)/2,IERR) 
D     WRITE(LU,9922) NPARM,IERR 
D9922 FORMAT("NEWPR - PUSHING LPARM,IERR=(IF NON ZERO)"2I5) 
      IF (IERR.NE.0) GOTO 800 
      CALL PRPUT(LSTACK,NPARM,1,IERR) 
D     WRITE(LU,9910) NPARM,IERR 
D9910 FORMAT("NEWPR - PUSHING NPARM,IERR="2I5)
      IF (IERR.NE.0) GOTO 800 
D     WRITE(LU,9903) (ISTACK(I),I=1,14) 
D9903 FORMAT("STACK:"14I5)
D     WRITE(LU,9905) (LSTACK(I),I=1,22) 
D9905 FORMAT("LSTCK:"2I3,20A2)
      GOTO 900
C 
C 
C     8. This is the abnormal error section.  There should be no
C     errors in this routine because all of the file has been checked 
C     before.  So this is serious.
C 
800   IF (IERR.EQ.-1) CALL LOGIT(0,0,0,1,-128,2HBO,IERR)
      IF (IERR.NE.-1) CALL LOGIT(0,0,0,1,-129,2HBO,IERR)
      ISTACK(2) = 2 
      LSTACK(2) = 2 
C 
C 
900   RETURN
      END 
