FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      SUBROUTINE FM(IP)
C 
C 1.1.   FM controls the formatter
C 
C     INPUT VARIABLES:
C 
      DIMENSION IP(1) 
C        IP(1)  - class number of input parameter buffer. 
C 
C     OUTPUT VARIABLES: 
C        IP(1) - CLASS
C        IP(2) - # REC
C        IP(3) - ERROR
C        IP(4) - who we are 
C 
C 2.2.   COMMON BLOCKS USED 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C 2.5.   SUBROUTINE INTERFACE:
C     CALLED SUBROUTINES: GTPRM,JCHAR 
C 
C 3.  LOCAL VARIABLES 
C        NCHAR  - number of characters in buffer
C        ICH    - character counter 
      DIMENSION IBUF(20)                      !  class buffer
      DIMENSION IPARM(2)
C               - parameters returned from GTPRM
      DIMENSION IREG(2) 
C               - registers from EXEC calls 
C        INP,IMODE,IRATE,ISYN 
C               - indices for input, mode, rate, synch test 
      DIMENSION LZEROS(3) 
C               - fill in unused characters 
      DIMENSION LAUX(6) 
C              - auxilliary data, from user 
C     NCHAUX - number of chars in aux data
C 
      LOGICAL KFMRST
C                - formatter reset
C 
      EQUIVALENCE (REG,IREG(1)),(PARM,IPARM(1)) 
C 
C 4.  CONSTANTS USED
      PARAMETER (ILEN=40)                    !  LENGTH OF IBUF, CHARACTERS
C 
C 5.  INITIALIZED VARIABLES 
      DATA LZEROS/2H00,2H00,2H00/ 
C 
C 6.  PROGRAMMER: NRV
C     LAST MODIFIED:  880127 by LAR - disabled automatic formatter reset
C# LAST COMPC'ED  870115:04:34 #
C
C     PROGRAM STRUCTURE
C
C     1. If we have a class buffer, then we are to set the FM.
C     If no class buffer, we have been requested to read the FM.
C
      DO I=1,6
        LAUX(I) = LAUXFM(I)
      ENDDO
      KFMRST=.FALSE.
      ICHOLD = -99
      ICLCM = IP(1)
      IF (ICLCM.EQ.0) THEN
        IERR = -1
        GOTO 990
      ENDIF
      REG = EXEC(21,ICLCM,IBUF,-ILEN)
      NCHAR = IREG(2)
      IEQ = ISCNC(IBUF,1,NCHAR,75B) 
C                   Scan for "="
      IF (IEQ.EQ.0) THEN
C 
C     2.  This is the read device section.
C     Fill up two class buffers, one requesting ( data (mode -3), 
C     the other ) (mode -4).
C 
        IBUF(2) = 2HFM
        ICLASS = 0
        DO I=3,4
          IBUF(1) = -I
          CALL EXEC(20,0,IBUF,-4,2HFS,0,ICLASS)
        ENDDO
C 
        NREC = 2
C 
C 
      ELSE IF (IEQ.NE.NCHAR.AND.JCHAR(IBUF,IEQ+1).EQ.77B) THEN
        IP(1) = 0
        IP(4) = 77B
        CALL FMDIS(IP,ICLCM)
        RETURN
C 
      ELSE IF (ICHCM(IBUF,IEQ+1,LTSRS,1,ILENTS).EQ.0) THEN
C
C     3. This is the test/reset device section. 
C 
        IBUF(1) = 6
        IBUF(2) = 2HFM
        ICLASS=0
        CALL EXEC(20,0,IBUF,-4,2HFS,0,ICLASS)
        NREC = 1
C
C
      ELSE IF (ICHCM(IBUF,IEQ+1,LTSRS,6,5).EQ.0) THEN
C
C     4. This is the request for a plain reset.
C
        NCH = 5
        IBUF(1) = 8
        IBUF(2) = 2HFM
        IBUF(3) = 2H+
        ICLASS = 0
        CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
        KFMRST = .TRUE.
        NREC = 1
C
      ELSE IF (ICHCM(IBUF,IEQ+1,LALRM,1,ILENAL).EQ.0) THEN
C
C     5. This is the alarm query and reset request.
C
        IBUF(1) = 7
        IBUF(2) = 2HFM
        ICLASS = 0
        CALL EXEC(20,0,IBUF,-4,2HFS,0,ICLASS)
        NREC = 1
C
      ELSE          ! SET FORMATTER
C
C
C     6. Step through buffer getting each parameter and decoding it.
C     Command from user has these parameters:
C                   FM=<output>,<rate>,<input>,<synch>,<aux>,<MATmode>
C     Choices are <input>: NOR, EXT, CRC.  Default NOR.
C                <output>: A, B, C, D.  Default mode B.
C                  <rate>: 0.125,0.25,0.5,1,2,4,8.  Default 4.
C                 <synch>: ON or OFF.  Default ON.
C                   <aux>: auxilliary data, up to 12 hex characters.
C                          Default is current value.
C
C     6.1 OUTPUT, PARAMETER 1
C
        ICH = 1+IEQ
        IC1 = ICH
        CALL GTPRM(IBUF,ICH,NCHAR,0,PARM)
C                   Get the mode, ASCII.  The default mode is B.
        IF (JCHAR(PARM,1).EQ.52B) THEN
          IMODE = IMODFM
        ELSE IF (JCHAR(PARM,1).EQ.54B) THEN
          IMODE = 1
        ELSE
          CALL IFMED(1,IMODE,IBUF,IC1,ICH-2)
          IF (IMODE.LT.0) THEN
            IERR = -201
            GOTO 990
          ENDIF
        ENDIF
C 
C     6.2 SAMPLE RATE, PARAMETER 2
C 
        IC1 = ICH
        CALL GTPRM(IBUF,ICH,NCHAR,2,PARM)
C                   Get the sample rate setting, real number
        IF (JCHAR(PARM,1).EQ.52B) THEN
          IRATE = IRATFM
        ELSE IF (JCHAR(IPARM,1).EQ.54B) THEN
          IRATE = 7      !  The default sample rate is 4 Mbits
        ELSE
          CALL IFMED(2,IRATE,IBUF,IC1,ICH-2)
          IF (IRATE.LT.0) THEN
            IERR = -202
            GOTO 990
          ENDIF
        ENDIF
C 
C     6.3 INPUT, PARAMETER 3
C 
        IC1=ICH
        CALL GTPRM(IBUF,ICH,NCHAR,0,PARM)
        IF (JCHAR(PARM,1).EQ.52B) THEN
          INP = INPFM
        ELSE IF (JCHAR(PARM,1).EQ.54B) THEN
          INP = 0      !  Defaults to NORmal
        ELSE
          CALL IFMED(3,INP,IBUF,IC1,ICH-2)
          IF (INP.LT.0) THEN
            IERR = -203
            GOTO 990
          ENDIF
        ENDIF
C 
C     6.4 SYNCH TEST, PARAMETER 4 
C 
        IC1 = ICH
        CALL GTPRM(IBUF,ICH,NCHAR,0,PARM)
        IF (JCHAR(IPARM,1).EQ.52B) THEN
          ISYN = ISYNFM
        ELSE IF (JCHAR(IPARM,1).EQ.54B) THEN
          ISYN = 1         !  Default value is "ON"
        ELSE
          CALL IFMED(4,ISYN,IBUF,IC1,ICH-2)
          IF (ISYN.LT.0) THEN
            IERR = -204
            GOTO 990
          ENDIF
        ENDIF
C
C     6.5 AUX DATA, PARAMETER 5
C
        IC1 = ICH
        CALL GTPRM(IBUF,ICH,NCHAR,0,PARM)
        NCHAUX = 0
        IF (JCHAR(PARM,1).NE.54B) THEN
C                   If no aux data, skip on
          NCHAUX = MIN0(ICH-IC1-1,12)
          IDUMM1 = ICHMV(LAUX,1,LAUXFM,1,12)
          IDUMM1 = ICHMV(LAUX,1,IBUF,IC1,NCHAUX)
C                   Use max of 4 chars, rest is old AUX field
        ENDIF
C
C     6.6 MAT MODE, PARAMETER 6
C
C260   CALL GTPRM(IBUF,ICH,NCHAR,1,PARM)
C     IMMODE = 0
C     IF (JCHAR(PARM,1).NE.54B) IMMODE = IPARM(1)
C     IF (IMMODE.GE.0.AND.IMMODE.LE.5) GOTO 300
C     IERR = -206
C     GOTO 990
C 
C     7. Finally, format the buffer for the controller. 
C     We have a valid LINP,LMODE,RATE,LSYN.  The buffer is set
C     up as follows:
C                   mmFM00000smr  then  ; 
C     where each letter represents a character (half word). 
C                   mm = mode, binary integer 
C                   FM = tells MAT formatter
C                    ; = strobe character for set-up data 
C                   00 = these bits unused
C                   s  = synch test 
C                   m  = input/output mode
C                   r  = sample rate code 
C 
        IBUF(1) = 0
        IBUF(2) = 2HFM
C        IDUMM1 = ICHMV(IBUF,5,2H; ,1,1)
C                   ***NOTE*** FOR JIM LEVINE'S FORMATTER WE MUST SEND
C                   THE STROBE *AFTER* THE DATA UPDATE
C                   Strobe character for first word 
        IDUMM1 = ICHMV(IBUF,5,LZEROS,1,5)
C                   Fill unused fields with zeros 
        IDUMM1 = IB2AS(ISYN,IBUF,10,1)
C                   Synch test bit has its own character
        IDUMM1 = ICHMV(IBUF,11,IHX2A(INP*4+IMODE),2,1)
C                   Put input and output into one word (2 bits each)
        IDUMM1 = IB2AS(IRATE,IBUF,12,1)
C                   Last character is sample rate 
C 
C 
C     8. Now plant these values into COMMON.
C     Next send the buffer to SAM.
C     Finally schedule BOSS to request that MATCON gets the data. 
C 
        ICHOLD = ICHECK(17)
        ICHECK(17) = 0
        INPFM = INP
        IMODFM = IMODE
        IRATFM = IRATE
        ISYNFM = ISYN
        IDUMM1 = ICHMV(LAUXFM,1,LAUX,1,4)
C 
        ICLASS=0
        NCH = 12
        CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C 
        NCH = 3
        IBUF(1) = 5
        IBUF(2)=2H;
        CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C                   ***NOTE***SEND THE STROBE CHARACTER AS SEPARATE 
C                   MESSAGE FOR JIM LEVINE'S FORMATTER
C                   USE MODE 5 TO SIMPLY TRANSMIT THIS CHARACTER
        NREC = 2
C
C IF AUX DATA, SEND TWO MORE BUFFERS, WITH ! AND % CONTROLS
        IF (NCHAUX.NE.0) THEN
C
          IBUF(1) = 0
          IBUF(2) = 2HFM
          IDUMM1 = ICHMV(IBUF,5,LAUX,1,8)
          NCH = 12
          CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C                   Send out the first 8 chars ...
          IBUF(1) = 5
          IBUF(2) = 2H!
          NCH = 3
          CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C                   ... as ! type data
          IBUF(1) = 0
          IBUF(2) = 2HFM
          IDUMM1 = ICHMV(IBUF,5,LAUX,9,4)
          IDUMM1 = ICHMV(IBUF,9,LZEROS,1,4)
          NCH = 12
          CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C                   Send out the last 4 chars and zeros ...
          IBUF(1) = 5
          IBUF(2) = 2H%
          NCH = 3
          CALL EXEC(20,0,IBUF,-NCH,2HFS,0,ICLASS)
C                   ... as % type data
          NREC = 6
        ENDIF
      ENDIF
C
C     9. All MATCN requests are scheduled here, and then FMDIS called.
C
      CALL EXEC(23,6HMATCN ,ICLASS,NREC)
      CALL RMPAR(IP)
      IF(KFMRST) CALL SUSP(2,1)
      IF (ICHOLD.NE.-99) ICHECK(17)=ICHOLD
      IF (ICHOLD.GE.0) ICHECK(17)=MOD(ICHOLD,1000)+1
      CALL FMDIS(IP,ICLCM)
      RETURN
C
990   IP(1) = 0
      IP(2) = 0
      IP(3) = IERR
      IP(4) = 2HQF
      RETURN
      END
