FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      PROGRAM QUIKR(3)    !  QUICK RESPONSE COMMANDS     <910607.1726>
C
C QUIKR is the root for all quick-response applications
C              functions in the Field System
C
C     INPUT VARIABLES:
C         IP(1) - class number containing invocation line
C         IP(2) - branch number, encoded
C
C     OUTPUT VARIABLES:
C         IP(1) - class number, if any
C         IP(2) - number of records in class
C         IP(3) - IERR error code return
C         IP(4) - who caused the error
C
C     COMMON BLOCKS USED
          INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C 3.  LOCAL VARIABLES
      DIMENSION IP(5)                     !  RMPAR variables
C
C 6.  PROGRAMMERS: NRV (1980), LEF (1987), LAR (1988)
C  WHO  WHEN    DESCRIPTION
C  GAG  910116  Added calls to WEH's new tape head calibration routines.
C  GAG  910124  Removed callS to LOWHI and PARTN.
C  GAG  910205  Rejoined QUIK1 and QUIK2 into this one file.
C
C     PROGRAM STRUCTURE :
C  Get RMPAR parameters, then call the subroutine whose number is in IP(2).
C
      CALL RMPAR(IP)
      CALL LIBER(LU)
C  This exec call locks this program into memory so it cannot be swapped.
      CALL EXEC(22,1)
      CALL LOCK_MATCN
      isub = ip(2)/100
      itask = ip(2) - 100*isub
      if (isub.eq.1) then
        call fm(ip)
      else if (isub.eq.2) then
        call vc(ip,itask)
      else if (isub.eq.3) then
        call ifd(ip)
      else if (isub.eq.4) then
        if (itask.eq.1.or.itask.eq.8) then
          call ma(ip,itask)
        else if (itask.eq.2) then
          call ib(ip)
        else if (itask.eq.3) then
          call cable(ip)
        else if (itask.eq.4) then
          call wx(ip)
        else if (itask.eq.5) then
          call wakop(ip)
        else if (itask.eq.6) then
          call chk(ip)
        else if (itask.eq.7) then
          call cal(ip)
        endif
      else if (isub.eq.5) then
        if (itask.eq.1) then
          call tp(ip)
        else if (itask.eq.2) then
          call tppos(ip)
        else if (itask.eq.3) then
          call feet(ip)
        endif
      else if (isub.eq.6) then
        if (itask.eq.1) then
          call st(ip)
        else if (itask.eq.2) then
          call et(ip)
        else if (itask.GE.3.AND.itask.LE.6) then
          call rwff(ip,itask)
        endif
      else if (isub.eq.7) then
        if (itask.eq.1) then
          call reset(ip)
        else if (itask.eq.2) then
          call newtp(ip)
        else if (itask.eq.3) then
          call label(ip)
        else if (itask.eq.4) then
          call matld(ip)
        end if
      else if (isub.eq.8) then
        call ena(ip)
      else if (isub.eq.9) then
        if (itask.eq.1) then
          call de(ip)
        else if (itask.eq.2) then
          call pe(ip)
        else if (itask.eq.3) then
          call party(ip)
        endif
      else if (isub.eq.10) then
        call repro(ip)
      else if (isub.eq.11) then
        if (itask.eq.1) then
          call sorce(ip)
        else if (itask.eq.2) then
          call rdoff(ip)
        else if (itask.eq.3) then
          call aeoff(ip)
        else if (itask.eq.4) then
          call onsor(ip)
        else if (itask.eq.6) then
          call xyoff(ip)
        else if (itask.eq.7) then
          call track(ip)
        endif
      else if (isub.eq.12) then
        if (itask.eq.1.or.itask.eq.2) then
          call ctemp(ip,itask)
        else if (itask.eq.5.or.itask.eq.6) then
          call tsys(ip,itask)
        else
          call tpi(ip,itask)
        endif
C for WVR stations only    else if (isub.eq.13) then
      else if (isub.eq.14) then
        if (itask.eq.1) then
          call pcalc(ip)
        else if (itask.eq.2) then
          call loset(ip)
        else if (itask.eq.3) then
          call patch(ip)
        else if (itask.eq.4) then
          call pcals(ip)
        endif
      else if (isub.eq.15) then
        if (itask.eq.1) then
          call lgout(ip)
        else if (itask.eq.2) then
          call oprid(ip)
        else if (itask.eq.3) then
          call fvpnt(ip)
        else if (itask.eq.4) then
          call onofc(ip)
        else if (itask.eq.5) then
          call pc(ip)
        else if (itask.eq.6) then
          call fsvrs(ip)
        endif
      else if (isub.eq.16) then
       call rxmo(ip)
C     else if (isub.eq.17) then
C       if (itask.eq.1) then
C         call head(ip)
C       endif
      else if (isub.eq.18) then
        call tpform(ip)
      else if (isub.eq.19) then
        if (itask.eq.1.or.itask.eq.2) then
          call beam(ip,itask)
        else if (itask.eq.3.or.itask.eq.4) then
          call flux(ip,itask)
        endif
      else if (isub.eq.20) then
        if (itask.eq.1) then
          call ucmo(ip)
        endif
      else if (isub.eq.21) then
        if (itask.eq.1) then
          call pass(ip)
        else if (itask.eq.2) then
          call stack(ip)
        else if (itask.eq.3) then
          call lvdt(ip,itask)
        else if (itask.eq.4) then
          call peak(ip)
        else if (itask.eq.5) then
          call savev(ip)
        else if (itask.eq.6) then
          call hdcalc(ip)
        else if (itask.eq.7) then
          call hecho(ip)
        else if (itask.eq.8) then
          call locate(ip)
        else if (itask.eq.9) then
          call worm(ip)
        else if (itask.eq.10) then
          call hdata(ip)
        endif
      endif
      if (ip(1).ne.0) call CLRQ(1,ip(1),0)    ! Renounce ownership of class
C                           so that it won't be deallocated when QUIKR ends
      CALL UNLOCK_MATCN
      call prtn(ip)
      call EXEC(6,0,-1)
      END
