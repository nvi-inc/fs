FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
C 
      SUBROUTINE IFDIS(IP,ICLCM)  !  IF DISTRIBUTOR DISPLAY <880922.1239>
C 
C 1.1.   IFDIS gets data from the IF distributor and displays it
C 
C 2.  IFDIS INTERFACE 
C 
      DIMENSION IP(1) 
C     INPUT VARIABLES:
C        IP(1)  - class number of buffer from MATCN 
C        IP(2)  - number of records in class
C        IP(3)  - error return from MATCN 
C        IP(4)  - 
C        ICLCM  - class number of command buffer
C 
C     OUTPUT VARIABLES: 
C        IP(1) - CLASS
C        IP(2) - # RECS 
C        IP(3) - ERROR
C        IP(4) - who we are 
C 
C 2.2.   COMMON BLOCKS USED 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C 2.5.   SUBROUTINE INTERFACE:
C     CALLING SUBROUTINES: IFD
C     CALLED SUBROUTINES: character utilities 
C 
C 3.  LOCAL VARIABLES 
      DIMENSION IBUF(30)                    ! Input class buffer
      DIMENSION IBUF2(30)                   ! Output display buffer
      DIMENSION ITP(10)                     ! Buffer for ! data with TP
      LOGICAL KCOM,KDATA
      DIMENSION IREG(2)                     ! Registers from EXEC calls
      EQUIVALENCE (REG,IREG(1)) 
      INTEGER NCH                           ! Character counter
C 
C 4.  CONSTANTS USED:
      PARAMETER (ILEN=60)                   ! Length of buffers, characters
C 
C     PROGRAMMER: NRV
C     LAST MODIFIED: 800215 
C 
C     PROGRAM STRUCTURE 
C 
C     1. First check error return from MATCN.  If not 0, get out
C     immediately.
C 
C 
      KCOM = IP(4).EQ.77B 
C 
      ICLASS = IP(1)
      NCREC = IP(2) 
      IERR = IP(3)
      NREC = 0
C 
      IF (.NOT.KCOM .AND. (IERR.LT.0 .OR. ICLASS.EQ.0 .OR. ICLCM.EQ.0))
     : RETURN
C 
C     2. Get class buffer with command in it.  Set up first part
C     of output buffer.  Get first buffer from MATCN. 
C 
      REG = EXEC(21,ICLCM,IBUF2,-ILEN)
C 
      NCHAR = IREG(2) 
      NCH = ISCNC(IBUF2,1,NCHAR,75B)                 ! Scan for "="
      KDATA = NCH.EQ.0
C                   If our command was only "device" we are waiting for 
C                   data and know what to expect. 
      IF (NCH.EQ.0) NCH = NCHAR+1 
C                   If no "=" found, position after last character
      NCH = ICHMV(IBUF2,NCH,2H/ ,1,1)         ! Put / to indicate a response
C 
      IF (.NOT.KCOM .AND. .NOT.KDATA) THEN
        DO I=1,NCREC
          IF (I.NE.1) NCH=MCOMA(IBUF2,NCH)      ! Commas separate parameters
          REG = EXEC(21,ICLASS,IBUF,-ILEN)
          NCHAR = IREG(2)
          NCH = ICHMV(IBUF2,NCH,IBUF(2),1,NCHAR-2)
C                   Move buffer contents into output list 
        ENDDO
      ELSE
        IF (KCOM) THEN
          IA1 = IAT1IF
          IA2 = IAT2IF
          IN1 = INP1IF
          IN2 = INP2IF
        ELSE
          REG = EXEC(21,ICLASS,ITP,-10)
          REG = EXEC(21,ICLASS,IBUF,-10)
C 
C     3. Now the buffer contains: IFD=, and we want to add the data.
C 
          CALL MA2IF(IBUF,ITP,IA1,IA2,IN1,IN2,TP1IFD,TP2IFD,IREMIF)
        ENDIF
C 
        IERR = 0
        NCH = NCH + IB2AS(IA1,IBUF2,NCH,100000B+2)   ! 1st attenuator setting
        IF (IA1.NE.IAT1IF) IERR = -301
        NCH = MCOMA(IBUF2,NCH)
        NCH = NCH + IB2AS(IA2,IBUF2,NCH,100000B+2)   ! 2nd attenuator setting
        IF (IA2.NE.IAT2IF) IERR = -302
        NCH = MCOMA(IBUF2,NCH)
        NCH = IIFED(-1,IN1,IBUF2,NCH,ILEN)           ! Encode IF1 input
        IF (IN1.NE.INP1IF) IERR = -303
        NCH = MCOMA(IBUF2,NCH)
        NCH = IIFED(-1,IN2,IBUF2,NCH,ILEN)           ! Encode IF2 input
        IF (IN2.NE.INP2IF) IERR = -304
C 
        IF (.NOT.KCOM) THEN
          NCH = MCOMA(IBUF2,NCH)
          NCH = IIFED(-2,IREMIF,IBUF2,NCH,ILEN)      ! Encode remote/local
          NCH = MCOMA(IBUF2,NCH)
          NCH = NCH + IR2AS(TP1IFD,IBUF2,NCH,6,0) - 1
          NCH = MCOMA(IBUF2,NCH)
          NCH = NCH + IR2AS(TP2IFD,IBUF2,NCH,6,0) - 1
        ENDIF
      ENDIF
C 
C     5. Now send the buffer to SAM and schedule PPT. 
C 
      ICLASS = 0
      NCH = NCH - 1 
      CALL EXEC(20,0,IBUF2,-NCH,2HFS,0,ICLASS)
      IF (.NOT.KCHECK) IERR = 0 
      IP(1) = ICLASS
      IP(2) = 1 
      IP(3) = IERR
      IP(4) = 2HQI
      RETURN
      END 
