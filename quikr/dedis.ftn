FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
C@DEDIS
C
      SUBROUTINE DEDIS(IP,ICLCM),DECODER DISPLAY C#870115:04:38#
C
C 1.1.   DEDIS gets data from the decoder.
C
C     INPUT VARIABLES:
C
      DIMENSION IP(1)
C        IP(1)  - class number of buffer from MATCN
C        IP(2)  - number of records in class
C        IP(3)  - error return from MATCN
C
C     OUTPUT VARIABLES:
C
C        IP(1) - error
C        IP(2) - class
C        IP(3) - number of records
C        IP(4) - who we are
C
C 2.2.   COMMON BLOCKS USED
C
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C 2.5.   SUBROUTINE INTERFACE:
C
C     CALLED SUBROUTINES: character utilities
C
C 3.  LOCAL VARIABLES
C
      DIMENSION IBUF(5,5),IBUF2(30),IAS(10)
C               - input class buffers, output display buffer
C        ILEN   - length of buffers, chars
C        NCH    - character counter
C        I      - bit, converted to 0 or 1
C        IA     - hex char from MAT
      DIMENSION LMODE(12),NR(6),NC(6)
C                 - mode names, number of records, number of characters
      DIMENSION IERRC(3,3),IERRCN(3)
      LOGICAL KCOM,KDATA,KCRC,KBIT
C              - true if COMMON variables wanted
C
      DIMENSION IREG(2)
C               - registers from EXEC
      EQUIVALENCE (REG,IREG(1))
C
C 4.  CONSTANTS USED
C
C 5.  INITIALIZED VARIABLES
C
      DATA ILEN/10/
      DATA NR/2,1,2,3,1,5/
      DATA NC/3,3,4,4,3,3/
      DATA LMODE  /2HAU,2HX ,2HSY,2HN ,2HTI,2HME,2HDA,2HTA,2HER,2HR ,
     &             2HCR,2HC /
      DATA IERRC  /2HBY,2HTE,2H  ,2HFR,2HAM,2HE ,2HRE,2HSE,2HT /
      DATA IERRCN /4,5,6/
      DATA LCHAN/2HAB/
C
C 6.  PROGRAMMER: NRV
C     LAST MODIFIED: CREATED 790319
C# LAST COMPC'ED  870115:04:38 #
C
C     PROGRAM STRUCTURE
C
C     1. First check error return from MATCN.  If not 0, get out
C     immediately.  If setup data wanted ( ? ), skip class read.
C 
      KCOM = IP(4).EQ.77B 
C 
      ICLASS = IP(1)
      NCREC = IP(2) 
      IERR = IP(3)
      NREC = 0
C 
      IF (KCOM) GOTO 200
      IF (IERR.LT.0) GOTO 990 
      IF (ICLASS.EQ.0.OR.ICLCM.EQ.0) GOTO 990 
C 
C 
C     2. Get class buffer with command in it.  Set up first part
C     of output buffer.  Get first buffer from MATCN. 
C 
200   REG = EXEC(21,ICLCM,IBUF2,-ILEN)
C 
      NCHAR = IREG(2) 
      NCH = ISCNC(IBUF2,1,NCHAR,75B)
C                   Scan for "="
      KDATA = NCH.EQ.0
C                   If our command was only "device" we are waiting for 
C                   data and know what to expect. 
      IF (NCH.EQ.0) NCH = NCHAR+1 
C                   If no "=" found, position after last character
      NCH = ICHMV(IBUF2,NCH,2H/ ,1,1) 
C                   Put / to indicate a response
C 
      IF (KCOM) GOTO 310
      IF (KDATA) GOTO 230 
C 
      DO 220 I=1,NCREC
        IF (I.NE.1) NCH=MCOMA(IBUF2,NCH)
C                   If not first parm, put comma before 
        REG = EXEC(21,ICLASS,IBUF,-ILEN)
        NCHAR = IREG(2) 
C       NCH = ICHMV(IBUF2,NCH,IBUF(2),1,NCHAR-2)
        NCH = ICHMV(IBUF2(1),NCH,IBUF(2,1),1,NCHAR-2)
C                   Move buffer contents into output list 
220     CONTINUE
      GOTO 500
C 
230   DO 240 I=1,NR(IMODDC) 
        REG = EXEC(21,ICLASS,IBUF(1,I),-ILEN) 
        REG = EXEC(21,ICLASS,IBUF(1,I),-ILEN) 
C                   Now we have disposed of the ACK buffers 
        REG = EXEC(21,ICLASS,IBUF(1,I),-ILEN) 
240     CONTINUE
        IF (NCREC.GT.3*NR(IMODDC)) CALL CLRCL(ICLASS) 
C 
C 
C     3. Now the buffer contains: DECODE=<chan>,<mode>, and we want to add
C     the data. 
C     Format of data received from decoder: 
C
C     DEdddddddd
C     where each "d" is a character with data.  We only report the
C     characters directly.
C
310   NCH = ICHMV(IBUF2,NCH,LCHAN,ICHAND+1,1)
      NCH = MCOMA(IBUF2,NCH)
      NCH = ICHMV(IBUF2,NCH,LMODE,IMODDC*4-3,NC(IMODDC))
      IF (KCOM) THEN
         NCH=MCOMA(IBUF2,NCH)
         NCH=ICHMV(IBUF2,NCH,IERRC(1,IERRDC_FS),1,IERRCN(IERRDC_FS))
         GOTO 500
      ENDIF
C
      IF(IMODDC.NE.6) THEN
        DO I=1,NR(IMODDC)
          NCH = MCOMA(IBUF2,NCH)
          NCH = ICHMV(IBUF2,NCH,IBUF(1,I),3,8)
        ENDDO
      ELSE
        IN=1
        DO I=1,5
          DO J=2,5
            IN=ICHMV(IAS,IN,IA22H(IBUF(J,I)),2,1)
          ENDDO
        ENDDO
        ICRC=IAND(007777B,IAS(10))
        ISTATE=0
        IN=1
        CALL CRCC(12,7003B,ISTATE,IAS,IN,148,0,0)
        NCH=MCOMA(IBUF2,NCH)
        kcrc=.true.
        DO i=1,12
          kcrc=kcrc.and.(kbit(icrc,i).eqv.kbit(istate,13-i))
        enddo
        IF(kcrc) THEN
          NCH=ICHMV(IBUF2,NCH,4HPASS,1,4)
        ELSE
          NCH=ICHMV(IBUF2,NCH,4HFAIL,1,4)
            CALL LOGIT(0,0,0,0,-301,2HQD,0)
        ENDIF
      ENDIF
C
C     5. Now send the buffer to SAM.
C
500   ICLASS = 0
      NCH = NCH - 1
      CALL EXEC(20,0,IBUF2,-NCH,2HFS,0,ICLASS)
C                   Send buffer starting with TP to display
C
      IP(1) = ICLASS
      IP(2) = 1
      IP(3) = 0
      IP(4) = 2HQD
990   RETURN
      END
