FTN77,Y,I  
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      PROGRAM FIVPT(3,48),SCAN CONTROL PROGRAM C#860809:03:13#
C
C   Discrete Source Scan program, scan nominally consists of FIVe PoinTs
C
C   This program utilizes the Field System and is highly dependent on it.
C
C
      INTEGER FTRY
      REAL LATOSV,LONOSV,LATPS1,LONPS1,LATPS2,LONPS2,LATOFF,LONOFF
      REAL LATPOS,LONPOS,LTRCHI,LNRCHI,LONOFS,LATOFS
      REAL LTPAR,LNPAR,LTLIOF,LNLIOF
      EXTERNAL FGAUS
C
      DIMENSION TIM(31), TEMP(31), OFF(31), TMPLIN(4), TIMLIN(4)
      DIMENSION LTPAR(5), ELTPAR(5), LNPAR(5), ELNPAR(5),IT(6)
      DIMENSION LBUF(40)
C
D     DIMENSION OFFO(31)                                                 
C
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
      INCLUDE /FS/INCLUDE/DPI.FTNI
C
C NOTE: THE FOLLOWING VARIABLES ARE READ FROM THE FSCOM:
C 
C       XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, DIAMAN
C       LAXFP, CALFP, LDEVFP, NREPFP, FREQFP, INTPFP, STEPFP, ANGLFP
C 
C       ADDITONALLY, CHECK THE CALLED SUBROUTINES 
C 
      DATA FTRY/20/,TOL/1E-3/,NWAIT/30/,LWHO/2HFP/
      DATA NMB/5/,IERR/0/,VFIVPT/1.00/,ISBUF/80/,NTSYS/5/ 
C
C  GET RID OF ANY BREAKS THAT WERE HANGING AROUND
C
      IF(IFBRK(IDUM).LT.0) GO TO 1
1     CONTINUE
C
C   0. Set-up and do preliminary work
C
C        Beamwidth Calculation
C
      BW = BMFP_FS
      NMB=INTPFP
      NTSYS=INTPFP
C
D     ORA=RADAT*180./PI
D     ODEC=DECDAT*180./PI
D     WRITE(LU,991) ORA,ODEC
D991  FORMAT(" FIVPT: RA, DEC ",2F12.3)
C
C        Write SOURCE, SITE, ORIGIN, and FIVEPT log entries
C
      CALL EXEC(11,IT,IT(6))
      RUT=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.0+FLOAT(IT(2)) 
      CALL SORCE(RUT,IT(5),IT(6),LBUF,ISBUF)  
      CALL SITE(VFIVPT,LBUF,ISBUF)
      CALL FIVP(LBUF,ISBUF) 
C 
C        Save old offsets 
C 
      XOSAV=XOFF
      YOSAV=YOFF
      AZOSAV=AZOFF
      ELOSAV=ELOFF
      HAOSAV=-RAOFF 
      DCOSAV=DECOFF 
      CALL REOFF(LONOSV,LATOSV,IERR)
      IF(IERR.NE.0) GO TO 80010 
      SAVLN2=LONOSV 
      SAVLT2=LATOSV 
C 
      CALL ORIGN(XOSAV,YOSAV,AZOSAV,ELOSAV,HAOSAV,DCOSAV,LBUF,ISBUF)
C 
C     WAIT TO ACQUIRE SOURCE
C 
      NWT=NWAIT 
      IF(IPGST(6HAQUIR ).LE.0) NWT=300  
      CALL ONSOR(NWT,IERR)
      IF(IERR.NE.0) GO TO 80010 
C 
C   1. Get System Temperature OFF source
C 
      CALL OFFCO(5.0*BW,AZOF,ELOF,AZT,ELT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
C
      CALL GOOFF(AZOSAV+AZOF,ELOSAV+ELOF,4HAZEL,NWAIT*2,IERR)
      IF(IERR.NE.0) GO TO 80010
C
      CALL TSYS(TEMPS,SIGTS,TPIA,TIMA,VBASE,VSLOPE,NTSYS,RUT,IERR)
      IF(IERR.NE.0) GO TO 80010
C
D     WRITE(LU,9900) TEMPS,TPIA,VBASE,VSLOPE
D9900 FORMAT(" TEMPS, TPIA, VBASE, VSLOPE =",4F10.3)
C
      CALL WTSYS(TEMPS,SIGTS,AZT,ELT,NTSYS,LBUF,ISBUF)
C
      CALL GOOFF(AZOSAV,ELOSAV,4HAZEL,-1,IERR)
      IF(IERR.NE.0) GO TO 80010
C
C    MAIN LOOP
C
      ITER=IABS(NREPFP)
10    CONTINUE
C
      ILAT=0
      ILON=0
C
C  REMEMBER WHERE WE ARE
C 
      CALL LOCAL(LONPS1,LATPS1,LAXFP,IERR)
      IF(IERR.NE.0) GO TO 80010 
      COSLAT=COS(LATPS1)
C 
D     OLATP1=LATPS1*180./PI                                              
D     OLONP1=LONPS1*180./PI                                              
D     WRITE(LU,9855) OLONP1,OLATP1,COSLAT                                
D9855 FORMAT(3F20.10)                                                    
C 
C   2.Latitude Scan 
C 
      BSTEP=STEPFP*BW
      STEPLT=BSTEP
      START= LATOSV-FLOAT((NPTSFP/2))*BSTEP
      LONOFF=LONOSV
C
      IF(NPTSFP.GE.5) GO TO 90
C
C  GET FIRST LINEARITY POINT
C
      LTLIOF=FLOAT(3+(NPTSFP/2))*BSTEP
      CALL GOOFF(LONOFF,LATOSV-LTLIOF,LAXFP,NWAIT*2,IERR)
      IF(IERR.NE.0) GO TO 80010
C
      CALL VOLTS(TPIA,SIG,TIMA,NMB,RUT,IERR)
      IF(IERR.NE.0) GO TO 80010
      TMPLIN(1)=(TPIA-VBASE)*VSLOPE-TEMPS
      TIMLIN(1)=TIMA
      SIG=SIG*VSLOPE
C
      OTOFF=LATOSV-LTLIOF
      CALL DPOIN(4HLIN ,3,1,TIMLIN(1),OTOFF,TMPLIN(1),SIG,NMB,LBUF,
     +          ISBUF)
90    CONTINUE
C
C DO SCAN
C
      DO 100 I=1,NPTSFP
           LATOFF=START+FLOAT(I-1)*BSTEP
           IF(I.EQ.1.AND.NPTSFP.GT.3) THEN
             CALL GOOFF(LONOFF,LATOFF,LAXFP,NWAIT*2,IERR)
           ELSE
             CALL GOOFF(LONOFF,LATOFF,LAXFP,NWAIT,IERR)
           ENDIF
           IF(IERR.NE.0) GO TO 80010
           CALL VOLTS(TPIA,SIG,TIMA,INTPFP,RUT,IERR)
           IF(IERR.NE.0) GO TO 80010
           TEMP(I)=(TPIA-VBASE)*VSLOPE-TEMPS
           TIM(I)=TIMA
           SIG=SIG*VSLOPE
           OFF(I)=LATOFF
C
D          OFFO(I)=LATOFF*180./PI
D          OLATOF=LATOFF*180.0/PI
D          OLONOF=LONOFF*180.0/PI
D          WRITE(LU,9901) TPIA,TEMP(I),TIM(I),OLATOF,OLONOF              
D9901 FORMAT(" VOLTS, TEMP, TIM, LAT & LON =",5F10.3)                    
C 
           CALL DPOIN(4HLAT ,3,I,TIM(I),OFF(I),TEMP(I),SIG,INTPFP,
     +                LBUF,ISBUF)   
100        CONTINUE 
C 
C   SECOND LINEARITY POINT
C 
      IF(NPTSFP.GE.5) GO TO 140 
      CALL GOOFF(LONOFF,LATOSV+LTLIOF,LAXFP,NWAIT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
      CALL VOLTS(TPIA,SIG,TIMA,NMB,RUT,IERR)    
      IF(IERR.NE.0) GO TO 80010 
      TMPLIN(2)=(TPIA-VBASE)*VSLOPE-TEMPS 
      TIMLIN(2)=TIMA
      SIG=SIG*VSLOPE
      OTOFF=LATOSV+LTLIOF 
      CALL DPOIN(4HLIN ,3,2,TIMLIN(2),OTOFF,TMPLIN(2),VSLOPE,NMB, 
     +           LBUF,ISBUF)  
C 
C    REMOVE LINEAR DRIFT
C 
D      WRITE(LU,9840) (OFFO(I),TIM(I),TEMP(I),I=1,NPTSFP)                
D9840  FORMAT(/3F20.6)                                                   
C 
       CALL UNSLP(TMPLIN,TIMLIN,TEMP,TIM,NPTSFP,SLOPE,CONST)  
C 
D      WRITE(LU,9840) (OFFO(I),TIM(I),TEMP(I),I=1,NPTSFP)                
D      WRITE(LU,9841) SLOPE,CONST                                        
C 
140    CONTINUE 
C 
C   3. FIT TO A GAUSSIAN
C 
       TMID=TIM((NPTSFP+1)/2) 
      LTPAR(5) = (TEMP(NPTSFP)-TEMP(1))/(TIM(NPTSFP)-TIM(1))
      LTPAR(4) = TEMP(1)+LTPAR(5)*(TMID-TIM(1)) 
      IF(NPTSFP.LT.5) LTPAR(4)=0.0
      IF(NPTSFP.LT.5) LTPAR(5)=0.0
      ELTPAR(4)=0.0 
      ELTPAR(5)=0.0 
C 
       TIM(1)=TIM(1)-TMID 
       TMAX=TEMP(1)-(LTPAR(4)+LTPAR(5)*TIM(1))
       IMAX=1 
       DO 150 I=2,NPTSFP
              TIM(I)=TIM(I)-TMID
              TI=TEMP(I)-(LTPAR(4)+LTPAR(5)*TIM(I)) 
              IF(TMAX.GE.TI) GO TO 150  
              TMAX=TI 
              IMAX=I
150           CONTINUE
C 
D     WRITE(LU,9842) TMAX,IMAX                                           
D9842 FORMAT(" TMAX, IMAX = ",2F20.10)                                   
C 
      LTPAR(1) = TMAX 
      LTPAR(2) = OFF(IMAX)
      LTPAR(3) = BW 
C 
      NPAR=3
      IF(NPTSFP.GE.5) NPAR=5
      CALL FIT2(OFF,TEMP,TIM,LTPAR,ELTPAR,NPTSFP,NPAR,TOL,FTRY,FGAUS, 
     +          LTRCHI,IERR)
C 
      IF(NPTSFP.LT.5) LTPAR(4)=CONST
      IF(NPTSFP.LT.5) LTPAR(5)=SLOPE
C 
D     WRITE(LU,9841) (LTPAR(I),ELTPAR(I),I=1,5)                          
D9841 FORMAT(/2F20.10)                                                   
C 
      CALL FITOT(6HLATFIT,6,LTPAR,IERR,LBUF,ISBUF)
      CALL ERROT(6HLATERR,6,ELTPAR,LTRCHI,LBUF,ISBUF) 
C 
      IF(LTPAR(2).GT.OFF(1).AND.LTPAR(2).LT.OFF(NPTSFP).AND.    
     + IERR.GT.0 ) ILAT=1   
      DIFFLT=ABS(LTPAR(2)-LATOSV) 
      IF(ILAT.EQ.1) LATOSV = LTPAR(2)   
      IF(NREPFP.LT.0.AND.ITER.GT.1.AND.DIFFLT.GT.BW*.2) ILAT=0  
      IERR=0  
C 
C   4. SCAN IN LONGITUDE
C 
      BSTEP=STEPFP*BW/COSLAT
      STEPLN=BSTEP  
      START= LONOSV-FLOAT((NPTSFP/2))*BSTEP 
      LATOFF=LATOSV 
C 
      IF(NPTSFP.GE.5) GO TO 190 
C 
C   GET THIRD LINEARITY POINT 
C 
      LNLIOF=FLOAT(3+(NPTSFP/2))*BSTEP
      CALL GOOFF(LONOSV-LNLIOF,LATOFF,LAXFP,NWAIT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
      CALL VOLTS(TPIA,SIG,TIMA,NMB,RUT,IERR)    
      IF(IERR.NE.0) GO TO 80010 
      TMPLIN(3)=(TPIA-VBASE)*VSLOPE-TEMPS 
      TIMLIN(3)=TIMA
      SIG=SIG*VSLOPE
      OTOFF=LONOSV-LNLIOF 
      CALL DPOIN(4HLIN ,3,3,TIMLIN(3),OTOFF,TMPLIN(3),SIG,NMB,
     +          LBUF,ISBUF) 
190   CONTINUE
C 
C  DO SCAN
C 
      DO 200 I=1,NPTSFP 
           LONOFF=START+FLOAT(I-1)*BSTEP
           CALL GOOFF(LONOFF,LATOFF,LAXFP,NWAIT,IERR) 
           IF(IERR.NE.0) GO TO 80010
           CALL VOLTS(TPIA,SIG,TIMA,INTPFP,RUT,IERR)  
           IF(IERR.NE.0) GO TO 80010
           TEMP(I)=(TPIA-VBASE)*VSLOPE-TEMPS
           TIM(I)=TIMA
           SIG=SIG*VSLOPE 
           OFF(I)=LONOFF
C 
D          OFFO(I)=LONOFF*180./PI                                        
D          OLATOF=LATOFF*180.0/PI                                        
D          OLONOF=LONOFF*180.0/PI                                        
D          WRITE(LU,9901) TPIA,TEMP(I),TIM(I),OLATOF,OLONOF              
C 
           CALL DPOIN(4HLON ,3,I,TIM(I),OFF(I),TEMP(I),SIG,INTPFP,
     +                LBUF,ISBUF)   
200        CONTINUE 
C 
      IF(NPTSFP.GE.5) GO TO 240 
C 
C   FOURTH LINEARITY POINT
C 
      CALL GOOFF(LONOSV+LNLIOF,LATOFF,LAXFP,NWAIT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
      CALL VOLTS(TPIA,SIG,TIMA,NMB,RUT,IERR)    
      IF(IERR.NE.0) GO TO 80010 
      TMPLIN(4)=(TPIA-VBASE)*VSLOPE-TEMPS 
      TIMLIN(4)=TIMA
      SIG=SIG*VSLOPE
      OTOFF=LONOSV+LNLIOF 
      CALL DPOIN(4HLIN ,3,4,TIMLIN(4),OTOFF,TMPLIN(4),SIG,NMB,
     +           LBUF,ISBUF)  
C 
C    REMOVE LINEAR DRIFT
C 
D      WRITE(LU,9840) (OFFO(I),TIM(I),TEMP(I),I=1,NPTSFP)                
C 
      CALL UNSLP(TMPLIN(3),TIMLIN(3),TEMP,TIM,NPTSFP,SLOPE,CONST) 
C 
D      WRITE(LU,9840) (OFFO(I),TIM(I),TEMP(I),I=1,NPTSFP)                
D      WRITE(LU,9841) SLOPE,CONST                                        
C 
240    CONTINUE 
C 
C    GET ANOTHER LOCAL COORDINATE POSITON TO AVERAGE WITH THE FIRST 
C 
      CALL LOCAL(LONPS2,LATPS2,LAXFP,IERR)
      IF(IERR.NE.0) GO TO 80010 
C 
      LONPOS=(LONPS1+LONPS2)*.5 
      LATPOS=(LATPS1+LATPS2)*.5 
C 
C   5. FIT TO A GAUSSIAN
C 
       TMID=TIM((NPTSFP+1)/2) 
      LNPAR(5) = (TEMP(NPTSFP)-TEMP(1))/(TIM(NPTSFP)-TIM(1))
      LNPAR(4) = TEMP(1)+LNPAR(5)*(TMID-TIM(1)) 
      IF(NPTSFP.LT.5) LNPAR(4)=0.0
      IF(NPTSFP.LT.5) LNPAR(5)=0.0
      ELNPAR(4)=0.0 
      ELNPAR(5)=0.0 
C 
       TIM(1)=TIM(1)-TMID 
       TMAX=TEMP(1)-(LNPAR(4)+LNPAR(5)*TIM(1))
       IMAX=1 
       DO 250 I=2,NPTSFP
              TIM(I)=TIM(I)-TMID
              TI=TEMP(I)-(LNPAR(4)+LNPAR(5)*TIM(I)) 
              IF(TMAX.GE.TI) GO TO 250  
              TMAX=TI 
              IMAX=I
250           CONTINUE
C 
D     WRITE(LU,9842) TMAX,IMAX                                           
C 
      LNPAR(1) = TMAX 
      LNPAR(2) = OFF(IMAX)
      LNPAR(3) = BW/COSLAT
C 
      NPAR=3
      IF(NPTSFP.GE.5) NPAR=5
      CALL FIT2(OFF,TEMP,TIM,LNPAR,ELNPAR,NPTSFP,NPAR,TOL,FTRY,FGAUS, 
     +          LNRCHI,IERR)
C 
      IF(NPTSFP.LT.5) LNPAR(4)=CONST
      IF(NPTSFP.LT.5) LNPAR(5)=SLOPE
C 
C   CORRECT LON PARAMETERS AND ERRORS 
C 
      LNPAR(3)=LNPAR(3)*COSLAT
      ELNPAR(3)=ELNPAR(3)*COSLAT
C
      CALL FITOT(6HLONFIT,6,LNPAR,IERR,LBUF,ISBUF)
      CALL ERROT(6HLONERR,6,ELNPAR,LNRCHI,LBUF,ISBUF)
C
      IF(LNPAR(2).GT.OFF(1).AND.LNPAR(2).LT.OFF(NPTSFP).AND.
     + IERR.GT.0) ILON=1
      DIFFLN=ABS(LNPAR(2)-LONOSV)
      IF(ILON.EQ.1)  LONOSV = LNPAR(2)
      IF(NREPFP.LT.0.AND.ITER.GT.1.AND.DIFFLN.GT.BW*.2/COSLAT) ILON=0
      IERR=0
C
      SEFD=0.0
      AE  =0.0
      STOC=0.0
      AEDTS=0.0
      IF(ILAT.EQ.1.AND.ILON.EQ.1.AND.LNPAR(1).GT.1E-6) THEN
        STOC=LNPAR(1)/CALFP
        IF(FXFP_FS.GT.0.0) THEN
          SEFD=TEMPS*(FXFP_FS/LNPAR(1))
          AE=LNPAR(1)*2.0*1.380662E0/(FXFP_FS*1E-3*DPI*(DIAMAN/2.0)**2)
          AEDTS=1000.*AE/TEMPS
        ENDIF
      ENDIF
      CALL PRFOT(STOC,SEFD,AE,AEDTS,LBUF,ISBUF)
C
D     WRITE(LU,9841) (LNPAR(I),ELNPAR(I),I=1,5)
C
C    LOOP BACK FOR MORE REPITIONS
C
      ITER=ITER-1
      IF((NREPFP.GT.0.AND.ITER.GT.0).OR.
     +  (NREPFP.LT.0.AND.ITER.GT.0.AND.(ILON.EQ.0.OR.ILAT.EQ.0))) THEN
        CALL OFFOT(LONPOS,LATPOS,LONOSV,LATOSV,ILON,ILAT,LBUF,ISBUF)
         GO TO 10
      ENDIF
      IF(ILAT.EQ.1) SAVLT2=LATOSV
      IF(ILON.EQ.1) SAVLN2=LONOSV
      CALL GOOFF(SAVLN2,SAVLT2,LAXFP,NWAIT,IERR)
      CALL OFFOT(LONPOS,LATPOS,LONOSV,LATOSV,ILON,ILAT,LBUF,ISBUF)
      IF(IERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,IERR,LWHO,2HER)
      GO TO 90000
C
C   ERROR
C
80010 CONTINUE
      XOFF=XOSAV
      YOFF=YOSAV
      AZOFF=AZOSAV
      ELOFF=ELOSAV
      RAOFF=-HAOSAV
      DECOFF=DCOSAV
      ITRY=2
C
80011 CONTINUE
      JERR=0
      CALL GOOFF(LONOSV,LATOSV,LAXFP,NWAIT,JERR)
      ITRY=ITRY-1
      IF(JERR.GT.O.AND.ITRY.GT.0) GO TO 80011
C
      IF(IERR.GT.0) GO TO 89990
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IERR,LWHO,2HER)
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-100,LWHO,2HER)
      GO TO 90000
C
C BREAK DETECTED
C
89990 CONTINUE
      IERR=-1
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IERR,LWHO,2HBR)
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-100,LWHO,2HER)
      GO TO 90000
C
C CLEAN UP AND EXIT
C
90000 CONTINUE
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE REOFF(LONOSV,LATOSV,IERR)
      REAL LONOSV,LATOSV
C 
C  PICK THE APPROPROATE OFFSETS FOR THE GIVEN AXIS SYSTEM 
C 
C  OUTPUT:
C 
C     LONOSV CONTAINS THE LONGITUDE AXIS OFFSET 
C 
C     LATOSV CONTAINS THE LATITUDE  AXIS OFFSET 
C 
C     IERR IS NONZERO IF AN ERROR OCCUURRED 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C        XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, LAXFP 
C 
C  HA/DEC, NOT RA/DEC 
C 
D     CALL EXEC(2,LU,14HENTERING REOFF,-14)                              
      IF(ICHCM(LAXFP,1,4HHADC,1,4).NE.0) GO TO 200
      LONOSV=-RAOFF 
      LATOSV=DECOFF 
      RETURN
C 
C  AZ/EL
C 
200   CONTINUE
      IF(ICHCM(LAXFP,1,4HAZEL,1,4).NE.0) GO TO 400
      LONOSV=AZOFF
      LATOSV=ELOFF
      RETURN
C 
C  X/Y NS 
C 
400   CONTINUE
      IF(ICHCM(LAXFP,1,4HXYNS,1,4).NE.0) GO TO 600
      LONOSV=XOFF 
      LATOSV=YOFF 
      RETURN
C 
C  X/Y EW 
C 
600   CONTINUE
      IF(ICHCM(LAXFP,1,4HXYEW,1,4).NE.0) GO TO 800
      LONOSV=XOFF 
      LATOSV=YOFF 
      RETURN
C 
C UNKNOWN AXIS SYSTEM 
C 
800   CONTINUE
      IERR=-10
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ONSOR(NWAIT,IERR)
      DIMENSION IT(5) 
C 
C  WAIT FOR ONSOURCE CONDITION
C 
C  INPUT: 
C 
C         NWAIT  = NUMBER OF SECONDS TO WAIT AT MOST FOR CONDITION
C               < 0 MEANS WAIT INDEFINITELY 
C  OUTPUT:
C 
C        IERR = 0 IF NO ERROR OCCURRED
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C         IONSOR
C 
C  MAIN LOOP
C 
D     CALL EXEC(2,LU,14HENTERING ONSOR,-14)                              
      CALL EXEC(11,IT)
      TIM=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.+FLOAT(IT(2))
10    CONTINUE
C 
C  TRY TO DETERMINE ONSOURCE STATUS 
C 
      CALL ANTCN(5,IERR)
      IF(IERR.NE.0) RETURN
      IF(IONSOR.NE.0) RETURN
C     IF(NWAIT.NE.0) CALL SUSP(2,1) 
      CALL EXEC(11,IT)
      TIM2=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.+FLOAT(IT(2)) 
      IF(TIM2.LT.TIM) TIM2=TIM2+86400.
      IF(TIM2.LT.TIM+FLOAT(NWAIT).OR.NWAIT.LT.0) GO TO 10 
C 
C  DIDN'T REACH ONSOURCE
C 
      IERR=-20
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE LOCAL(LONPOS,LATPOS,LAXIS,IERR)
      REAL LONPOS,LATPOS
C 
C  GET LOCAL ANTENNA COORDINATES
C 
C  OUTPUT:
C 
C         LONPOS = CALCULATED LONGITUDE-LIKE COORDINATE 
C 
C         LATPOS = CALCULATED LATITUDE-LIKE COORDINATE
C 
C         IERR = 0 IF NO ERROR OCCURRED 
C 
       DOUBLE PRECISION DLAT,DLON,RA,DEC,AZ,EL,X,Y,DHA,DPI,REFR 
       DIMENSION IT(6)
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C        XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, LAXFP, RADAT, DECDAT
C 
      DATA DPI/3.141592653589D0/
C
C  CALCULATE THE POSITION IN THE LOCAL X/Y NS SYSTEM
C
D     CALL EXEC(2,LU,14HENTERING LOCAL,-14)                              
D     ORA=RADAT*180./PI                                                  
D     ODC=DECDAT*180./PI                                                 
D     WRITE(LU,995) ORA,ODC,PI,DPI                                       
D995  FORMAT(" RA DEC PI DPI",4F10.3)                                    
      DLAT=ALAT
      DLON=WLONG
      CALL EXEC(11,IT,IT(6))
C
      RA=RADAT
      DEC=DECDAT
D     ORA=RA*(180.0/PI)                                                  
D     ODC=DEC*180.0/PI                                                   
D     WRITE(LU,992) ORA,ODC,PI                                           
D992  FORMAT(" RA, DEC, PI",3F12.4)                                      
D     OLAT=DLAT*180./PI                                                  
D     OLON=DLON*180./PI                                                  
D     WRITE(LU,993) IT,OLAT,OLON                                         
D993  FORMAT(" IT, DLAT, DLON ",6I5,2F12.3)                              
      CALL CNVRT(1,RA,DEC,AZ,EL,IT,DLAT,DLON)
      EL=EL+(DPI/180.0D0)*REFR(EL*(180.0D0/DPI))
      CALL CNVRT(5,AZ,EL,X,Y,IT,DLAT,DLON)
D     OAZ=AZ*180.0/PI                                                    
D     OEL=EL*180.0/PI                                                    
D     OX=X*180.0/PI                                                      
D     OY=Y*180./PI                                                       
D     OCR=REFR(EL*(180.D0/DPI))                                          
D     WRITE(LU,991) OAZ,OEL,OX,OY,OCR                                    
D991  FORMAT(" AZ, EL, X, Y, REFR ",5F10.4)                              
C
C  NOW CONVERT BACK TO WHAT WE WERE ASKED FOR
C
C  HA/DEC, NOT RA/DEC
C
D     CALL EXEC(2,LU,14HLOCAL HADC    ,-14)                              
      IF(ICHCM(LAXIS,1,4HHADC,1,4).NE.0) GO TO 200
      CALL CNVRT(6,X,Y,DHA,DEC,IT,DLAT,DLON)
      LONPOS=DHA
      LATPOS=DEC
      RETURN
C
C  AZ/EL
C
200   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL AZEL    ,-14)                              
      IF(ICHCM(LAXIS,1,4HAZEL,1,4).NE.0) GO TO 400
      CALL CNVRT(4,X,Y,AZ,EL,IT,DLAT,DLON)
      LONPOS=AZ
      LATPOS=EL
      RETURN
C
C  X/Y NS
C
400   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL XYNS    ,-14)                              
D     CALL EXEC(2,LU,LAXIS,-4)                                           
      IF(ICHCM(LAXIS,1,4HXYNS,1,4).NE.0) GO TO 600
      LONPOS=X
      LATPOS=Y
      RETURN
C 
C  X/Y EW 
C 
600   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL XYEW    ,-14)                              
C      IF(ICHCM(LAXIS,1,4HXYEW,1,4).NE.0) GO TO 800 
C 
C   WE DON'T SUPPORT THIS YET WEH 840728
C 
      GO TO 800 
C      LONPOS=X   
C      LATPOS=Y   
C      RETURN 
C 
C UNKNOWN AXIS SYSTEM 
C 
800   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL ERROR   ,-14)                              
      IERR=-40
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE OFFCO(OFF,AZOF,ELOF,AZPOS,ELPOS,IERR)
C 
C  OFFSET CALCULATION FOR SYSTEM TEMPERATURE
C 
C  INPUT: 
C 
C        OFF = DISTANCE TO GO OFF SOURCE
C 
C  OUTPUT:
C 
C        AZOF   = AZIMUTH OFFSET
C 
C        ELOF   = ELEVATION OFFSET
C 
C        AZPOS  = AZIMUTH OF THE RESULTING POSIOTN
C 
C        ELPOS  = ELEVATION OF THE RESULTING POSITION 
C 
C        IERR = 0 IF NO ERROR 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  INITAILLY ASSUME THAT: 
C 
D     CALL EXEC(2,LU,14HENTERING OFFCO,-14)                              
      CALL LOCAL(AZPOS,ELPOS,4HAZEL,IERR) 
      IF(IERR.NE.0) RETURN
      AZOF=OFF/COS(ELPOS) 
      ELOF=0.0
C 
C  NOW FIX IT, IF ITS WRONG 
C 
      IF(AZPOS.GT.PI) AZOF=-AZOF
      IF(ELPOS.LT.75.0*(PI/180.)) GO TO 1000
      AZOF=0.0
      ELOF=-OFF 
C 
1000  CONTINUE
      AZPOS=AZPOS+AZOF
      IF(AZPOS.GE.2.0*PI) AZPOS=AZPOS+2.0*PI
      IF(AZPOS.LT.0.0) AZPOS=AZPOS-2.0*PI 
      ELPOS=ELPOS+ELOF
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE GOOFF(LONOFF,LATOFF,LAXIS,NWAIT,IERR)
      REAL LONOFF,LATOFF
C 
C  GO TO THE INDICATED OFFSET 
C 
C  INPUT: 
C 
C            NWAIT = NUMBER OF SECONDS TO WAIT FOR ONSOURCE 
C 
C  OUTPUT:
C 
C            LONOFF = LONIGITUDE AXIS OFFSET
C 
C            LATOFF = LATITUDE AXIS OFFSET
C 
C            IERR = 0 IF NO ERROR 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C        XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, 
C 
C  HA/DEC, NOT RA/DEC 
C 
D     CALL EXEC(2,LU,14HENTERING GOOFF,-14)                              
      IF(ICHCM(LAXIS,1,4HHADC,1,4).NE.0) GO TO 200
      RAOFF=-LONOFF 
      DECOFF=LATOFF 
      GO TO 10000 
C 
C  AZ/EL
C 
200   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/200 ,-10)                             
      IF(ICHCM(LAXIS,1,4HAZEL,1,4).NE.0) GO TO 400
      AZOFF=LONOFF
      ELOFF=LATOFF
      GO TO 10000 
C 
C  X/Y NS 
C 
400   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/400 ,-10)                             
      IF(ICHCM(LAXIS,1,4HXYNS,1,4).NE.0) GO TO 600
      XOFF=LONOFF 
      YOFF=LATOFF 
      GO TO 10000 
C 
C  X/Y EW 
C 
600   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/600 ,-10)                             
      IF(ICHCM(LAXIS,1,4HXYEW,1,4).NE.0) GO TO 80000
      XOFF=LONOFF 
      YOFF=LATOFF 
      GO TO 10000 
C
C  NOW DO THE OFF
C
10000 CONTINUE
      IERR=0
      IF(NWAIT.LT.0) RETURN
      CALL ANTCN(2,IERR)
      IF(IERR.NE.0) RETURN
C
C WAIT FOR ONSOURCE
C
      CALL ONSOR(NWAIT,IERR)
      RETURN
C
C UNKNOWN AXIS SYSTEM
C
80000 CONTINUE
D          CALL EXEC(2,LU,12HLOCAL/80000 ,12)
      IERR=-60
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE TSYS(TEMPS,SIGTS,TPIA,TIMA,VBASE,VSLOPE,INTP,RUT,IERR)
C 
C  GET SYSTEM TEMPERATURE AND BASELINE TPI READING
C 
C  INPUT: 
C 
C        INTP = INTEGRATION PERIOD IN SECONDS 
C 
C        RUT  = REFERENCE UT TIME OF DAY IN SECONDS 
C 
C  OUTPUT:
C 
C        TEMPS = CALCULATED SYSTEM TEMPERATURE
C 
C        TPIA  = OBSERVED TPI READING 
C 
C        TIMA  = SECONDS SINCE RUT
C 
C        VBASE = TPIZERO READING
C 
C        VLSOPE = FACTOR FOR CONVERSION OF COUNTS TO DEGREES
C
C        IERR = O IF NO ERROR OCCURRED
C
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C  WE READ THE FOLLOWING VALUES FROM FSCOM
C
C      CALFP
C
      DIMENSION ICMND(3),INDATA(10),ISAV(10),IZERO(10)
      DATA ICMND/ 2H#9,2H3%,2H__/,IQUES/2H??/,IDOLR/2H$$/
      DATA ISAV/2H#9,2H3=,0,0,0,0,2H__,0,0,0/
      DATA IZERO/2H#9,2H3=,2H00,2H00,2H3F,2H3F,2H__,0,0,0/
      DATA NIN/-20/
C
C MAKE SURE THE CAL IS OFF
C
      CALL SCMDS(8HCALOFFFP,8)
C
C  READ EXISTING IFD ATTENUATOR SETTINGS
C
D     CALL EXEC(2,LU,14HENTERING TSYS ,-14)
      CALL MATCN(ICMND,-5,IQUES,INDATA,NIN, 9,IERR)
      IF(IERR.NE.0) RETURN
      CALL ICHMV(ISAV,5,INDATA,1,8)
C
C  TURN ON ALL THE ATTENUATORS
C
      CALL ICHMV(IZERO,5,INDATA,1,4)
      CALL MATCN(IZERO,-13,IDOLR,INDATA,NIN,2,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  OKAY GET THE VOLTS
C
      CALL VOLTS(VBASE,SIG,TDUM,INTP,RUT,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  RESET THE ATTENUATORS
C
      CALL MATCN(ISAV,-13,IDOLR,INDATA,NIN,2,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  NOW SET GET THE TPI READING
C
      CALL VOLTS(TPIA,SIGTS,TIMA,INTP,RUT,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  NOW DO TPICAL
C
C       TURN CAL ON
C 
      CALL SCMDS(8HCALONFP ,7)  
C 
C       GET DATA
C 
      CALL VOLTS(TPICAL,SIG,TDUM,INTP,RUT,IERR) 
      IF(IERR.NE.0) GO TO 8000
C 
C       CAL OFF
C
      CALL SCMDS(8HCALOFFFP,8)
C
C  FINALLY, GET THE SYSTEM TEMPEARTURE AND VSLOPE
C
      VSLOPE=CALFP/(TPICAL-TPIA)
      TEMPS=(TPIA-VBASE)*VSLOPE
      SIGTS=SIGTS*VSLOPE
      RETURN
C
C  ERROR RETURN, RESET ATTENUATORS
C
8000  CONTINUE
      JTRY=2
C
8001  CONTINUE
      JERR=0
      CALL MATCN(ISAV,-13,IDOLR,INDATA,NIN,2,JERR)
      JTRY=JTRY-1
      IF(JERR.GT.0.AND.JTRY.GT.0) GO TO 8001
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-110,LWHO,2HER)
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE VOLTS(TPIA,SIG,TIMA,INTP,RUT,IERR) 
C 
C   TOTAL POWER INTEGERATION ROUTINE, THIS ROUTINE READS THE TPI
C       FOR THE SPECIFIED DEVICE
C 
C   INPUT:
C 
C       INTP   - INTEGRATION PERIOD IN SECONDS
C 
C       NTRY   - EXTRA TRIES TO ALLOW, IF AN ERROR OCCURS 
C 
C       RUT    - REFERENCE UT TIME OF DAY IS SECONDS
C 
C   OUTPUT: 
C 
C       TPIA   - MEASURED TPI LEVEL 
C 
C       SIG    - POPULATION SIGMA 
C 
C       TIMA   - TIME IN SECONDS OF MEASUREMENT RELATIVE TO RUT 
C 
C       IERR = 0 IF NO ERROR OCCURRED 
C 
      DOUBLE PRECISION TIMT,DTPI,DRI,TPITA,SIGT,TIMTA,DIDIM1
      DIMENSION ICMND(4,17),IREG(2),IT(5),INDATA(10),ITI(5) 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE USE THE FOLLOWING VARIABLES FROM FSCOM
C 
C      LDEVFP, LUMAT
C 
      EQUIVALENCE (REG,IREG)
      DATA ICMND/ 2HV1, 2H#0,2H1%,2H__, 
     +            2HV2, 2H#0,2H2%,2H__, 
     +            2HV3, 2H#0,2H3%,2H__, 
     +            2HV4, 2H#0,2H4%,2H__, 
     +            2HV5, 2H#0,2H5%,2H__, 
     +            2HV6, 2H#0,2H6%,2H__, 
     +            2HV7, 2H#0,2H7%,2H__, 
     +            2HV8, 2H#0,2H8%,2H__,
     +            2HV9, 2H#0,2H9%,2H__,
     +            2HVA, 2H#0,2HA%,2H__,
     +            2HVB, 2H#0,2HB%,2H__,
     +            2HVC, 2H#0,2HC%,2H__,
     +            2HVD, 2H#0,2HD%,2H__,
     +            2HVE, 2H#0,2HE%,2H__,
     +            2HVF, 2H#0,2HF%,2H__,
     +            2HI1, 2H#9,2H3!,2H__,
     +            2HI2, 2H#9,2H3!,2H__/
      DATA IQUES/2H??/,NDEV/17/,LWHO/2HFP/,LWHAT/2HVO/,NTRY/1/
      DATA NIN/10/
C
C  0. INITIALIZE
C
C       LOCK INTO MEMORY
C
D     CALL EXEC(2,LU,14HENTERING VOLTS,-14)                              
      CALL EXEC(22,1)
C
C       WHICH DEVICE?
C 
      DO 8 I=1,NDEV 
           IF(ICMND(1,I).NE.LDEVFP) GO TO 8 
           ID=I 
           GO TO 11 
8          CONTINUE 
C 
C            DEVICE NOT FOUND 
C 
      GO TO 80000 
C 
C            GOT IT 
C 
11    CONTINUE
C 
C       SET UP OTHER THINGS 
C 
      TPIA=0
      SIG=0 
      TIMA=0
C 
C       WAIT FOR A SECOND TO CYCLE TPI
C        (WE WILL WAIT AN ADDITIONAL SECOND BEFORE THE FIRST READING) 
C 
      CALL SUSP(1,102)
      CALL EXEC(11,ITI) 
C 
C   1. LOOP GETTING DATA
C 
      DO 20 I=1,INTP
C 
C       WAIT TILL THE NEXT SECOND AT LEAST
C 
       IF(IFBRK(IDUM).LT.0)GO TO 80040  
       CALL EXEC(11,IT) 
       ITV1=IT(1)-ITI(1)                    
       ITV2=IT(2)-ITI(2)                    
       ITIM=ITV1*100+ITV2+102 
       IF(ITIM.LT.0) ITIM=ITIM+6000.            
           CALL SUSP(1,ITIM)
D      WRITEVLU,9901 ITIM,ITV1,ITV2,I                                    
D9901  FORMAT(" ITIM, ITV1 , ITV2, I = ",4I7)                            
C 
C      GET THE STUFF
C 
           ITRY=NTRY
12         CONTINUE 
           CALL MATCN(ICMND(2,ID),-5,IQUES,INDATA,NIN, 9,IERR)
           CALL EXEC(11,ITI)
           IF(IERR.NE.0) RETURN 
C 
C      CONVERT TO COUNTS
C 
           IF(ID.EQ.17) DTPI=FLOAT(IA22H(INDATA(1)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(2)))
           IF(ID.NE.17) DTPI=FLOAT(IA22H(INDATA(3)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(4)))
C 
C       CHECK FOR TPI SATURATION
C 
           IF(DTPI.LT.65534.5D0) GO TO 16 
           CALL LOGIT(IDUM,IDUM,IDUM,-1,-80,LWHO,LWHAT) 
           ITRY=ITRY-1
           IF(ITRY.LE.0) GO TO 80010
           GO TO 12 
C 
C       CALCULATE TIME
C 
16         CONTINUE 
           DIM1=DBLE(FLOAT(I-1))
           DRI=1.0D0/DBLE(FLOAT(I)) 
           TPITA=(TPITA*DIM1+DTPI)*DRI  
           SIGT=(SIGT*DIM1+DTPI*DTPI)*DRI 
           TIMT=FLOAT(ITI(2))+FLOAT(ITI(3))*60.0+ 
     +          FLOAT(ITI(4))*3600.0  
           IF(TIMT.LT.DBLE(RUT)) TIMT=TIMT+86400.0D0
           TIMTA=(TIMTA*DIM1+TIMT)*DRI
D       WRITE(LU,9920) INDATA,DTPI,TIMT,ID,INTP                          
D9920   FORMAT(" INDATA, DTPI, TIMT ID INTP= ",10A2,2F10.3,2I7)          
20         CONTINUE 
C 
C        AVERAGE TIME AND COUNTS
C 
      IF(INTP.GT.1) GO TO 30
      SIGT=0
      GO TO 35
C 
30    CONTINUE
      DIDIM1=DBLE(FLOAT(INTP))/DBLE(FLOAT(INTP-1))
      SIGT=DSQRT(DABS(SIGT-TPITA*TPITA)*DIDIM1) 
C 
35    CONTINUE
      TPIA=TPITA
      SIG=SIGT
      TIMA=TIMTA
      GO TO 90000 
C 
C        UNKNOWN DEVICE ERROR 
C 
80000 CONTINUE
      IERR=-81
      GO TO 90000 
C 
C        SATURATION ERRORS
C 
80010 CONTINUE
      IERR=-82
      GO TO 90000 
C 
C  BREAK DETECTED 
C 
80040 CONTINUE
      IERR=1
      GO TO 90000 
C 
C        CLEAN UP AND EXIT
C 
90000 CONTINUE
      CALL EXEC(22,0) 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE MATCN(ICMND,NOUT,ITRIG,INDATA,NIN,NREQ,IERR) 
C 
C  MAT COMMUNICATION ROUTINE
C 
C  INPUT: 
C 
C        ICMND = BUFFER HOLDING DATA TO GO OUT
C 
C        NOUT = POSITIVE WORDS OR NEGATIVE CHARACTERS IN ICMND
C 
C        ITRIG = TRIGGER CHARATER IN LOWER BYTE, UPPER BYTE NULL
C 
C        NIN = POSITIVE WORDS OR NEGATIVE CHARACTERS IN INDATA
C 
C        NREQ = NUMBER OF REQUIRED CHARACTERS IN RESPONSE, POSITIVE 
C 
C  OUTPUT:
C 
C        INDATA = RETURN BUFFER 
C 
C        IERR = 0 IF NO ERROR 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE READ THE FOLLOWING VARIABLES FROM FSCOM 
C 
C        LUMAT
C 
      DIMENSION IREG(2) 
      EQUIVALENCE (REG,IREG)
C 
      DATA IDUM/0/,LWHO/2HFP/,LWHAT/2HMA/,NTRY/2/ 
  
C 
C  LOCK THE BUS WITH WAIT 
C 
D     CALL EXEC(2,LU,14HENTERING MATCN,-14)
C     CALL LURQ(000001B,LUMAT,1)
C
      ITER=NTRY
      NI=NIN
      IF(NIN.GT.0) NI=-2*NIN
12    CONTINUE
      ITER=ITER-1
      IF(ITER.LT.0) GO TO 80000
      IF(IFBRK(IDUM).LT.0) GO TO 80010
      CALL EXEC(3,2600B+LUMAT)
      REG=REIO(2,2000B+LUMAT,ICMND,NOUT+1)
      REG=REIO(2,2000B+LUMAT,ITRIG,-1)
      REG=REIO(1,2000B+LUMAT,INDATA,NI)
C
C      CHECK FOR TIME OUT
C
      IF(IAND(IREG(1),02B).EQ.0) GO TO 14
      CALL LOGIT(IDUM,IDUM,IDUM,-1,-70,LWHO,LWHAT)
      GO TO 12
C
C       CHECK FOR CHARACTER COUNT ERROR
C
14    CONTINUE
      IF(IREG(2).EQ.NREQ) GO TO 90000
      CALL LOGIT(IDUM,IDUM,IDUM,-1,-71,LWHO,LWHAT)
      GO TO 12
C
C  FAILED 
C 
80000 CONTINUE
      IERR=-72
      GO TO 90000 
C 
C BREAK DETECTED
C 
80010 CONTINUE
      IERR=1
      GO TO 90000 
C 
C CLEAN UP AND EXIT 
C 
90000 CONTINUE
C     CALL LURQ(100000B,LUMAT,1)
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE UNSLP(TMPLIN,TIMLIN,TEMP,TIM,NPTS,SLOPE,CONST) 
      DIMENSION TMPLIN(2),TIMLIN(2),TEMP(NPTS),TIM(NPTS)
C 
C   REMOVE A LINEAR SLOPE AND A CONSTANT, DETERMINED FROM TMPLIN, 
C       FROM THE DATA IN TEMP 
C 
C  INPUT: 
C 
C      TMPLIN - ARRAY HOLDING THE TEMPERATURE DRIFT INFORMATION 
C 
C      TIMLIN - THE TIME COORDIANTE OF THE TMPLIN DATA
C 
C      TEMP   - THE DATA TO BE CORRECTED
C 
C      TIM    - THE TIME COORDINATE OF THE DATA 
C 
C      NPTS   - NUMBER OF POINTS IN TEMP AND TIM
C 
D     CALL EXEC(2,LU,14HENTERING UNSLP,-14)                              
      SLOPE=(TMPLIN(2)-TMPLIN(1))/(TIMLIN(2)-TIMLIN(1)) 
      TMID=TIM((NPTS+1)/2)
      CONST=TMPLIN(1)+SLOPE*(TMID-TIMLIN(1))
      DO 10 I=1,NPTS
         TEMP(I)=TEMP(I)-((TIM(I)-TMID)*SLOPE+CONST)  
10       CONTINUE 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ANTCN(IP1,IERR)
C 
C ANTCN SCHEDULING SUBROUTINE 
C 
C INPUT:
C 
C       IP1 = THE FIRST PARAMETER IN THE RUN STRING 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C OUTPUT: 
C 
C       IERR = 0 IF NO ERROR OCCURRED 
C 
      DIMENSION IP(5) 
C 
      DATA NTRY/2/,IDUM/0/
C 
D     CALL EXEC(2,LU,14HENTERING ANTCN,-14)                              
      ITRY=NTRY 
15    CONTINUE
      IF(IFBRK(IDUM).LT.0) GO TO 80010
      CALL EXEC(23,6HANTCN ,IP1,0,0,0,0)
      CALL RMPAR(IP)
      IF(IP(3).GE.0) RETURN 
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IP(3),IP(4),2HFP)
      ITRY=ITRY-1 
      IF(ITRY.GT.0) GO TO 15
      GO TO 80020 
C 
C BREAK DETECTED
C 
80010 CONTINUE
      IERR=1
      RETURN
C 
C FAILED COMMUNICATION
C 
80020 CONTINUE
      IERR=-30
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE FIT2(X,Y,X2,PAR,EPAR,NPTS,NPAR,TOL,NTRY,F,CHI,IERR)
C 
C     LEAST SQUARES FITTING ROUTINE...FITS TO FUNCTION F
C     WHICH MUST BE DECLARED EXTERNAL IN THE CALLING ROUTINE. 
C     MAXIMUM NUMBER OF PARAMETERS IS 5.  NOTE THAT AN
C     ERROR RESULTS IN A RETURN OF IERR <= 0.  THIS ROUTINE 
C     REQUIRES SUBROUTINE MATINV.   
C 
      DIMENSION PAR(1),X(1),Y(1),A(5,5),B(5),AUX(5),EPAR(1) 
      DIMENSION X2(1) 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
D     CALL EXEC(2,LU,14HENTERING FIT  ,-14)                              
      DO 100 ITRY=1,NTRY
      DO 20 I=1,NPAR
      B(I)=0. 
      DO 20 J=1,NPAR
20    A(I,J)=0. 
      DO 40 K=1,NPTS
      DO 30 I=1,NPAR
30    AUX(I)=F(I,X(K),X2(K),PAR)
      R=Y(K)-F(0,X(K),X2(K),PAR)
      DO 40 I=1,NPAR
      B(I)=B(I)+R*AUX(I)
      DO 40 J=1,NPAR
40    A(I,J)=A(I,J)+AUX(I)*AUX(J) 
C 
      CALL MATIN(NPAR,A,B,MBACK)
      IF(MBACK.NE.-1) GO TO 200 
      IAGAIN=0
      DO 60 I=1,NPAR
      IF(ABS(B(I)/SQRT(ABS(A(I,I)))).GT.TOL) IAGAIN=1   
60    PAR(I)=PAR(I)+B(I)
      IF(IAGAIN.EQ.0) GO TO 101 
100   CONTINUE
      IERR=-2     
      GO TO 102 
C 
101   CONTINUE
      IERR=ITRY 
C 
102   CONTINUE
      CHI=0.
      DO 110 I=1,NPAR 
      EPAR(I)=SQRT(ABS(A(I,I))) 
110   CONTINUE
      NFREE=NPTS-NPAR 
      IF(NFREE.LE.0) RETURN 
      XSUM=0. 
      XSQ=0.
      DO 120 I=1,NPTS 
      R=Y(I)-F(0,X(I),X2(I),PAR)
120   XSQ=XSQ+R*R 
      CHI=SQRT(XSQ/NFREE) 
      DO 140 I=1,NPAR 
140   EPAR(I)=CHI*SQRT(ABS(A(I,I))) 
      RETURN
200   IERR=-1   
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE MATIN(N,A,B,MSIGNL)
C 
C     MATRIX INVERSION ROUTINE 5 PARAMETERS.
C 
      DIMENSION A(5,5),B(5),PIVOT(5),IPIVOT(5),INDEX(5,5) 
C 
      DETERM=1
      DO 20 J=1,N 
20    IPIVOT(J)=0 
      DO 550 I=1,N
      AMAXI=0.
      DO 105 J=1,N
      IF(IPIVOT(J).EQ.1) GO TO 105
      DO 100 K=1,N
      IF(IPIVOT(K).EQ.1) GO TO 100
      IF(IPIVOT(K).GT.1) GO TO 730
      IF(ABS(AMAXI).GE.ABS(A(J,K))) GO TO 100 
      IROW=J
      ICOLUM=K
      AMAXI=A(J,K)
100   CONTINUE
105   CONTINUE
C 
      IPIVOT(ICOLUM)=IPIVOT(ICOLUM)+1 
      IF(IROW.EQ.ICOLUM) GO TO 260
      DETERM=-DETERM
      DO 200 L=1,N
      SWAP=A(IROW,L)
      A(IROW,L)=A(ICOLUM,L) 
200   A(ICOLUM,L)=SWAP
      SWAP=B(IROW)
      B(IROW)=B(ICOLUM) 
      B(ICOLUM)=SWAP
260   INDEX(I,1)=IROW 
      INDEX(I,2)=ICOLUM 
      PIVOT(I)=A(ICOLUM,ICOLUM) 
      IF(PIVOT(I).EQ.0.) GO TO 710
320   DET=DETERM*PIVOT(I) 
      IF(DET.NE.0.) GO TO 329 
      MSIGNL=0
      DETERM=DETERM*1.0E16
      GO TO 320 
329   DETERM=DET
      A(ICOLUM,ICOLUM)=1. 
      DO 350 L=1,N
350   A(ICOLUM,L)=A(ICOLUM,L)/PIVOT(I)
      B(ICOLUM)=B(ICOLUM)/PIVOT(I)
      DO 550 L1=1,N 
      IF(L1.EQ.ICOLUM) GO TO 550
      T=A(L1,ICOLUM)
      A(L1,ICOLUM)=0. 
      DO 450 L=1,N
450   A(L1,L)=A(L1,L)-A(ICOLUM,L)*T 
      B(L1)=B(L1)-B(ICOLUM)*T 
550   CONTINUE
C 
      DO 709 I=1,N
      L=N+1-I 
      IF(INDEX(L,1).EQ.INDEX(L,2)) GO TO 709
      JROW=INDEX(L,1) 
      JCOLUM=INDEX(L,2) 
      DO 705 K=1,N
      SWAP=A(K,JROW)
      A(K,JROW)=A(K,JCOLUM) 
705   A(K,JCOLUM)=SWAP
709   CONTINUE
      MSIGNL=-1 
      RETURN
C     MIXED DIMENSIONS
730   MSIGNL=2
      RETURN
C     SINGULAR MATRIX 
710   MSIGNL=1
      END 
      FUNCTION FGAUS(IWHICH,X,X2,PAR) 
C 
C     THREE-PARAMETER SINGLE GAUSSIAN + LINEAR FUNCTION IN 2ND COORDIANTE 
C 
      DIMENSION PAR(1)
C 
      E=(X-PAR(2))/PAR(3) 
      W=EXP(-2.7725887*E*E) 
      GO TO (20,40,60,80,100,120), IWHICH+1 
20    FGAUS=PAR(1)*W+PAR(4)+PAR(5)*X2 
      RETURN
40    FGAUS=W 
      RETURN
60    FGAUS=5.5451774*PAR(1)*E*W/PAR(3) 
      RETURN
80    FGAUS=5.5451774*PAR(1)*E*E*W/PAR(3) 
      RETURN
100   FGAUS=1.
      RETURN
120   FGAUS=X2
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SORCE(RUT,IDOY,IYR,LBUF,ISBUF) 
      DIMENSION LBUF(1) 
C 
C WRITE SOURCE LOG ENTRY
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE READ THE FOLLOWING FROM FSCOM:
C 
C    LSORNA,  DEC50, RA50, EP1950,
C 
C  SOURCE ENTRY IDENTIFIER
C 
D     CALL EXEC(2,LU,14HENTERING SORCE,-14)                              
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,8HSOURCE  ,1,7)
C 
C  SOURCE NAME
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,LSORNA,1,10) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C RA
C 
      ICNEXT=IPTRA(RA50,LBUF,ICNEXT)  
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C DECLINATION 
C 
      ICNEXT=IPTDC(DEC50,LBUF,ICNEXT) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C EPOCH 
C 
      ICNEXT=ICNEXT+JR2AS(EP1950,LBUF,ICNEXT,-6,1,ISBUF)  
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  TIME 
C 
      IH=INT(RUT/3600.0)
      RUT1=RUT-3600.0*FLOAT(IH) 
      IM=INT(RUT1/60.0) 
      RUT2=RUT1-60.0*FLOAT(IM)
      IS=INT(RUT2+0.5)
D     WRITE(LU,9010) RUT,IH,IM,IS                                        
D9010 FORMAT(" RUT, IH, IM, IS = ",F10.1,3I4)                            
C 
      IY=MOD(IYR,100) 
      ICNEXT=ICNEXT+IB2AS(IY,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H/  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IDOY,LBUF,ICNEXT,40000B+400B*3+3) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H.  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IH,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H:  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IM,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H:  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IS,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C EVEN OFF THE LAST WORD AND SEND IT
C 
      NCHAR=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHAR)
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE FIVP(LBUF,ISBUF) 
      DIMENSION LBUF(1) 
C 
C WRITE FIVEPT LOG ENTRY
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C WE READ THE FOLLOWING FROM FSCOM: 
C 
C     LAXFP, LDEVFP, CALFP, NREPFP, NPTSFP, FREQFP, INTPFP, STEPFP, 
C     ANGLFP, DIAMAN
C 
C FIVEPT LOG ENTRY IDENTIFIER
C
D     CALL EXEC(2,LU,14HENTERING FIVP ,-14)
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,8HFIVEPT  ,1,7)
C
C AXIS OF SCAN
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LAXFP,1,4)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C REPITITONS
C
      ICNEXT=ICNEXT+IB2AS(NREPFP,LBUF,ICNEXT,3)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C NUMBER OF POINTS PER AXIS
C
      ICNEXT=ICNEXT+IB2AS(NPTSFP,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C STEP SIZE
C
      ICNEXT=ICNEXT+JR2AS(STEPFP,LBUF,ICNEXT,-4,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C INTEGRERATION PERIOD
C
      ICNEXT=ICNEXT+IB2AS(INTPFP,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C DEVICE MNEMONIC
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LDEVFP,1,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CALIBRATION NOISE SOURCE
C
      ICNEXT=ICNEXT+JR2AS(CALFP,LBUF,ICNEXT,-5,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C BEAMWIDTH
C
      ICNEXT=ICNEXT+JR2AS(BMFP_FS*180./PI,LBUF,ICNEXT,-7,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C FLUX
C
      ICNEXT=ICNEXT+JR2AS(FXFP_FS,LBUF,ICNEXT,-9,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CLEAN UP AND OUTPUT THE RESULT
C
      NCHARS=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
      CALL LOGIT(LBUF,NCHARS)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SITE(VFIVPT,LBUF,ISBUF)
      DIMENSION LBUF(1)
C
      INCLUDE /FS/INCLUDE/DPI.FTNI
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C  WRITE SITE RECORD TO LOG
C
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,1,6HSITE  ,1,5)
C
C  ANTENNA NAME
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LNAANT,1,8)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C  LONGITUDE
C
      ICNEXT=ICNEXT+JR2AS(SNGL(WLONG*RAD2DEG),LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C  LATITIUDE
C
      ICNEXT=ICNEXT+JR2AS(SNGL(ALAT*RAD2DEG),LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  DIAMETER 
C 
      ICNEXT=ICNEXT+JR2AS(DIAMAN,LBUF,ICNEXT,-6,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  AXIS TYPE
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,4HXXXX,1,4)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  POINTING MODEL NUMBER
C 
      ICNEXT=ICNEXT+IB2AS(0,LBUF,ICNEXT,3)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  FIVPT VERSION NUMBER 
C 
      ICNEXT=ICNEXT+JR2AS(VFIVPT,LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  FS VERSION 
C 
      ICNEXT=ICNEXT+JR2AS(FSVER,LBUF,ICNEXT,-5,2,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C CLEAN UP AND SEND 
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ORIGN(XO,YO,AZO,ELO,HAO,DCO,LBUF,ISBUF)
      DIMENSION LBUF(1) 
C 
C WRITE ORIGIN LOG ENTRY
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C INPUT:
C 
C XO = XOFFSET
C YO  =Y  OFSET 
C AZO = AZ OFFSET 
C ELO = EL OFFSET 
C HAO = HA OFFSET 
C DECO = DEC OFFSET 
C 
C     WRITE ORIGIN IDENTIFIER 
C 
D     CALL EXEC(2,LU,14HENTERING ORIGN,-14)                              
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,8HORIGIN  ,1,7)
C 
C HAOFFSET
C 
      ICNEXT=ICNEXT+JR2AS(HAO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)    
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C DECLINATION OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(DCO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)    
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C AZIMUTH OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(AZO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)    
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C ELEVATION OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(ELO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)    
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C X OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(XO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)   
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C Y OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(YO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)   
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C CLEAN UP AND SEND IT
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE WTSYS(TEMPS,SIGTS,AZ,EL,NP,LBUF,ISBUF) 
      DIMENSION LBUF(1) 
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WRITE TSYS LOG ENTRY 
C 
      ICNEXT=1
C 
C RECORD IDENTIFIER 
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,6HTSYS  ,1,5)
C 
C AZIMUTH 
C 
      ICNEXT=ICNEXT+JR2AS(AZ*180.0/PI,LBUF,ICNEXT,-7,3,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
C  ELEVATION
C 
      ICNEXT=ICNEXT+JR2AS(EL*180.0/PI,LBUF,ICNEXT,-7,3,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
C SYSTEM TEMPERATURE
C 
      ICNEXT=ICNEXT+JR2AS(TEMPS,LBUF,ICNEXT,-7,3,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
C SYSTEM TEMPERATURE SIGMA
C 
      IF(NP.LE.1) GO TO 100 
      ICNEXT=ICNEXT+JR2AS(SIGTS,LBUF,ICNEXT,-7,4,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
C CLEAN AND SEND BUFFER 
C 
100   CONTINUE
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE FITOT(LMESS,MCHARS,LTPAR,IERR,LBUF,ISBUF)
      REAL LTPAR
      DIMENSION LTPAR(5),LBUF(1)
C 
C WRITE XXXFIT LOG ENTRY
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C INPUT:
C 
C       LTPAR = ARRAY OF FIT PARAMETERS 
C 
C       IERR  = FIT CODE FROM FITTING ROUTINE 
C 
C XXXFIT LOG ENTRY IDENTIFIER 
C 
D     OLTP1=LTPAR(1)*180./PI                                             
D     WRITE(LU,9800) OLTP1                                               
D9800 FORMAT(5F20.10)                                                    
       ICNEXT=1 
       ICNEXT=ICHMV(LBUF,ICNEXT,LMESS,1,MCHARS) 
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C  OFFSET 
C 
       ICNEXT=ICNEXT+JR2AS(LTPAR(2)*180.0/PI,LBUF,ICNEXT,-9,5,ISBUF)    
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C HALF-WIDTH
C 
       ICNEXT=ICNEXT+JR2AS(LTPAR(3)*180.0/PI,LBUF,ICNEXT,-7,4,ISBUF)  
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C  TEMPERATURE PEAK   
C 
       ICNEXT=ICNEXT+JR2AS(LTPAR(1),LBUF,ICNEXT,-7,4,ISBUF) 
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C TEMPERATURE OFFSET
C 
       ICNEXT=ICNEXT+JR2AS(LTPAR(4),LBUF,ICNEXT,-7,4,ISBUF)   
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C TEMPERATURE SLOPE 
C 
       ICNEXT=ICNEXT+JR2AS(LTPAR(5),LBUF,ICNEXT,-7,4,ISBUF)     
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C FIT CODE
C 
       ICNEXT=ICNEXT+IB2AS(IERR,LBUF,ICNEXT,3)
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C CLEAN UP AND SEND DATA
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ERROT(LMESS,MCHARS,ELTPAR,LTRCHI,LBUF,ISBUF) 
      REAL LTRCHI 
      DIMENSION ELTPAR(5),LBUF(1) 
C 
C WRITE XXXERR LOG ENTRY
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C INPUT:
C 
C       ELTPAR = ARRAY OF ERRORS IN THE FIT PARAMETERS
C 
C       LTRCHI = REDUCED CHI OF THE FIT 
C 
C XXXERR LOG ENTRY IDENTIFIER 
C 
D     OLTPE1=ELTPAR(1)*180./PI                                           
D     WRITE(LU,9800) OLTPE1                                              
D9800 FORMAT(5F20.10)                                                    
       ICNEXT=1 
       ICNEXT=ICHMV(LBUF,ICNEXT,LMESS,1,MCHARS) 
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C SIGMA OFFSET
C 
       ICNEXT=ICNEXT+JR2AS(ELTPAR(2)*180.0/PI,LBUF,ICNEXT,-9,5,ISBUF)   
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C SIGMA HALF-WIDTH
C 
       ICNEXT=ICNEXT+JR2AS(ELTPAR(3)*180.0/PI,LBUF,ICNEXT,-7,4,ISBUF) 
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C TEMPERATURE PEAK SIGMA
C 
       ICNEXT=ICNEXT+JR2AS(ELTPAR(1),LBUF,ICNEXT,-7,4,ISBUF)  
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C SIGMA TEMPERATURE OFFSET
C 
       ICNEXT=ICNEXT+JR2AS(ELTPAR(4),LBUF,ICNEXT,-7,4,ISBUF)  
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C SIGMA TEMPERATURE SLOPE 
C 
       ICNEXT=ICNEXT+JR2AS(ELTPAR(5),LBUF,ICNEXT,-7,4,ISBUF)  
       ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
C 
C REDUCED CHI 
C 
       ICNEXT=ICNEXT+JR2AS(LTRCHI,LBUF,ICNEXT,-8,4,ISBUF)     
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
C CLEAN UP AND SEND DATA
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE DPOIN(LMESS,MCHARS,I,TIM,OFF,TEMP,SIG,NP,LBUF,ISBUF) 
      DIMENSION LMESS(2),LBUF(1)
C 
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,LMESS,1,MCHARS)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+IB2AS(I,LBUF,ICNEXT,3)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(TIM,LBUF,ICNEXT,-7,0,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
      ICNEXT=ICNEXT+JR2AS(OFF*180./PI,LBUF,ICNEXT,-8,4,ISBUF)   
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(TEMP,LBUF,ICNEXT,-8,3,ISBUF)  
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
      IF(NP.LE.1) GO TO 100 
      ICNEXT=ICNEXT+JR2AS(SIG,LBUF,ICNEXT,-6,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
100   CONTINUE
      NCHARS=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
      CALL LOGIT(LBUF,NCHARS)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE OFFOT(LONPOS,LATPOS,LONOFF,LATOFF,ILON,ILAT,LBUF,
     +                 ISBUF)
      REAL LONPOS,LATPOS,LONOFF,LATOFF
      DIMENSION LBUF(1)
C
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,1,8HOFFSET  ,1,7)
C
      ICNEXT=ICNEXT+JR2AS(LONPOS*180.0/PI,LBUF,ICNEXT,-9,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
      ICNEXT=ICNEXT+JR2AS(LATPOS*180.0/PI,LBUF,ICNEXT,-9,4,ISBUF)     
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C 
      ICNEXT=ICNEXT+JR2AS(LONOFF*180.0/PI,LBUF,ICNEXT,-9,5,ISBUF)     
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)  
C
      ICNEXT=ICNEXT+JR2AS(LATOFF*180.0/PI,LBUF,ICNEXT,-9,5,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+IB2AS(ILON,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+IB2AS(ILAT,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      NCHARS=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
      CALL LOGIT(LBUF,NCHARS)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE PRFOT(STOC,SEFD,AE,AEDTS,LBUF,ISBUF)
      REAL STOC,SEFD,AE,AEDTS
      DIMENSION LBUF(1)
C
       INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,1,8HPERFORM ,1,8)
C
      ICNEXT=ICNEXT+JR2AS(STOC,LBUF,ICNEXT,-8,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(SEFD,LBUF,ICNEXT,-7,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(AE,LBUF,ICNEXT,-8,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(AEDTS,LBUF,ICNEXT,-8,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      NCHARS=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
      CALL LOGIT(LBUF,NCHARS)
      RETURN
      END
      FUNCTION JR2AS(RE,LBUF,ICN,IT,ID,ISBUF)
      DIMENSION LBUF(1)
C
      JR2AS=IR2AS(RE,LBUF,ICN,IT,ID)
      IF(.NOT. JCHAR(LBUF,ICN).EQ.36) RETURN
      ITA=MIN0(IABS(IT)+IABS(ID)+1,ISBUF*2-ICN+1)
      JR2AS=IR2AS(RE,LBUF,ICN,ITA,ID)
      JR2AS=IABS(IT)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SCMDS(IMESS,IC)
      DIMENSION IMESS(1)
C
      CALL COPIN(IMESS,IC)
C
      CALL EXEC(7)
      END
