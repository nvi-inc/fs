FTN77,I,Y
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
      PROGRAM MATCN(3)   !    MAT CONTROLLER <901228.2039>
C 
C   MATCN controls the I/O to the Microprocessor ASCII Transceiver
C 
C  MODIFICATIONS: 
C
C  DATE   WHO CHANGES
C  811012 NRV REMOVED SOME WVR-SPECIFIC CODE, ALL REFERENCES TO LUWVR
C  870911 MWH MODIFIED FOR USE WITH A400 8-CHANNEL MUX
C  901220 GAG Added call to logit when initializing MODTBL table upon error
C             condition.
C
C     INPUT VARIABLES: (RMPAR)
C
C        IP1    - class number of input buffer
C        IP2    - number of records in class
C
C     Buffer from class I/O contains following:
C     IBUF(1) = mode, must be between MINMOD and MAXMOD
C                   -8 - get ; strobe data
C                   -7 - get . strobe data
C                   -6 - get - strobe data
C                   -5 - get + strobe data
C                   -4 - get ) strobe data
C                   -3 - get ( strobe data
C                   -2 - get % strobe data
C                   -1 - get ! strobe data
C                    0 - send data and update
C                    1 - send data, verify, and update
C                    2 - send pending data
C                    3 - send pending data and verify 
C                    4 - update pending data
C                    5 - send contents of buffer with no modifications
C                    6 - issue "test/reset" (escape char.)
C                    7 - test alarm, reset alarm
C                    8 - send direct, like mode 5, but use address
C     IBUF(2) = device mnemonic 
C     IBUF(3 to end) = data, if mode is 0,1,2,3,4,5 
C 
C     OUTPUT VARIABLES:   (RMPAR) 
C 
C        IP1    - class number of response
C        IP2    - number of records in the class
C        IP3    - error return
C                 +2 - non-acknowledge (i.e. alarm is ON) 
C                 +1 - acknowledge
C                  0 - no response
C                 -1 - trouble with class buffer
C                 -2 - illegal mode 
C                 -3 - unrecognized device
C                 -4 - device time-out on response
C                 -5 - improper response (wrong number of chars)
C                 -6 - verify error 
C        IP4    - who we are "MA" 
C        IP5    - not used
C 
C     Buffer returned to caller contains response, if any, to 
C     I/O request.
C 
C   COMMON BLOCKS USED
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C   SUBROUTINE INTERFACE: 
C 
C     CALLED SUBROUTINES: IAT, DATAT
C 
C   LOCAL VARIABLES 
C 
      DIMENSION IP(5) 
C               - RMPAR 
C        IMODE  - mode for transmission/reception 
C        MAXMOD,MINMOD,MAXDEV 
C               - maximum, minimum mode numbers allowed
C               - max devices
C        NCHAR  - # chars in class buffer we read
C        NCH2   - # chars in buffer 2
C        ICLASS - class # we read
C        ICLASR - class # we respond with
C        NCLREC - # class records
C        ICLREC - counter for outer loop over class records
      DIMENSION IREG(2)
C               - registers from EXEC
      DIMENSION IBUF(180),IBUF2(80)
C               - buffers for input, output
C        ILEN,ILEN2   - length of above buffers
      DIMENSION LSTROB(8)
C              - strobe characters for modes < 0, requesting data
      LOGICAL KINI
C               - TRUE once we have initialized
C        NDEV   - # devices in module table
      DIMENSION MODTBL(3,25)
C               - module table, word 1 = mnemonic, word 2 = hex address
      DIMENSION LALARM(10)
C               - alarm message **NOTE** this should remain at a
C                 max of 20 characters for longest message from MATCN 
      LOGICAL KTP 
C               - true if this message is addressed to the TAPE drive
      EQUIVALENCE (REG,IREG(1))
      PARAMETER (NBAUD=6)
      DIMENSION IBAUD(NBAUD),IBINDX(NBAUD)
C      - list of legal baud rates and corresponding indices
C
C   INITIALIZED VARIABLES
C
      DATA KINI/.FALSE./
      DATA MINMOD/-8/, MAXMOD/8/,  MAXDEV/25/
      DATA ILEN/360/,ILEN2/160/
      DATA LSTROB/2H!>,2H%>,2H(>,2H)>,2H+>,2H->,2H.>,2H;>/
      DATA LALARM/2H  ,2H*A,2HLA,2HRM,2H* ,2H (,2H# ,2H ),3407B,0/
      DATA NALARM/18/
      DATA IBAUD/110,300,1200,2400,4800,9600/
      DATA IBINDX/3,6,7,9,10,11/
C
C
C
C     1. First get parameters and initialize if necessary.
C
      CALL RMPAR(IP)
1     ICLASS = IP(1)
      NCLREC = IP(2)
      IP(4) = 2HMA
      ICLASR = 0
      NCLRER = 0
      IERR = 0
      IF (ICLASS.NE.0) GOTO 100
      IERR = -1
      GOTO 1090
C
100   IF (KINI) GOTO 200
C
C     1.1 Initialize the MAT LU.
C
      IF (LUMAT.LT.0) GOTO 119
C                   If we were passed a negative LU, then skip the CNs.
      DO I=1,NBAUD
        IF (IBMAT.EQ.IBAUD(I)) IBX=I
      ENDDO
      IPRAM1 = 41400B + 8*IBINDX(IBX) + MUXMAT
C          set baud, 7 bits per char, 1 stop bit, even parity
      IF (IBMAT.EQ.110 .OR. IBMAT.EQ.9600) IPRAM1 = IPRAM1 + 2000B
C          set 2 stop bits for 110 or 9600 baud
      CALL EXEC(3,3000B+LUMAT,IPRAM1)
C         this call sets the baud,parity, etc.
      ITO=10.*1100./FLOAT(IBMAT)+2.5
      CALL EXEC(3,2200B+LUMAT,ITO)
C                   This may be dynamically adjusted by IAT
      CALL EXEC(3,2100B+LUMAT)       !  Disable as terminal
      CALL EXEC(3,2600B+LUMAT)
C        flush input buffers
      CALL EXEC(3,3400B+LUMAT,4B)
C        set for CPU-to-CPU protocol
      CALL EXEC(3,3300B+LUMAT,100000B)
119   LUMAT = IABS(LUMAT)
C
C     1.2  Read in device address table.
C     Read table from class buffer
C
      DO I=1,NCLREC
        REG=EXEC(21,ICLASS,IBUF,-ILEN)
        NCHAR = MIN(IREG(2),ILEN)
        IF (I.LE.MAXDEV) THEN
          MODTBL(1,I) = IBUF(1)
          IDUM=ICHMV(MODTBL(2,I),1,IBUF,4,2)
          IFC=7
          IX=IAS2B(IBUF,IFC,NCHAR-IFC+1)
          IF(IX.EQ.-32768) IX=0
          MODTBL(3,I)=IX
        ENDIF
      ENDDO
      IF (NCLREC.GT.MAXDEV) CALL LOGIT(0,0,0,1,-101,2HMA,MAXDEV)
C
190   NDEV = MIN0(MAXDEV,NCLREC)
C
      IDEV=1
      KINI = .TRUE.
      GOTO 1090
C
C     2. Begin the loop over class buffer records.
C     Read in the buffer, get the mode and module code.
C     Search the module table for a match.
C     Set up the output buffer with the hex address.
C
200   CONTINUE
      DO 900 ICLREC = 1,NCLREC
        REG = EXEC(21,100000B+ICLASS,IBUF,-ILEN)
        IF (IERR.LT.0) GOTO 900
C                   If we got an error earlier, skip to end of loop
        IF (IREG(1).LT.0) THEN
          IERR = -1
          GOTO 900
        ENDIF
C
        NCHAR = MIN(IREG(2),ILEN)
        IMODE = IBUF(1)
        IF (IMODE.GE.MINMOD.AND.IMODE.LE.MAXMOD) GOTO 220
        IERR = -2
        GOTO 900
C
220   IDEV = 1
      IF (IMODE.EQ.5) GOTO 500
C
        DO I=1,NDEV
          IF (MODTBL(1,I).EQ.IBUF(2)) GOTO 221
        ENDDO
        IERR = -3
        GOTO 900
221     IDEV = I
        ITN=MODTBL(3,I)+10.*1100./FLOAT(IBMAT)+2.5
        IF(ITO.NE.ITN) THEN
          ITO=ITN
          CALL EXEC(3,2200B+LUMAT,ITO)
        ENDIF
        KTP  = MODTBL(1,IDEV).EQ.2HTP
C
        IDUM=ICHMV(IBUF,1,2H# ,1,1)
        IDUM=ICHMV(IBUF,2,MODTBL(2,IDEV),1,2)
C                   The input buffer now has: #xx <data>
      IBUF2(1) = MODTBL(1,IDEV)
C                   The output buffer now has module mnemonic
C
      IF (IMODE.LT.0) GOTO 400
      IF (IMODE.EQ.6) GOTO 600
      IF (IMODE.EQ.7) GOTO 700
      IF (IMODE.EQ.8) GOTO 800
C
C
C     3. Here we are sending data to the MAT.
C     Put an "=" sign before the data
C
        IDUM=ICHMV(IBUF,4,2H= ,1,1)
        CALL DATAT(IMODE,IBUF,NCHAR,LUMAT,KECHO,LU,
     .             IBUF2(2),NCH2,IERR)
        GOTO 899
C
C
C     4.  Here we are requesting a type of data from the device.
C     For tape drive communications, the buffer is set up like:
C                   #nns>
C     For other units, the buffer is:
C                   #nns
C     where s=strobe character
C 
400   NCHAR = ICHMV(IBUF,4,LSTROB(-IMODE),1,2)-1
C                   Put proper strobe character followed by > into buffer 
      IF (KTP) CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,IBUF2(2),
     .NCH2,IERR)
C                   Send #nns> to the tape drive and let it get 
C                   ready for the following data request. 
      IF (KTP) NCHAR = 4
C                   For the tape drive, we send #nn? only 
C                   For the other modules, we already have #nns> in the 
C                   buffer and NCHAR is set at the > character
      NCHAR = ICHMV(IBUF,NCHAR,2H? ,1,1)-1
C                   Put the ? into the buffer, so that
C                   for the tape drive, we have #nn?
C                   and for the others, we have #nns?
      CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR)
      GOTO 899
C
C
C     5. For mode 5, send buffer straight to MAT, get response,
C     if any, and return to caller.
C
500   CONTINUE
      NCH=ISCNC(IBUF(2),1,NCHAR-2,2H##)
      IF(NCH.NE.0.AND.NCH.LT.NCHAR-3) THEN
        NCH=NCH+1
        DO I=1,NDEV
          IF (ICHCM(MODTBL(2,I),1,IBUF(2),NCH,2).EQ.0) THEN
            ITN=MODTBL(3,I)+10.*1100./FLOAT(IBMAT)+2.5
            IF(ITO.NE.ITN) THEN
              ITO=ITN
              CALL EXEC(3,2200B+LUMAT,ITO)
            ENDIF
            GOTO 501
          ENDIF
        ENDDO
      ENDIF
501   CONTINUE
      CALL IAT(IBUF(2),NCHAR-2,LUMAT,KECHO,LU,IBUF2(2),
     .NCH2,IERR)
      GOTO 899
C
C
C     6. TEST/RESET mode messages.  Buffer already contains #xx.
C
600   IDUM=ICHMV(IBUF,4,33B,2,1)
      NCH = 4
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR)
C                   Send <escape> to the device
      IF (IERR.LT.0.OR.NCH2.EQ.0) GOTO 900
      IF(ICLASR.EQ.0) CALL CLRQ(1,ICLASR,0)
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
      IDUM=ICHMV(IBUF,1,5HUUUUU,1,5)
C                   Send some UU's to synch up again
      NCH = 5 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERRX)
      GOTO 900
C 
C 
C     7. Query and reset alarm.  Buffer contains address. 
C 
700   IDUM=ICHMV(IBUF,4,2H' ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR) 
C                   Send ' to query alarm 
      IF (IERR.LT.0.OR.NCH2.EQ.0) GOTO 900
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
      IDUM=ICHMV(IBUF,4,2H" ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR) 
C                   Send " to reset alarm 
      IDUM=ICHMV(IBUF,4,2H' ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR) 
      GOTO 899
C 
C 
C     8. Send buffer directly.  Address has already been substituted
C     into first three characters.  Fill in fourth with a blank.
C 
800   IDUM=ICHMV(IBUF,4,2H  ,1,1) 
      CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,IBUF2(2),NCH2,IERR) 
      GOTO 899
C 
C 
C     9.  End of outer loop on class records. 
C 
899   IF ((IERR.LT.0.AND.IERR.NE.-5).OR.NCH2.EQ.0) GOTO 900 
C                   If there was a real error, skip any responses 
C                   EXCEPTION: for wrong-length responses, report 
C                   the actual response - it might be intereseting. 
      IF(ICLASR.EQ.0) CALL CLRQ(1,ICLASR,0)
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
C                   Put response into class 
      IF (IERR.NE.+2) GOTO 900
      LALARM(1) = MODTBL(1,IDEV)
      IDUM=ICHMV(LALARM,10,MODTBL(1,IDEV),1,2)
      IDUM=ICHMV(LALARM,14,MODTBL(2,IDEV),1,2)
      IF(ICLASR.EQ.0) CALL CLRQ(1,ICLASR,0)
      CALL EXEC(20,0,LALARM,-NALARM,2HFS,0,ICLASR)
C                   If alarm was on, send message 
      NCLRER = NCLRER + 1 
C 
900     CONTINUE
C 
C     10. Now we have read all of the class records.  There may have
C     been an error in one record, and there may also be outstanding
C     response class numbers.  If so, do not send back partial classes. 
C     EXCEPTION: for wrong-length responses (IERR=-5) send it back. 
C 
      IF (IERR.LT.0 .AND. IERR.NE.-5 .AND. ICLASR.NE.0) THEN
        DO I=1,NCLRER
          CALL EXEC(21,100000B+ICLASR,IBUF,-ILEN)
        ENDDO
        ICLASR = 0
        NCLRER = 0
      ENDIF
C
1090  IP(1) = ICLASR
      IP(2) = NCLRER
      IP(3) = IERR
      IP(4) = 2HMA
      IP(5) = MODTBL(1,IDEV)
      CALL PRTN(IP)
      CALL EXEC(6,0,1)
C                   SUSPEND HERE *********************************
      CALL RMPAR(IP)
      IP(4) = 2HMA
      GOTO 1
      END
