FTN77,I,Y
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
      PROGRAM DDOUT(3,70)          !  Display log and write it to disk.
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
      character*8 llog0,llogo
      character*63 lnamef
      integer*4 irec,ioff
      integer*2 trimlen
      DIMENSION IP(5),IBUF(60),IREG(2),IDCBL(656),IBUL(60)
      DIMENSION IPARM(2),LHELP(22),IBUR(60),IWHAT(2)
      LOGICAL KACK,KP,KK,KXD,KXL
      EQUIVALENCE (REG,IREG(1),IRGA),(IREG(2),IRGB),(IBUF(9),IBS)
      EQUIVALENCE (PARM,IPARM(1))
      DATA LHELP  /2H!!,2H H,2HEL,2HP!,2H *,2H* ,2HER,2HRO,2HR ,2H  ,
     /             2H  ,2H W,2HRI,2HTI,2HNG,2H L,2HOG,2H F,2HIL,2HE ,
     /             2H(x,2Hx)/
      DATA LNAMEF/' '/
C                                             Last update:  <910214.2152>
C  1. Start here.
C
      KXD = .FALSE.
      KXL = .FALSE.
      IDSCL=0             !  Prepare to allocate a new class number
      CALL CLRQ(1,IDSCL,6HCLOUT )
c     ILOGLU=ICRLOG       !  Save LU of first log as a default for errors
      LLOG0=LLOG          !  Save first log's name too
C            Set bit so that class will keep its number even when empty.
      ICLB=IOR(IAND(ICLBOX,17777B),020000B)
C            Set No-Wait and Save-Buffer bits for peeks into ICLBOX with ICLT
      ICLT=IOR(IAND(ICLBOX,17777B),160000B)
C
C  2. Beginning of main processing loop.
C
20000 CONTINUE
      REG=EXEC(21,ICLB,IBUF,-120,IR1,IR2,IR3)      !  Wait for next message
      IF (IR2.EQ.2HDN) THEN
        KXD = .TRUE.
        GOTO 20000
      ENDIF
      IF (IR2.EQ.2HDF) THEN
        KXD = .FALSE.
        GOTO 20000
      ENDIF
      IF (IR2.EQ.2HLN) THEN
        KXL = .TRUE.
        GOTO 20000
      ENDIF
      IF (IR2.EQ.2HLF) THEN
        KXL = .FALSE.
        GOTO 20000
      ENDIF
      IF(IR2.EQ.-1) GO TO 70000
      IBUFL=IRGB                                   !  Save length read in
      IBULL=ICHMV(IBUL,1,IBUF,1,IBUFL)             !  Save a copy for log
      IF(IBULL.LE.120) IBULL=ICHMV(IBUL,IBULL,2H  ,1,1)-2
C
C  3. Execute this section only if a new log file is requested.
C
      IF (IR2.EQ.2HNL) THEN              !  Request for a new log file
        IERRX=0                              !  Reset log retry error
        LLOGO=' '                            !  Reset first log try
        IF(LNAMEF.eq.' ') CALL fmpCLOSE(IDCBL,ierr)
        LNAMEF=LLOG(:trimlen(llog))//'.LOG::LOG'  !  Build file name
        call fmpopen(idcbl,ierr,lnamef,'rwos',5)  ! Open the new log file
        DO WHILE (IERR.LT.0)                          !  Couldn't open file
C                                                        Try creating it
          call fmpopen(idcbl,ierr,lnamef(:trimlen(lnamef))//':4:48',
     &                 'rwcs',5)
         IF (IERR.LT.0) THEN
            IF (LLOG.EQ.LLOG0) THEN
              LNAMEF=' '
              GOTO 80000
            ENDIF
            LLOGO = LLOG
            LLOG = LLOG0                             !  Try the original log,
C           ICRLOG = ILOGLU                          !  assuming it's on the
            IERRX = IERR                             !  standard LU
            LNAMEF=LLOG(:trimlen(llog))//'.LOG::LOG'
            call fmpopen(idcbl,ierr,lnamef,'rwos',5)
          ENDIF
        ENDDO
        CALL FMPAPPEND(IDCBL,IERR)
        if(ierr.ne.0) call fmpsetposition(idcbl,ierr,1j,0j)
        CALL FMPPOSITION(IDCBL,IERR,IREC,IOFF)
        LEN=FMPREAD(IDCBL,IERR,IBUF,120)
        DO WHILE(LEN.GE.0.or.ierr.lt.0)
          CALL FMPPOSITION(IDCBL,IERR,IREC,IOFF)
          len=fmpread(idcbl,ierr,ibuf,120)
        ENDDO
        CALL FMPSETPOSITION(IDCBL,IERR,IREC,IOFF)
        IF (IREC.GT.1) GO TO 70000           !  Jump if file was old
      ENDIF
C
C  4. Check for ACK response
C
      IF (JCHAR(IBUF,10).NE.57B) THEN
        KACK = .FALSE.                !  Wrong format for a response
      ELSE
        ICH = 1 + ISCNC(IBUF,11,IBUFL,57B)
        IF (ICH.EQ.1) THEN
          KACK = .FALSE.               !  No / in response buffer
        ELSE
C * * * * * * * * * * * * *  REPEAT-UNTIL loop  * * * * * * * * * * * * * * *
          KACK=.TRUE.
48000     CALL GTPRM(IBUF,ICH,IBUFL,0,PARM)
C         IF (JCHAR(PARM,1).EQ.54B) THEN         !  End of response buffer
C           KACK = .TRUE.                        !  All parameters were ACK
C         ELSE IF (ICHCM(PARM,1,4HACK ,1,4).NE.0) THEN
          IF (ICHCM(PARM,1,4HACK ,1,4).NE.0) THEN
            KACK = .FALSE.                       !  Parameter was not ACK
          ELSE IF(ICH.LE.IBUFL) THEN
C         ELSE
            GOTO 48000                           !  Go on to next parameter
C * * * * * * * * * * * *  End REPEAT-UNTIL loop  * * * * * * * * * * * * * *
          ENDIF
        ENDIF
      ENDIF
C
C  5.  Error recognition and message expansion
C
      KP = (JCHAR(IBUF,10).EQ.44B)        !  Is entry from procedure stream?
      IF (KXD .OR. IR2.EQ.-1 .OR. .NOT.(KP.OR.KACK)) THEN
        IF (JCHAR(IR2,1).NE.102B)GO TO 59000     !  Send any error to FSERR
        IF (IDGET(6HFSERR ).EQ.0) GO TO 59000    !  Check that FSERR is o.k.
        IWHE=0                                   !  Reset IWHAT information
        IWHS=0
        IWL=0 
        IWHS=ISCNC(IBUF,11,IBUFL,50B)
        IF (IWHS.NE.0) THEN                          ! If a WHAT field exists
          IWHE=ISCNC(IBUF,11,IBUFL,51B)              ! Get end of WHAT field
          IF (IWHE.NE.0) THEN                        ! Check for WHAT end
            IWL=MIN0(4,IWHE-IWHS-1)                  ! Get WHAT length
            IDUMMY = ICHMV(IWHAT,1,IBUF,IWHS+1,IWL)  ! Save WHAT info
          ENDIF
        ELSE
          IWHS = IBUFL + 1
        ENDIF
        CALL EXEC(23,6HFSERR ,LU,0,0,0,0,IBS,16-IBUFL)
        REG=EXEC(14,1,IBUR,-80)              !  Get the returned information
        IF (IRGA.NE.0)GO TO 59000
        IBURL=IRGB                                   !  Save returned length
        IF (IBURL.EQ.4 .AND. ICHCM(IBUR,1,4HNONO,1,4).EQ.0) GOTO 59000
        IF (IWL.NE.0) THEN                     ! If WHAT field input,
          REG=DXPM(IBUR,IBURL,2H?W,2)          !  check for ?W
          IF (IRGA.NE.0) THEN                  ! If found,
            IWM=MIN0(IRGB,IWL)                 ! find max replacement length
            IDUMMY = ICHMV(IBUR,IRGA,IWHAT,1,IWM)   !  & return WHAT field
          ENDIF
        ENDIF
        IWHS=ICHMV(IBUF,IWHS,2H  ,1,1)         ! Remove leading parenthesis
C 
C               MOVE RETURNED INFO INTO OUTPUT MESSAGE FOR DISPLAY
C 
        IBUFL=ICHMV(IBUF,IWHS,IBUR,1,IBURL)-1 
        REG=DXPM(IBUF,IBUFL,2H?F,2)                  ! Check message for ?F
C 
C               CHECK IF FMGR MESSAGE TO BE APPENDED
C 
        IF (IRGA.NE.0) THEN
          IWM=MIN0(IRGB,IWL)                 !  Move WHAT field into ?F field
          IDUMMY = ICHMV(IBUF,IRGA,IWHAT,1,IWM)
          CALL IFILL(IBUR,1,20,40B)
          IDUMMY = ICHMV(IBUR,1,3HFM ,1,3)     !  Make FM message for FSERR
          IDUMMY = ICHMV(IBUR,4,IWHAT,1,IWM)
C 
C               NOW GO GET FM MESSAGE IF PRESENT
C 
          CALL EXEC(23,6HFSERR ,LU,0,0,0,0,IBUR,-8)
          REG=EXEC(14,1,IBUR,-80)              !  Get returned information
C 
C               CHECK FOR SOMETHING RETURNED
C 
          IF (IRGA.EQ.0 .AND. (IRGB.NE.4 .OR.
     +        ICHCM(IBUR,1,4HNONO,1,4).NE.0) )  THEN
            IRGB=MIN0(119,IBUFL+IRGB)-IBUFL         !  Check for buffer limit
            IBUFL=ICHMV(IBUF,IBUFL+1,2H  ,1,1)      !  Begin with a blank
            IBUFL=ICHMV(IBUF,IBUFL,IBUR,1,IRGB)-1   !  Append info to message
          ENDIF
        ENDIF
C 
C               APPEND BELL IF AN ERROR 
59000   CONTINUE
        IF (JCHAR(IR2,1).EQ.102B) IBUFL=ICHMV(IBUF,IBUFL+1,2H ,1,1)-1
        DO I=1,NLULOG           !  Send log entry to each LU requested
          CALL EXEC(18,LULOG(I),IBUF,-IBUFL,2HFS,IR2,IDSCL)
        ENDDO
        IF (IP(2).NE.IDSCL) THEN                 !  If first time through,
          CALL EXEC(24,6HCLOUT ,IDSCL)           !  start clout,
          IP(2)=IDSCL                            !  and make a note of it.
        ENDIF
      ENDIF
C
C  6.  Write information to the log file if certain conditions are met
C
      IF (KXL .OR. (.NOT.KP .AND. .NOT.KACK)) THEN
        call fmpwrite(idcbl,ierr,ibul,ibull)
        IF (IERR.LT.0) GO TO 80000
      ENDIF
C
C  7. POST messages to disk; return either to caller or to main loop
C
70000 CONTINUE
      IF (IR2.EQ.-1) THEN                    !  The end has occurred
        CALL fmpPOST(IDCBL,IERR)
        GO TO 90000
      ELSE
        REG=EXEC(21,ICLT,IBUFF,-2)         !  Check for more info waiting:
C BEHAVIOR OF A-REG AT ODDS WITH DOCUMENTATION WEH 890121
        IF (IRGA.LT.0) CALL fmpPOST(IDCBL,IERR)      !  If none, post now;
        GOTO 20000                                   !  otherwise, hurry back
      ENDIF
C
C  8. This section is reached if there's trouble with the log file.
C
80000 CONTINUE
      IDUMMY = IB2AS(IERR,LHELP,19,4)              !  Include error code
      IDUMMY = ICHMV(LHELP,42,LLOG,1,2)            !  and log ID in message
      CALL EXEC(18,LU,LHELP,-44,2HFS,IR2,IDSCL)    !  Write error message
      IF (IR2.NE.-1) GO TO 20000        !  Try to continue despite error
C
C  9. This is the point of no return, and the only way to leave the program.
C
90000 CONTINUE
      IF (IPGST(6HFSERR ) .NE.-1)CALL EXEC(24,6HFSERR ,LU,-1)  !  End FSERR
      CALL EXEC(18,0,IBUF,0,2HFS,-1,IDSCL)
      CALL fmpCLOSE(IDCBL,IERR)            !  Close file to get last record
      ICLB=IOR(IAND(ICLB,117777B),100000B)                  !  Deallocate
      CALL EXEC(21,ICLB,IBUF,-2,IR1,IR2,IR3)                !      class.
      CALL IFILL(IP,1,10,0)                        !  Clear IP array
C     CALL IDOFF(6HDDOUT )                 !  Vanish if not in system
      CALL EXEC(6,0,3)                 !  Vanish if not in system
      END
