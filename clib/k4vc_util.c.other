/* k4 VC buffer parsing utilities */

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <limits.h>
#include <math.h>

#include "../include/macro.h"
#include "../include/params.h"
#include "../include/fs_types.h"
#include "../include/fscom.h"         /* shared memory definition */
#include "../include/shm_addr.h"      /* shared memory pointer */

static char device[]={"v4"};           /* device menemonics */

static char *key_lohi[ ]={ "low", "high" };
static char *key_loup[ ]={ "lsb", "usb" };

#define NKEY_LOHI sizeof(key_lohi)/sizeof( char *)
#define NKEY_LOUP sizeof(key_loup)/sizeof( char *)

#define MAX_BUF 512

int k4vc_dec(lcl,ivc,count,ptr)
struct k4vc_cmd *lcl;
int *ivc,*count;
char *ptr;
{
    int ierr, arg_key(), arg_int();
    double atof();
    char buffer[80];
    int ilen, flen;
    char *decloc, *fract;
    int idfok,idf,type;

    ierr=0;
    if(ptr == NULL) ptr="";

start:
    switch (*count) {
    case 1:
      ierr=arg_int(ptr,ivc,0,FALSE);
      if(ierr==0 && (*ivc <1 || *ivc >16))
	ierr=-200;
      break;
    case 2:
      if(shm_addr->k4vclo.freq[*ivc-1]!=0) {
	idfok=TRUE;
	if(shm_addr->k4vclo.freq[*ivc-1]>=24000)
	  idf=1;
	else
	  idf=0;
      } else
	idfok=FALSE;
      ierr=arg_key(ptr,key_lohi,NKEY_LOHI,&lcl->lohi[*ivc-1],idf,idfok);
      break;
    case 3:
      type=shm_addr->equip.rack_type;
      if(type != K42 && type != K42A && type != K42K3 && type != K42AK3) {
	(*count)++;
	goto start;
      }
      ierr=arg_int(ptr,&lcl->att[*ivc-1],0,TRUE);
      if(ierr==0 && (lcl->att[*ivc-1] <0 || lcl->att[*ivc-1] >15))
	ierr=-200;
      break;
    case 4:
      ierr=arg_key(ptr,key_loup,NKEY_LOUP,&lcl->loup[*ivc-1],1,TRUE);
      break;
    default:
      *count=-1;
    }
    
    if(ierr!=0) ierr-=*count;
    if(*count>0) (*count)++;
    return ierr;
}

void k4vc_enc(output,count,lcl)
char *output;
int *count;
struct k4vc_cmd *lcl;
{
  int ivalue, type;

  output=output+strlen(output);

  if(*count > 0 && *count < 17) {
    sprintf(output,"%02d,",*count);
    ivalue=lcl->lohi[ *count-1];
    if(ivalue>=0 && ivalue <NKEY_LOHI)
      strcat(output,key_lohi[ivalue]);
    else
      strcat(output,BAD_VALUE);
    type=shm_addr->equip.rack_type;
    if(type != K42 && type != K42A && type != K42K3 && type != K42AK3)
      ;
    else
      sprintf(output,",%02d,",lcl->att[*count-1]);

    strcat(output,",");
    ivalue=lcl->loup[ *count-1];
    if(ivalue>=0 && ivalue <NKEY_LOUP)
      strcat(output,key_loup[ivalue]);
    else
      strcat(output,BAD_VALUE);

  } else
    *count=-1;
  
  return;
}
void k4vc_mon(output,count,lcl)
char *output;
int *count;
struct k4vc_mon *lcl;
{
  int ivalue, pwr;

  output=output+strlen(output);
  
  if(*count > 0 && *count < 17) {
    if(lcl->yes[*count-1])
      strcpy(output,"yes");
    else
      strcpy(output,"no");
    
    strcat(output,",");
    pwr=lcl->usbpwr[*count-1];
    if(pwr>= 0 && pwr <= 99)
      sprintf(output+strlen(output),"%02d",pwr);
    else
      strcat(output,BAD_VALUE);

    strcat(output,",");
    pwr=lcl->lsbpwr[*count-1];
    if(pwr>= 0 && pwr <= 99)
      sprintf(output+strlen(output),"%02d",pwr);
    else
      strcat(output,BAD_VALUE);
  } else
    *count=-1;

  return;
}

k4vc_req_q(ip)
long ip[5];
{
 ib_req7(ip,device,13*16+2,"RD");

 ib_req7(ip,device,13*16+2,"LV");

}

k4vc_req_c(ip,lclc,ivc)
long ip[5];
struct k4vc_cmd *lclc;
int ivc;
{
  char buffer[20];

  sprintf(buffer,"CH%02d",ivc);
  
  if(lclc->lohi[ivc-1])
    strcat(buffer," HIF");
  else
    strcat(buffer," LIF");

  if(lclc->loup[ivc-1])
    strcat(buffer," USB");
  else
    strcat(buffer," LSB");

  ib_req2(ip,device,buffer);

}

k4vc_res_q(lclc,lclm,ip)
struct k4vc_cmd *lclc;
struct k4vc_mon *lclm;
long ip[5];
{
  char buffer[MAX_BUF];
  int max,i;
  int icount;
  char lohi, loup;

  max=sizeof(buffer);
  ib_res_ascii(buffer,&max,ip);
  if(max < 0) {
    ip[2]=-1;
    return;
  }

  for(i=0;i<16;i++) {
    if(3!=(icount=sscanf(buffer+8*i+4,"%c%c%c",
		 lclm->yes+i,&lohi,&loup))) {
      ip[2]=-1;
      return;
    }

    if(index("YN",lclm->yes[i])==NULL || lclm->yes[i]==0) {
      ip[2]=-1;
      return;
    }
    if(index("LH",lohi)==NULL || lohi==0) {
      ip[2]=-1;
      return;
    } else if(lohi == 'H')
      lclc->lohi[i]=1;
    else
      lclc->lohi[i]=0;

    if(index("LU",loup)==NULL || loup==0) {
      ip[2]=-1;
      return;
    } else if(loup == 'U')
      lclc->loup[i]=1;
    else
      lclc->loup[i]=0;
    

  }

  max=sizeof(buffer);
  ib_res_ascii(buffer,&max,ip);
  if(max < 0) {
    ip[2]=-2;
    return;
  }
    
  for(i=0;i<16;i++) {
    if(2!=sscanf(buffer+9*i+3,"%2d/%2d",
		 lclm->usbpwr+i,lclm->lsbpwr+i)) {
      ip[2]=-2;
      return;
    }
  }

}


