#!/usr/bin/perl
#
# Copyright (c) 2023 NVI, Inc.
#
# This file is part of VLBI Field System
# (see http://github.com/nvi-inc/fs).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

sub time_add {
#
# calculate time of the log entry
# everything is measured relative to $reftime, first time in log
# it will make a mess of $reftime is not reasonable
#
    my ($time, $ref_add) = @_;
    my @result=@{$time};
    my @add=@{$ref_add};
#    print join(' ',@result), " in\n";
#    print join(' ',@add), " add in\n";

# seconds

   $result[4]+=$add[4];
   if($result[4] > 59) {
       $rem=$result[4] % 60;
       $quo=int($result[4]/60);
#       print "quo $quo rem $rem \n";
       $result[4]=$rem;
       $result[3]+=$quo;
   } elsif ($result[4]<0) {
       $rem=$result[4] % 60;
       $quo=-1+int($result[4]/60);
#       print "quo $quo rem $rem \n";
       $result[4]=$rem;
       $result[3]+=$quo;
   }

# minutes

   $result[3]+=$add[3];
   if($result[3] > 59) {
       $rem=$result[3] % 60;
       $quo=int($result[3]/60);
#       print "quo $quo rem $rem \n";
       $result[3]=$rem;
       $result[2]+=$quo;
   } elsif ($result[3]<0) {
       $rem=$result[3] % 60;
       $quo=-1+int($result[3]/60);
#       print "quo $quo rem $rem \n";
       $result[3]=$rem;
       $result[2]+=$quo;
   }

# hours

   $result[2]+=$add[2];
   if($result[2] > 23) {
       $rem=$result[2] % 24;
       $quo=int($result[2]/.0);
#       print "quo $quo rem $rem \n";
       $result[2]=$rem;
       $result[1]+=$quo;
   } elsif ($result[2]<0) {
       $rem=$result[2] % 24;
       $quo=-1+int($result[2]/24);
#       print "quo $quo rem $rem \n";
       $result[2]=$rem;
       $result[1]+=$quo;
   }

# days

# we don't handle leap years yet

   $result[1]+=$add[1];
   if($result[1] > 365) {
       $rem=$result[1] % 365;
       $quo=int($result[1]/.0);
#       print "quo $quo rem $rem \n";
       $result[1]=$rem;
       $result[0]+=$quo;
   } elsif ($result[1]<0) {
       $rem=$result[1] % 365;
       $quo=-1+int($result[1]/365);
#       print "quo $quo rem $rem \n";
       $result[1]=$rem;
       $result[0]+=$quo;
   }

#years

   $result[0]+=$add[0];

    return (@result);
}
#
# main program
#

# 1.0 Initialize

require "getopts.pl";

if (!&Getopts("hV")) {
  print STDERR "For help, try: '$0 -h'\n";
  exit -1;
}

if ($#ARGV < 0 &&!defined($opt_h) &&!defined($opt_V)) {
        print STDERR "For help, try: '$0 -h'\n";
        exit 0;
}

if(defined($opt_V)) {
    print "[auto_start 0.2]\n";
    exit 0;
}

if (defined($opt_h)) {
    print "Usage: $0 [options] [sessions]

Synopsis: This script puts commands in the FS time-list to
automatically start a schedule, and start/stop antenna, at a later
time. The exit code is 0 for no error. The script stops at the first
error detected and exits with a non-zero code.

If the first time-block command in a 'session' SNAP file is at least
10 minutes in the future, the script will send the FS a time-list
commands to start the schedule 10 minutes early and execute the
'ant_start' SNAP procedure two minutes after that. The 'ant_stop' SNAP
procedure will be scheduled to execute five minutes after the last
time-block command in the SNAP file.

It is assumed that there will be 'ant_start' and 'ant_stop' SNAP
procedures (usually in the 'station' procedure) that will start and
stop the antenna. For both procedures, it might be a good idea to try
the corresponding action more than once, if that is benign. This will
be more robust in case there are errors. If it is not necessary to
take action to start or stop the antenna, the corresponding procedures
can be left empty.

The FS must be running and the STATION environment variable defined
with the two-letter station code.

Multiple sessions can be processed if the result makes sense. However,
the FS time-list can only hold a small number of entries. Currently,
the limit is 15. With that limit, the maximum number a sessions that
should be waiting should be four to allow room for other timed
commands.

Option explanations:

 -h        print this help information and stop
 -V        print program version information and stop
";
    exit 0;
}

$station= lc $ENV{'STATION'};
if($station eq "") {
    print STDERR "STATION environment variable not defined.\n";
    exit -1
}
foreach $name (@ARGV) {
    $file = "/usr2/sched/${name}$station.snp";
    open(FILE,$file) || do {
	print STDERR "can't open $file: $!\n";
	next;
    };
#    print "file $file \n";

    $kfirst=1;
    while (<FILE>) {
        if(/^!(\d{4})\.(\d{3})\.(\d{2}):(\d{2}):(\d{2})/) {
#            print;
#            print "$1 $2 $3 $4 $5\n";

#  find first time

            @sndval =  ($1,$2,$3,$4,$5);
            if($kfirst == 0) {
                 next;
            }
            $kfirst=0;
#            print join(' ',@sndval), " snd\n";
#            print join(' ',@addval), " add\n";

# set start time

            @addval =  ( 0, 0, 0,-10, 0);
            @retval = time_add(\@sndval,\@addval);
#            print join(' ',@retval), " ret\n";

# is the start time in the past or now?

            ($sec,$min,$hour,$mday,$mon,$year,$wday,$doy) = gmtime();
            $year+=1900;
            $doy++;
#            print "year $year doy $doy $hour $min $sec \n";

            if($year >  $retval[0] ||
               $year == $retval[0] && $doy >  $retval[1] ||
               $year == $retval[0] && $doy == $retval[1] && $hour >  $retval[2] ||
               $year == $retval[0] && $doy == $retval[1] && $hour == $retval[2] && $min >  $retval[3] ||
               $year == $retval[0] && $doy == $retval[1] && $hour == $retval[2] && $min == $retval[3] && $sec >= $retvl[4]) {
                print STDERR "Auto-start time is in the past: ", join(' ',@retval),"\n";
                exit -1;
             }

# schedule start

            $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap schedule=$name$station,#1\@",@retval);
#            print "command $command\n";
            $result=system($command);
#            print "result $result\n";
            if($result !=0 ) {
                print STDERR  "setting schedule auto-start failed, result: $result\n";
                exit -1;
            }

# antenna start

            @sndval=@retval;
            @addval =  ( 0, 0, 0, 2, 0);
            @retval = time_add(\@sndval,\@addval);
#            print join(' ',@retval), " ret\n";
            $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap ant_start\@",@retval);
#            print "command $command\n";
            $result=system($command);
#            print "result $result\n";
            if($result !=0 ) {
                print STDERR  "setting antenna auto-start failed, result: $result\n";
                exit -1;
            }
        }
    }

# antenna stop use last sndval

#    print "end @sndval\n";
    @addval =  ( 0, 0, 0, 5, 0);
    @retval = time_add(\@sndval,\@addval);
#    print join(' ',@retval), " ret\n";
    $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap ant_stop\@",@retval);
#    print "command $command\n";
    $result=system($command);
#    print "result $result\n";
    if($result !=0 ) {
        print STDERR  "setting antenna auto-stop failed, result: $result\n";
        exit -1;
    }
}
exit 0;
