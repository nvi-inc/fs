#!/usr/bin/perl
#
# Copyright (c) 2023 NVI, Inc.
#
# This file is part of VLBI Field System
# (see http://github.com/nvi-inc/fs).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

sub time_add {
#
# calculate time of the log entry
# everything is measured relative to $reftime, first time in log
# it will make a mess of $reftime is not reasonable
#
    my ($time, $ref_add) = @_;
    my @result=@{$time};
    my @add=@{$ref_add};
#    print join(' ',@result), " in\n";
#    print join(' ',@add), " add in\n";

# seconds

   $result[4]+=$add[4];
   if($result[4] > 59) {
       $rem=$result[4] % 60;
       $quo=int($result[4]/60);
#       print "quo $quo rem $rem \n";
       $result[4]=$rem;
       $result[3]+=$quo;
   } elsif ($result[4]<0) {
       $rem=$result[4] % 60;
       $quo=-1+int($result[4]/60);
#       print "quo $quo rem $rem \n";
       $result[4]=$rem;
       $result[3]+=$quo;
   }

# minutes

   $result[3]+=$add[3];
   if($result[3] > 59) {
       $rem=$result[3] % 60;
       $quo=int($result[3]/60);
#       print "quo $quo rem $rem \n";
       $result[3]=$rem;
       $result[2]+=$quo;
   } elsif ($result[3]<0) {
       $rem=$result[3] % 60;
       $quo=-1+int($result[3]/60);
#       print "quo $quo rem $rem \n";
       $result[3]=$rem;
       $result[2]+=$quo;
   }

# hours

   $result[2]+=$add[2];
   if($result[2] > 23) {
       $rem=$result[2] % 24;
       $quo=int($result[2]/.0);
#       print "quo $quo rem $rem \n";
       $result[2]=$rem;
       $result[1]+=$quo;
   } elsif ($result[2]<0) {
       $rem=$result[2] % 24;
       $quo=-1+int($result[2]/24);
#       print "quo $quo rem $rem \n";
       $result[2]=$rem;
       $result[1]+=$quo;
   }

# days

# we don't handle leap years yet

   $result[1]+=$add[1];
   if($result[1] > 365) {
       $rem=$result[1] % 365;
       $quo=int($result[1]/.0);
#       print "quo $quo rem $rem \n";
       $result[1]=$rem;
       $result[0]+=$quo;
   } elsif ($result[1]<0) {
       $rem=$result[1] % 365;
       $quo=-1+int($result[1]/365);
#       print "quo $quo rem $rem \n";
       $result[1]=$rem;
       $result[0]+=$quo;
   }

#years

   $result[0]+=$add[0];

    return (@result);
}
#
# main program
#

# 1.0 Initialize

require "getopts.pl";

if (!&Getopts("ehv")) {
  print STDERR "For help, try: '$0 -h'\n";
  exit -1;
}

if ($#ARGV < 0 &&!defined($opt_h) &&!defined($opt_v)) {
        print STDERR "For help, try: '$0 -h'\n";
        exit 0;
}

if(defined($opt_v)) {
    print "[auto_start 0.6]\n";
    exit 0;
}

if (defined($opt_h)) {
    print "Usage: $0 [options] [schedule]

Synopsis: This script puts commands in the FS time-list to
automatically start a 'schedule' (use just the experiment name or
session code, the station code is automatically appended), and
start/stop the antenna, at later times. The exit code is zero for no
error. The script stops at the first error detected and exits with a
non-zero code.

The first time-block command in the 'schedule' SNAP file must be at
least 10 minutes in the future, If so, the script will send the FS
time-list commands to:

 * start the schedule 10 minutes early
 * execute the 'ant_start' SNAP procedure two minutes after that
 * execute the 'ant_stop' SNAP procedure five minutes after the last
   time-block command in the SNAP file.

'ant_start' and 'ant_stop' SNAP procedures are required to already
exist in the 'station' procedure library to, respectively, start and
stop the antenna. For both procedures, it might be a good idea to try
the corresponding action more than once, if that is benign. That will
be more robust in case there are errors. If it is not necessary to
take action to start or stop the antenna, the corresponding procedures
can be left empty.

The FS must be running and the STATION environment variable defined
with the two-letter station code.

The '-e' option can be used to suppress all the commands except the
'ant_stop' after the schedule. This can be useful if it was necessary
to restart the FS or the 'ant_stop' procedure was otherwise removed
from time-list. The FS 'ti' SNAP command can be used to show what is
in the time-list.

Multiple 'schedule's can be processed if the result makes sense.
However, the FS time-list can only hold a small number of entries.
Currently, the limit is 15. With that limit, the maximum number a
schedules that should be set for 'auto-start' is four, to allow room
for other timed commands.

Option explanations:

 -e        only command 'ant_stop' for the end of the schedule
 -h        print this help information and stop
 -v        print program version information and stop
";
    exit 0;
}

$station= lc $ENV{'STATION'};
if($station eq "") {
    print STDERR "STATION environment variable not defined.\n";
    exit -1
}
foreach $name (@ARGV) {
    $file = "/usr2/sched/${name}$station.snp";
    open(FILE,$file) || do {
	print STDERR "can't open $file: $!\n";
	next;
    };
#    print "file $file \n";

    $kfirst=1;
    while (<FILE>) {
        if(/^!(\d{4})\.(\d{3})\.(\d{2}):(\d{2}):(\d{2})/) {
#            print;
#            print "$1 $2 $3 $4 $5\n";

#  find first time

            @timval =  ($1,$2,$3,$4,$5);
            if($kfirst == 0 || $opt_e) {
                 next;
            }
            $kfirst=0;
#            print join(' ',@timval), " tim\n";
#            print join(' ',@addval), " add\n";

# set start time

            @addval =  ( 0, 0, 0,-10, 0);
            @retval = time_add(\@timval,\@addval);
#            print join(' ',@retval), " ret\n";

# is the start time in the past or now?

            ($sec,$min,$hour,$mday,$mon,$year,$wday,$doy) = gmtime();
            $year+=1900;
            $doy++;
#            print "year $year doy $doy $hour $min $sec \n";

            if($year >  $retval[0] ||
               $year == $retval[0] && $doy >  $retval[1] ||
               $year == $retval[0] && $doy == $retval[1] && $hour >  $retval[2] ||
               $year == $retval[0] && $doy == $retval[1] && $hour == $retval[2] && $min >  $retval[3] ||
               $year == $retval[0] && $doy == $retval[1] && $hour == $retval[2] && $min == $retval[3] && $sec >= $retvl[4]) {
                print STDERR "Auto-start time is in the past: ", join(' ',@retval),"\n";
                exit -1;
             }

# schedule start

            $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap schedule=$name$station,#1\@",@retval);
#            print "command $command\n";
            $result=system($command);
#            print "result $result\n";
            if($result !=0 ) {
                print STDERR  "setting schedule auto-start failed, result: $result\n";
                exit -1;
            }

# antenna start

            @timval=@retval;
            @addval =  ( 0, 0, 0, 2, 0);
            @retval = time_add(\@timval,\@addval);
#            print join(' ',@retval), " ret\n";
            $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap ant_start\@",@retval);
#            print "command $command\n";
            $result=system($command);
#            print "result $result\n";
            if($result !=0 ) {
                print STDERR  "setting antenna auto-start failed, result: $result\n";
                exit -1;
            }
        }
    }

# antenna stop use last timval

#    print "end @timval\n";
    @addval =  ( 0, 0, 0, 5, 0);
    @retval = time_add(\@timval,\@addval);
#    print join(' ',@retval), " ret\n";
    $command = sprintf("%s%04d.%03d.%02d:%02d:%02d","inject_snap ant_stop\@",@retval);
#    print "command $command\n";
    $result=system($command);
#    print "result $result\n";
    if($result !=0 ) {
        print STDERR  "setting antenna auto-stop failed, result: $result\n";
        exit -1;
    }
}
exit 0;
