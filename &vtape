FTN4X 
$FILES (0,1)
C     RJ Cappallo  Program VTAPE - handles Honeywell x-ports - 11/80
C     Main program - decodes commands & invokes proper subroutines. 
      PROGRAM VTAPE (3,90)
C 
C     :RU,VTAPE,<transport ref. #>,<command string> 
C 
C     where <trans. ref. #> is an arbitrary integer associated with 
C     a particular transport...defined by a DE command, and refer-
C     enced by all other commands.
C 
C 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      LOGICAL*2 LINTER
      INTEGER*2 IBUF(40),JBUF(3),IPAR(5),ISPAQ(2) 
      DATA ISPAQ /1,' '/
C 
      CALL RMPAR(IPAR)
C     Get parameters from RU,VTAPE.. string.
  10  LUOP=LUOPR()
      CALL GETST (IBUF(2),-78,IBUF(1))
      KERR=-7 
      IF (IBUF(1) .LE.0) THEN 
          WRITE (LUOP,11) 
 11       FORMAT ("Valid scheduling sequences are:",/,
     .":RU,VTAPE,<drive #>  goes interactive; quit with :: command.",/, 
     .":RU,VTAPE,<drive #>,??  lists allowable commands.",/,
     .":RU,VTAPE,<drive #>,??,<command>  describes specific command.")  
          GOTO 99 
      ENDIF 
C     Delete all blanks.
      CALL IXQ (IBUF,ISPAQ,0,0) 
C     Something was input, should be transport ref# first.
      ISTRC=1 
      NREF=KVALQ(IBUF,IERR,ISTRC) 
      IF (IERR.EQ.1) GOTO 90
C     Valid ref# found, find rest of string, interactively if necess. 
      IF (ISTRC.GE.IBUF(1)) THEN
C          Interactive
           LINTER=.TRUE.
           LUINT=LUOP 
  20       WRITE (LUOP,'("?_")')
           READ (LUOP,'(39A2)') (IBUF(I),I=2,40)
           IBUF(1)=ITLOG()
           CALL IXQ (IBUF,ISPQ,0,0) 
      ELSE
C          Not interactive- squeeze tref# out of command string.
           LINTER=.FALSE. 
           IF (IPAR(1) .EQ.0) THEN
               LUINT=64 
           ELSE 
               LUINT=LUOP    !sched. by file man. -- write to term. 
           ENDIF
           LENGTH=IBUF(1)-ISTRC 
           CALL MOVEQ(IBUF,ISTRC+1,IBUF,1,LENGTH) 
           IBUF(1)=LENGTH 
      ENDIF 
C 
C     Command is first in buffer; decode and call right modules.
C 
      ISTRC=1 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,1,2H ,) 
      KERR=-7 
      IF (JBUF(1) .NE.2) GOTO 90
C     Two-letter command, decode. 
      KODE=JBUF(2)
      IF (KODE.EQ.2H??) THEN  
          CALL TAPQM (LUOP,IBUF,KERR) 
      ELSE IF (KODE.EQ.2HEK) THEN 
          CALL TAPEK (IBUF,LUOP,LUEK,KERR)
      ELSE IF (KODE.EQ.2HOF) THEN 
          LUEK=0
          KERR=0
      ELSE IF (KODE.EQ.2HLK) THEN 
C         Lock self into core.
          CALL EXEC (22,1)
          KERR=0
      ELSE IF (KODE.EQ.2H::) THEN 
          KERR=0
      ELSE IF (KODE.EQ.2HDE) THEN 
          CALL TAPDE (NREF,IBUF,KERR) 
      ELSE
          INDEX=ISLOT(NREF,KERR)
          IF (KERR.NE.-3) THEN
              CALL TAPHI (.TRUE.,INDEX,IBUF)
              IF (KODE.EQ.2HRG) THEN
                  CALL TAPRG (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HTM) THEN 
                  CALL TAPTM (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HEN) THEN 
                  CALL TAPEN (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HAQ) THEN 
                  CALL TAPAQ (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HDI) THEN 
                  CALL TAPDI (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HRP) THEN 
                  CALL TAPRP (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HTE) THEN 
                  CALL TAPTE (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HBS) THEN 
                  CALL TAPBS (INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HRA) THEN 
                  CALL TAPRA (INDEX,KERR) 
              ELSE IF (KODE.EQ.2HST) THEN 
                  CALL TAPST (LUINT,INDEX,IBUF,IPAR,KERR) 
              ELSE IF (KODE.EQ.2HAS) THEN 
                  CALL TAPAS (LUINT,INDEX,IBUF,KERR)
              ELSE IF (KODE.EQ.2HME) THEN 
                  CALL TAPME (LUINT,INDEX,IBUF,IPAR,KERR) 
              ELSE IF (KODE.EQ.2HHI) THEN 
                  CALL TAPHI (.FALSE.,INDEX,IBUF,LUOP)  
              ELSE
                  KERR=-7 
              ENDIF 
          ENDIF 
      ENDIF 
C 
  90  IF (KERR.LT.0) THEN 
          WRITE (LUINT,'("VTAPE error code",I3," on #",I3,  
     .                  " while executing _")') KERR,NREF 
          CALL WRITQ (LUINT,IBUF) 
      ENDIF 
C     If interactive, get another command.
      IF (LINTER .AND. KODE.NE.2H::) GOTO 20
C     Return MAT replies, go dormant saving resources.
 99   IPAR(1)=MIN0 (KERR,0) 
      CALL PRTN(IPAR) 
      CALL EXEC(6,0,1)
      CALL RMPAR (IPAR) 
      GOTO 10 
      END 
C     Subroutine TAPDE -defines transport ref# characteristics RJC 12/80
      SUBROUTINE TAPDE (NREF,IBUF,KERR) 
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 IBUF(1),JBUF(3),IBCODE(2,5),INIT1(7),INIT2(6),INIT3(4), 
     .          INIT5(2),INIT6(5),MESSUN(7)   
      INTEGER*4 KOINIT(7) 
      DATA KOMMA/2H ,/,IBCODE/300,6,1200,9,2400,11,4800,13,9600,15/,
     .     INIT1/12,'RG,720,0,2,2'/,INIT2/10,'AQ,NOR,1,1'/, 
     .     INIT3/5,'DI,FO'/,INIT5/2,'EN'/, !INIT4 was DI,FRS
     .     INIT6/7,'TM,LTON'/,  
     .     KOINIT/25400401B,      ! !00560101  AQ,NOR,1,1 
     .            0B,             ! %00000000  EN 
     .            20000000000B,   ! (80000000  DI,FO  TM,LTON 
     .            710000000B,     ! )07200000  RG,720,0,2,2 
     .            25400000B,      ! +00560000 
     .            0B,0B/,         ! -00000000 .00000000 
     .     MESSUN/'EQ,       ,UN'/
C 
C     Find correct table entry, or first vacant one.
      INDEX=ISLOT(NREF,KERR)
      IF (KERR.EQ.-3) THEN
          NDFIND=NDFIND+1 
          IF (NDFIND.GT.8) THEN 
              KERR=-8 
              GOTO 99 
          ENDIF 
          INDEX=NDFIND
          IDEVTB(1,INDEX)=NREF
      ENDIF 
      CALL TAPHI (.TRUE.,INDEX,IBUF)
C     Parse command string for MAT address. 
      ISTRC=4 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,KOMMA)
C     Check for valid hex digits for MAT address. 
      IF (JBUF(1).NE.2) GOTO 90 
      DO 20 I=1,2 
          IDIG=IGETQ(JBUF,I)
          IF(IDIG.LT.48 .OR. IDIG.GT.57.AND.IDIG.LT.65 .OR. IDIG.GT.70) 
     .      GOTO 90 
 20       CONTINUE
C     Valid digits, plug table. 
      IDEVTB(2,INDEX)=JBUF(2) 
      KERR=0
C     Parse for drive LU, if there, else use default. 
      IF (ISTRC.LE.IBUF(1)) THEN
          IDEVTB(3,INDEX)=KVALQ(IBUF,IERR,ISTRC)
          IF (IERR.NE.0) GOTO 90
      ELSE
          IDEVTB(3,INDEX)=25
      ENDIF 
C     Parse for baud rate, or use default.
      IF (ISTRC.LE.IBUF(1)) THEN
          IBAUD=KVALQ(IBUF,IERR,ISTRC)
          IF (IERR.NE.0) GOTO 90
C         Find code for this baud-rate. 
          DO 30 I=1,5 
              IF (IBAUD.EQ.IBCODE(1,I)) GOTO 35 
 30           CONTINUE
          GOTO 90 
 35       IDEVTB(4,INDEX)=IBCODE(2,I) 
C     Default=2400 baud.
      ELSE
          IDEVTB(4,INDEX)=11
      ENDIF 
C 
C     Parse for communications option, if present.
      IF (ISTRC.LE.IBUF(1)) THEN
          ICOM=KVALQ (IBUF,IERR,ISTRC)
          IF(IERR.NE.0 .OR. ICOM.LT.0 .OR. ICOM.GT.1) GOTO 90 
          IDEVTB(5,INDEX)=ICOM
C     Default is no verify. 
      ELSE
          IDEVTB(5,INDEX)=0 
      ENDIF 
C 
C     Parse for InHibit option. 
      IF (ISTRC.LE.IBUF(1)) THEN
          CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,KOMMA)
          IF (JBUF(1).EQ.2 .AND. JBUF(2).EQ. 2HIH) THEN 
              KERR=0
              GOTO 99 
          ELSE
              GOTO 90 
          ENDIF 
      ENDIF 
C 
C     Initialize transport. 
C 
C     Disable LU. 
      LU=IDEVTB(3,INDEX)
      CALL CN21 (LU)
C     Set 12966 baud rate.
      CALL EXEC (3, 3300B+LU, IDEVTB(4,INDEX))
C     Unbuffer this LU. 
      IEQT=IAND (IGETS (IGETS(1652B)+LU-1) ,77B)
      CALL CNUMD (IEQT, MESSUN(3))
      CALL MESSS (MESSUN,13)
C 
      DO 50 I=1,7 
 50       KOMMND(I,INDEX)=KOINIT(I) 
C 
      CALL TAPRA (INDEX,KERR) 
      IF (KERR .LT.0) GOTO 99 
      CALL TAPRG (INDEX,INIT1,KERR) 
C     Temporary fix for controller ALARM on not ready. REMOVE!!!
      IF (KERR .EQ.-1) THEN 
          CALL TAPRA (INDEX,KERR) 
          CALL TAPOT (INDEX,5,KERR) 
      ENDIF 
C     .......end fix. 
      IF (KERR.LT.0) GOTO 99
C 
      CALL TAPAQ (INDEX,INIT2,KERR) 
      IF (KERR.LT.0) GOTO 99
C 
      CALL TAPDI (INDEX,INIT3,KERR) 
      IF (KERR.LT.0) GOTO 99
C 
      CALL TAPEN (INDEX,INIT5,KERR) 
      IF (KERR.LT.0) GOTO 99
C 
      CALL TAPTM (INDEX,INIT6,KERR) 
      GOTO 99 
C     Syntax error. 
  90  KERR=-7 
 99   RETURN
      END 
C     ISLOT finds correct slot# for NREF. RJC 12/80 
      FUNCTION ISLOT(NREF,KERR) 
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
C     Guilty till proven innocent (of a syntax error).
      KERR=-3 
      IF (NDFIND .GT. 0) THEN 
          DO 4 I=1,NDFIND 
              IF (NREF .EQ. IDEVTB(1,I)) THEN 
                  ISLOT=I 
                  KERR=0
              ENDIF 
 4            CONTINUE
      ENDIF 
      RETURN
      END 
C     Subroutine TAPRG -controls the rate generator. RJC 1/81 
      SUBROUTINE TAPRG (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 IBUF(1),JBUF(3),QEQ(18),I42(2)
      INTEGER*4 I4,I4GET
      LOGICAL SAMEQ 
      EQUIVALENCE (I4,I42(1)) 
      DATA KOMMA/' ,'/, QEQ/1,'4',6,1,'2',5,1,'1',4,1,'H',3,
     .     1,'Q',2,1,'E',1/ 
C     Read ) strobe to get current state of motion. 
      CALL TAPIN (INDEX,4,KERR) 
      KOMMND(4,INDEX)=KSTATE(4,INDEX) 
C 
      ISTRC=4 
C     Parse rate generator frequency field. 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .GT.0) THEN 
          I42(2)=IBCD(JBUF) 
          IF (I42(2).EQ.-1 .OR. JBUF(1).GT.3) THEN  
              KERR=-7 
              RETURN
          ENDIF 
          CALL I4PUT (27, 16, KOMMND(4,INDEX), I4)
      ENDIF 
C     Parse rate timer field. 
      CALL IPRSQ(IBUF,JBUF,4,ISTRC,2,KOMMA) 
      IF (JBUF(1) .EQ.0) THEN 
C         Default timer value is zero.
          I4=0
      ELSE
          I42(2)=IBCD(JBUF) 
          IF (I42(2).EQ.-1) THEN  
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (15,0, KOMMND(4,INDEX), I4)
C     Parse bit-synch. bandwidth. 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .GT.0) THEN 
          I4=0
          DO 20 I=1,16,3
              IF (SAMEQ(JBUF,QEQ(I))) I4=QEQ(I+2)+1 
 20           CONTINUE
          IF (I4.EQ.0) THEN 
C             Didn't find a matching bandwidth code.
              KERR=-7 
              RETURN
          ENDIF 
C         Stuff BW code into both acq. and playback strobes.
          CALL I4PUT (18,16, KOMMND(1,INDEX), I4) 
          CALL I4PUT (18,16, KOMMND(5,INDEX), I4) 
      ENDIF 
C     Parse for equalizaton bandwidth.
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .GT.0) THEN 
          I4=0
          DO 40 I=1,16,3
              IF (SAMEQ(JBUF,QEQ(I))) I4=QEQ(I+2) 
 40           CONTINUE
          IF (I4.EQ.0) THEN 
              KERR=-7 
              RETURN
          ENDIF 
C 
          CALL I4PUT (22,20, KOMMND(1,INDEX), I4) 
          CALL I4PUT (22,20, KOMMND(5,INDEX), I4) 
      ENDIF 
C 
      CALL TAPOT (INDEX,4,KERR) 
C     Restore old RG value if new request is timed. 
      IF (I4GET (15,0,KOMMND(4,INDEX)) .NE.0) 
     .    KOMMND(4,INDEX)=KSTATE(4,INDEX) 
C     DEBUG DEBUG 
      IF (I4GET(23,16,KOMMND(5,INDEX)).NE.86J) THEN 
C-----        WRITE(14, 
C----. '("&dB -VTAPE ERROR- go on, but call Roger 448-2826")')
C----     WRITE(16,'("INDEX,IBUF,QEQ=",(/,10I6))')  
C----.      INDEX,(IBUF(I),I=1,30),QEQ  
C----     CALL TAPHI (.FALSE.,INDEX,0,16) 
          CALL I4PUT (23,16,KOMMND(5,INDEX),86J)
      ENDIF 
C     Issue bandwidth commands. 
      IF (KERR.GE.0) CALL TAPOT (INDEX,5,KERR)
      RETURN
      END 
C     Subroutine TAPTM - controls motion of tape..RJC 1/81
      SUBROUTINE TAPTM (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 IBUF(1),JBUF(3),QREV(3),QFA(2),QFOR(3),QLO(2),QST(2), 
     .          QREC(3),QLTON(3),QLTOF(3),QTMON(3),QTMOF(3),Q240(3),
     .          Q120(3),Q60(2),Q30(2),Q15(2),Q8(2)
      INTEGER*4 IPSKOD
      LOGICAL SAMEQ,ZREV,ZFA,ZFOR,ZLO,ZST,ZREC,ZLTON,ZLTOF,ZTMON,ZTMOF, 
     .        ZIPS,ZERR,ZNOREC
      DATA QREV/3,'REV'/,QFA/2,'FA'/,QFOR/3,'FOR'/,QLO/2,'LO'/, 
     .     QST/2,'ST'/,QREC/3,'REC'/,QLTON/4,'LTON'/,QLTOF/4,'LTOF'/, 
     .     QTMON/4,'TMON'/,QTMOF/4,'TMOF'/,Q240/3,'240'/,Q120/3,'120'/, 
     .     Q60/2,'60'/,Q30/2,'30'/,Q15/2,'15'/,Q8/1,'8'/
C     Initialize logical indicators for command presence to be off. 
      ZREV  =.FALSE.
      ZFA   =.FALSE.
      ZFOR  =.FALSE.
      ZLO   =.FALSE.
      ZST   =.FALSE.
      ZREC  =.FALSE.
      ZLTON =.FALSE.
      ZLTOF =.FALSE.
      ZTMON =.FALSE.
      ZTMOF =.FALSE.
      ZIPS  =.FALSE.
      ZNOREC=.FALSE.
C 
      ISTRC=4 
      DO 50 I=1,32767 
          IF (ISTRC .LE. IBUF(1)) THEN
C             More characters to parse. 
              CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,2H ,) 
              IF      (SAMEQ(QREV ,JBUF)) THEN $ ZREV  =.TRUE.
              ELSE IF (SAMEQ(QFA  ,JBUF)) THEN $ ZFA   =.TRUE.
              ELSE IF (SAMEQ(QFOR ,JBUF)) THEN $ ZFOR  =.TRUE.
              ELSE IF (SAMEQ(QLO  ,JBUF)) THEN $ ZLO   =.TRUE.
              ELSE IF (SAMEQ(QST  ,JBUF)) THEN $ ZST   =.TRUE.
              ELSE IF (SAMEQ(QREC ,JBUF)) THEN $ ZREC  =.TRUE.
              ELSE IF (SAMEQ(QLTON,JBUF)) THEN $ ZLTON =.TRUE.
              ELSE IF (SAMEQ(QLTOF,JBUF)) THEN $ ZLTOF =.TRUE.
              ELSE IF (SAMEQ(QTMON,JBUF)) THEN $ ZTMON =.TRUE.
              ELSE IF (SAMEQ(QTMOF,JBUF)) THEN $ ZTMOF =.TRUE.
              ELSE IF (SAMEQ(Q240,JBUF)) THEN 
                  ZIPS=.TRUE. 
                  IPSKOD=7
              ELSE IF (SAMEQ(Q120,JBUF)) THEN 
                  ZIPS=.TRUE. 
                  IPSKOD=6
              ELSE IF (SAMEQ(Q60,JBUF)) THEN
                  ZIPS=.TRUE. 
                  IPSKOD=5
              ELSE IF (SAMEQ(Q30,JBUF)) THEN
                  ZIPS=.TRUE. 
                  IPSKOD=4
              ELSE IF (SAMEQ(Q15,JBUF)) THEN
                  ZIPS=.TRUE. 
                  IPSKOD=3
              ELSE IF (SAMEQ(Q8,JBUF)) THEN 
                  ZIPS=.TRUE. 
                  IPSKOD=2
              ELSE
                  KERR=-7 
                  RETURN
              ENDIF 
          ELSE
C             End of command string...syntax OK.
C             Logical sieve to catch combinatoric errors. 
C             Direct conflicts. 
              ZERR=ZREV.AND.ZFOR .OR. ZLTON.AND.ZLTOF 
     .             .OR. ZTMON.AND.ZTMOF 
C             Can't go FAST and also set IPS value. 
              ZERR=ZERR .OR. ZFA.AND.ZIPS 
C             RECord not allowed under certain circumstances. 
              ZNOREC=ZTMON .OR. ZST .OR. ZLO .OR. ZFA .OR. ZIPS 
              ZERR=ZERR .OR. ZREC.AND.ZNOREC
C             No motion allowed when STopping or LOading. 
              ZERR=ZERR .OR. (ZST .OR. ZLO).AND.
     .                       (ZIPS.OR.ZREV.OR.ZFOR.OR.ZREC.OR.ZTMON)
C             Can't STop and LOad in the same command.
              ZERR=ZERR .OR. ZST.AND.ZLO
C             Can start recording only when FOrward or REVerse are pushed.  
              ZERR=ZERR .OR. ZREC.AND. .NOT.(ZFOR .OR. ZREV)
              IF (ZERR) THEN
                  KERR=-7 
              ELSE
C                 Turn off tape mode on abrupt speed changes. 
C                 That is to say, use ramp generator as the reference.
                  IF (ZIPS .OR.ZFA .OR.ZLO .OR.ZST) THEN
                      CALL I4PUT (27,27,KOMMND(3,INDEX),0J)     
                      CALL I4PUT (30,30,KOMMND(3,INDEX),0J)     
                  ENDIF 
C                 Turn off existent RECord condition if so indicated. 
                  IF (ZNOREC) CALL I4PUT (31,31,KOMMND(2,INDEX),0J) 
                  IF (ZREV  ) CALL I4PUT (31,31,KOMMND(4,INDEX),0J) 
                  IF (ZFOR  ) CALL I4PUT (31,31,KOMMND(4,INDEX),1J) 
C                 Simulated FAst button, IPS=240 and RG=960 kHz.
                  IF (ZFA   ) CALL I4PUT (30,16,KOMMND(4,INDEX),774540B)
                  IF (ZLO   ) CALL I4PUT (30,28,KOMMND(4,INDEX),1J) 
                  IF (ZST   ) CALL I4PUT (30,28,KOMMND(4,INDEX),0J) 
                  IF (ZREC  ) CALL I4PUT (31,31,KOMMND(2,INDEX),1J) 
                  IF (ZLTON ) CALL I4PUT (31,31,KOMMND(3,INDEX),1J) 
                  IF (ZLTOF ) CALL I4PUT (31,31,KOMMND(3,INDEX),0J) 
C                 Insert bits for Quasi-Tape mode and REF/RAMP. 
                  IF (ZTMON ) THEN
                      CALL I4PUT (27,27,KOMMND(3,INDEX),1J) !ref=RG 
                      CALL I4PUT (30,30,KOMMND(3,INDEX),1J) !QT=on
                  ELSE IF (ZTMOF) THEN
                      CALL I4PUT (30,30,KOMMND(3,INDEX),0J) !ref=RAMP 
                      CALL I4PUT (30,30,KOMMND(3,INDEX),0J) !QT=off 
                  ENDIF 
C                 Change of IPS no longer resets RG=720.
                  IF (ZIPS  ) CALL I4PUT (30,28,KOMMND(4,INDEX),IPSKOD) 
C                 IF (ZIPS  ) CALL I4PUT (30,16,KOMMND(4,INDEX),
C    .                                          ISHFT(IPSKOD,12)+3440B) 
C                 Command table updated, now issue commands.
                  KERR=0
                  IF (ZLTON.OR.ZLTOF.OR.ZTMON.OR.ZTMOF) 
     .                CALL TAPOT (INDEX,3,KERR) 
                  IF ((ZFA .OR.ZLO .OR.ZST .OR.ZFOR .OR.ZREV .OR.ZIPS)
     .               .AND. KERR.GE.0) CALL TAPOT (INDEX,4,KERR) 
                  IF (KERR.GE.0 .AND. (ZREC .OR. ZNOREC)) 
     .               CALL TAPOT (INDEX,2,KERR)
              ENDIF 
              RETURN
          ENDIF 
 50       CONTINUE
      END 
C     Subroutine TAPEN - enables selected tracks   RJC 12/80
      SUBROUTINE TAPEN (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      LOGICAL SAMEQ 
      INTEGER*2 MAPTRK(28),JBUF(3),QALL(3),QGP1(3),QGP2(3),QGP3(3), 
     .          QGP4(3),QEN(2),IBUF(1)
      DATA MAPTRK/0,8,1,9,2,10,3,11,4,12,5,13,6,14,16,24,17,25,18,26, 
     .            19,27,20,28,21,29,22,30/, 
     .            QALL/3,'ALL'/,QGP1/3,'GP1'/,QGP2/3,'GP2'/,
     .            QGP3/3,'GP3'/,QGP4/3,'GP4'/,QEN/2,'EN'/ 
C 
C     Reset all tracks to the disabled condition. 
      CALL I4PUT (30, 0, KOMMND(2,INDEX), 0J) 
      ISTRC=4 
C     Loop over all possible fields.
      DO 30 I=1,34
          IF (ISTRC .GT. IBUF(1)) THEN
C             End of command string.
              CALL TAPOT (INDEX,2,KERR) 
              RETURN
          ENDIF 
          CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,2H ,) 
C         Figure out what this subfield is. 
          IF (SAMEQ (JBUF,QALL)) THEN 
              CALL I4PUT (30,0,KOMMND(2,INDEX), -1J)
          ELSE IF (SAMEQ (JBUF,QGP1)) THEN
              CALL I4PUT (6,0,KOMMND(2,INDEX), -1J) 
          ELSE IF (SAMEQ (JBUF,QGP2)) THEN
              CALL I4PUT (14,8,KOMMND(2,INDEX), -1J)
          ELSE IF (SAMEQ (JBUF,QGP3)) THEN
              CALL I4PUT (22,16,KOMMND(2,INDEX), -1J) 
          ELSE IF (SAMEQ (JBUF,QGP4)) THEN
              CALL I4PUT (30,24,KOMMND(2,INDEX), -1J) 
          ELSE
              JSTRC=1 
              ITRK=KVALQ (JBUF,IERR,JSTRC)
              IF (IERR.EQ.1 .OR. ITRK.LT.1 .OR. ITRK.GT.28) THEN
                  KERR=-7 
                  RETURN
              ENDIF 
C             OK specification of a single track #. 
              CALL I4PUT (MAPTRK(ITRK),MAPTRK(ITRK),KOMMND(2,INDEX),1J) 
          ENDIF 
 30       CONTINUE
C 
      END 
C     Subroutine TAPAQ - setup for acquisition mode  RJC 12/80
      SUBROUTINE TAPAQ (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 JBUF(3),QNOR(3),QBYP(3),Q0(2) 
      INTEGER*4 IDIG
      LOGICAL SAMEQ 
      DATA KOMMA/2H ,/,QNOR/3,'NOR'/,QBYP/3,'BYP'/,Q0/1,'0'/
C     Parse for mode descriptor.
      ISTRC=4 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,KOMMA)
C 
      IF (SAMEQ (JBUF,QNOR)) THEN 
C         Normal mode...get selected decoder tracks.
          DO 20 I=1,2 
              CALL IPRSQ (IBUF,JBUF,3,ISTRC,2,KOMMA)
              IF (JBUF(1) .GT.2) THEN 
                  KERR=-7 
                  RETURN
              ENDIF 
C             If only one character, pad with leading zero. 
              IF (JBUF(1) .EQ.1) CALL MERGQ (JBUF,Q0,JBUF)
              IF (JBUF(1) .EQ.2) THEN 
                  DO 10 J=1,2 
                      IDIG=IGETQ(JBUF,J)
                      IF (IDIG.LT.48 .OR. IDIG.GT.57
     .                    .OR. J.EQ.1 .AND. IDIG.GT.50) THEN
                          KERR=-7 
                          RETURN
                      ENDIF 
                      IBIT= 8*I -4*J
 10                   CALL I4PUT (IBIT+3, IBIT, KOMMND(1,INDEX), IDIG)
              ENDIF 
C             On null string, nothing is done.
 20           CONTINUE
C         Reset bypass-mode flag. 
          CALL I4PUT (25,25, KOMMND(1,INDEX), 0J) 
C 
      ELSE IF (SAMEQ(JBUF,QBYP)) THEN 
          CALL I4PUT (25,25, KOMMND(1,INDEX), 1J) 
      ELSE
          KERR=-7 
          RETURN
      ENDIF 
C 
      CALL TAPOT (INDEX,1,KERR) 
      RETURN
      END 
C 
C     Subroutine TAPDI -generates strobe word for tape display. RJC 12/80 
      SUBROUTINE TAPDI(INDEX,IBUF,KERR) 
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 IBUF(1),JBUF(4),QFO(2),QFRS(3),QSP(2),QVA(2)
      INTEGER*4 IDIG
      LOGICAL SAMEQ 
      DATA QFO/2,'FO'/,QFRS/3,'FRS'/,QSP/2,'SP'/,QVA/2,'VA'/
C     Parse for option. 
      ISTRC=4 
      CALL IPRSQ(IBUF,JBUF,4,ISTRC,0,2H ,)
C 
      IF (SAMEQ(JBUF,QFO)) THEN 
          CALL I4PUT (25,20,KOMMND(3,INDEX),0J) 
C 
      ELSE IF (SAMEQ(JBUF,QSP)) THEN
          CALL I4PUT (25,20,KOMMND(3,INDEX),17J)
C 
      ELSE IF (SAMEQ(JBUF,QFRS)) THEN 
          CALL I4PUT (22,22,KOMMND(3,INDEX),1J) 
C 
      ELSE IF (.NOT.SAMEQ(JBUF,QVA)) THEN 
C         Not one of the allowable options, flag syntax error.
          KERR=-7 
          RETURN
C 
      ELSE
C         Value for display, validate it & stuff KOMMND.
          CALL IPRSQ (IBUF,JBUF,5,ISTRC,0,2H ,) 
          IF (JBUF(1).LE.0 .OR. JBUF(1).GT.5) THEN
              KERR=-7 
              RETURN
          ENDIF 
          CALL I4PUT (25,20,KSTATE(3,INDEX),51J)
          IF (JBUF(1) .EQ.5) THEN 
C             Fifth (half) digit requires special handling. 
              IDIG=IGETQ(JBUF,1) -48
              IF (IDIG.LT.0 .OR. IDIG.GT.1) THEN
                  KERR=-7 
                  RETURN
              ENDIF 
              CALL DLETQ (JBUF,1,1) 
          ELSE
              IDIG=0
          ENDIF 
          CALL I4PUT (16,16,KOMMND(3,INDEX),IDIG) 
C         Check and insert each of (at most) 4 remaining digits.
          DO 20 I=1,4 
              J=I+JBUF(1)-4 
              IF (J .LE. 0) THEN
                  IDIG=0
              ELSE
                  IDIG=IGETQ(JBUF,J)
                  IF (IDIG.GE.48 .AND. IDIG.LE.57) THEN 
C                     Process a decimal digit (0-9).
                      IDIG=IDIG-48
                  ELSE IF (IDIG.GE.65 .AND. IDIG.LE.70) THEN
C                     Hex digit (A-F).
                      IDIG=IDIG-55
                  ELSE
                      KERR=-7 
                      RETURN
                  ENDIF 
              ENDIF 
              CALL I4PUT (19-4*I,16-4*I,KOMMND(3,INDEX),IDIG) 
 20           CONTINUE
      ENDIF 
C     Send command to ASCII transceiver.
      CALL TAPOT (INDEX,3,KERR) 
C     Turn off footage counter reset bit (non-repeating command). 
      CALL I4PUT (22,22,KOMMND(3,INDEX),0J) 
      RETURN
      END 
C     Subroutine TAPRP -makes track selections for reproduce mode. RJC 1/81 
      SUBROUTINE TAPRP (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 QPAR(3),QCOM(3),QBYP(3),JBUF(3),KBUF(3),ITRAK(4), 
     .          IOD(4),IEV(2),IGP(4)
      INTEGER*4 IDIG,ITRKOD 
      LOGICAL SAMEQ,EVEN
      EQUIVALENCE (IOD(3),IEV(1)) 
      DATA QPAR/3,'PAR'/,QCOM/3,'COM'/,QBYP/3,'BYP'/,KOMMA/2H ,/
C     Statement functions 
      EVEN(N)=MOD(N,2) .EQ. 0 
      ITRKOD(N)= (N-1)/2+N/15 
C 
C     Parse for mode descriptor.
      ISTRC=4 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,KOMMA)
C     Decode track numbers. 
      DO 10 I=1,4 
          CALL IPRSQ (IBUF,KBUF,4,ISTRC,2,KOMMA)
          IF (KBUF(1) .EQ.0) THEN 
              ITRAK(I)=0
          ELSE
              KSTRC=1 
              ITRAK(I)=KVALQ(KBUF,IERR,KSTRC) 
              IF (ITRAK(I).LE.0 .OR. ITRAK(I).GT.28) THEN 
                  KERR=-7 
                  RETURN
              ENDIF 
C             Make sure only digits are present.
              DO 5 J=1,KBUF(1)
                  IJ=IGETQ(KBUF,J)
                  IF (IJ.LT.48 .OR. IJ.GT.57) THEN
                      KERR=-7 
                      RETURN
                  ENDIF 
  5               CONTINUE
          ENDIF 
 10       CONTINUE
C 
      IF (SAMEQ(JBUF,QPAR)) THEN
C         Parallel mode, get decoder assignments. 
          DO 20 I=1,2 
              IF (ITRAK(I) .NE.0) THEN
                  IF (EVEN(ITRAK(I))) THEN
C                     Set GP1/2 =EV1/2; EV1/2 to correct track. 
                      CALL I4PUT (8*I-3,8*I-4,KOMMND(7,INDEX),I+0J) 
                      CALL I4PUT (4*I+7,4*I+4,KOMMND(5,INDEX),
     .                                               ITRKOD(ITRAK(I)))
                  ELSE
C                     Set GPs to ODs; set ODs to tracks.
                      CALL I4PUT (8*I-3,8*I-4,KOMMND(7,INDEX),3*I-3J) 
                      CALL I4PUT (4*I-1,4*I-4,KOMMND(5,INDEX),
     .                                               ITRKOD(ITRAK(I)))
                  ENDIF 
              ENDIF 
 20           CONTINUE
C         Set ASEL/BSEL to GP1/GP2. 
          CALL I4PUT (3,0,KOMMND(7,INDEX),7J) 
          CALL I4PUT (11,8,KOMMND(7,INDEX),7J)
C         Clear COMMON and BYPASS flags.
          CALL I4PUT (25,24,KOMMND(5,INDEX),0J) 
      ELSE IF (SAMEQ(JBUF,QCOM) .OR. SAMEQ(JBUF,QBYP)) THEN 
C         Set COMMON mode flag and possibly BYPASS as well. 
          IDIG=1
          IF (SAMEQ(JBUF,QBYP)) IDIG=3
          CALL I4PUT (25,24,KOMMND(5,INDEX),IDIG) 
          NOD=0 
          NEV=0 
C         Setup group and track assignments from each of four fields. 
          DO 40 I=1,4 
              IF (ITRAK(I) .GT.0) THEN
                  IF (EVEN(ITRAK(I))) THEN
                      IF (NEV.EQ.0) THEN
                          NEV=1 
                          IEV(1)=ITRAK(I) 
                          IGP(I)=1
                      ELSE
                          IGP(I)=-1 
                          DO 30 J=1,NEV 
  30                          IF (ITRAK(I) .EQ. IEV(J)) IGP(I)=2*J-1
                          IF (IGP(I) .EQ. -1) THEN
C                             Track not allocated, must do so.
                              IF (NEV .EQ.2) THEN 
C                                 Too many (>2)..abort. 
                                  KERR=-7 
                                  RETURN
                              ENDIF 
                              NEV=2 
                              IEV(2)=ITRAK(I) 
                              IGP(I)=3
                          ENDIF 
                      ENDIF 
                  ELSE
C                     Odd bookkeeping.
                      IF (NOD.EQ.0) THEN
                          NOD=1 
                          IOD(1)=ITRAK(I) 
                          IGP(I)=0
                      ELSE
                          IGP(I)=-1 
                          DO 35 J=1,NOD 
  35                          IF (ITRAK(I) .EQ. IOD(J)) IGP(I)=2*J-2
                          IF (IGP(I) .EQ. -1) THEN
C                             Track not allocated, must do so.
                              IF (NOD .EQ.2) THEN 
C                                 Too many (>2)..abort. 
                                  KERR=-7 
                                  RETURN
                              ENDIF 
                              NOD=2 
                              IOD(2)=ITRAK(I) 
                              IGP(I)=2
                          ENDIF 
                      ENDIF 
                  ENDIF 
              ENDIF 
 40           CONTINUE
C         Set unused OD1 and OD2 to track 1, EV1 and EV2 to track 2.
          IF (NOD.EQ.2) THEN
C             Select GP default to be EV2.
              JTRAK=3 
          ELSE
C             GP default will be OD2. 
              JTRAK=2 
              IOD(2)=1
              IF (NOD.EQ.0) IOD(1)=1
          ENDIF 
C 
          IF (NEV.LT.2) THEN
              IEV(2)=2
              IF (NEV.EQ.0) IEV(1)=2
          ENDIF 
C         Plug strobe tables. 
          DO 60 I=1,4 
              CALL I4PUT (4*I-1,4*I-4,KOMMND(5,INDEX),ITRKOD(IOD(I))) 
C             Time to plug in defaults. 
              IF (ITRAK(I) .EQ.0) IGP(I)=JTRAK
              IF (EVEN(I)) THEN 
C                 GP2 & 4 codes are odd-even reversed from GP1 & 3. 
                  IDIG=IXOR (IGP(I),1)
                  CALL I4PUT (I+11,I+10,KOMMND(7,INDEX),IDIG) 
              ELSE
                  IDIG=IGP(I) 
                  CALL I4PUT (I+4,I+3,KOMMND(7,INDEX),IDIG) 
              ENDIF 
 60           CONTINUE
      ELSE
          KERR=-7 
          RETURN
      ENDIF 
C 
      CALL TAPOT (INDEX,5,KERR) 
      IF (KERR .GE.0) CALL TAPOT (INDEX,7,KERR) 
      RETURN
      END 
C     Subroutine TAPBS -sets decoders A+B for specific bit syncs.   RJC 5/83
      SUBROUTINE TAPBS (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 IBUF(1),JBUF(2) 
      INTEGER*4 KODER(2)
C     Parse for decoders. 
      ISTRC=4 
      DO 10 I=1,2 
          CALL IPRSQ(IBUF,JBUF,2,ISTRC,0,2H ,)
          KODER(I)=IGETQ(JBUF,1)-48 
          IF(KODER(I).GE.17 .AND.KODER(I).LE.22 .AND.JBUF(1).EQ.1)THEN
              KODER(I)=KODER(I)-7  !translate 0-F hex 
          ELSE IF (KODER(I).LT.0 .OR.KODER(I).GT.9 .OR.JBUF(1).NE.1)THEN
              KERR=-7  !neither 0-9 or A-F
              RETURN
          ENDIF 
 10       CONTINUE
C     Decoder specifications OK, now insert & issue command.
      CALL I4PUT ( 3,0,KOMMND(7,INDEX),KODER(1))
      CALL I4PUT (11,8,KOMMND(7,INDEX),KODER(2))
      CALL TAPOT (INDEX,7,KERR) 
      RETURN
      END 
C     Subroutine TAPTE -issues commands for test pattern generator. RJC 1/81
      SUBROUTINE TAPTE (INDEX,IBUF,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 JBUF(3),QON(2),QOF(2),QFOR(3),QREV(3) 
      INTEGER*4 I4
      LOGICAL SAMEQ 
      DATA QON/2,'ON'/,QOF/2,'OF'/,QFOR/3,'FOR'/,QREV/3,'REV'/, 
     .     KOMMA/2H ,/
C     Parse ON/OFf field. 
      ISTRC=4 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (SAMEQ (JBUF,QOF)) THEN
          I4=0
      ELSE IF (SAMEQ (JBUF,QON) .OR. JBUF(1) .EQ.0) THEN
C         Default is ON.
          I4=1
      ELSE
          KERR=-7 
          RETURN
      ENDIF 
      CALL I4PUT (31,31,KOMMND(6,INDEX),I4) 
C     Parse clock source field. 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .EQ.0) THEN 
          I4=0
      ELSE
          I4=IGETQ(JBUF,1)-48 
          IF (JBUF(1).NE.1 .OR. I4.LT.0 .OR. I4.GT.1) THEN
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (23,23, KOMMND(6,INDEX), I4) 
C     Parse low (0-13) tracks pattern.
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .EQ.0) THEN 
          I4=0
      ELSE
          I4=IGETQ(JBUF,1)-48 
          IF (JBUF(1).NE.1 .OR. I4.LT.0 .OR. I4.GT.3) THEN
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (25,24, KOMMND(6,INDEX), I4) 
C     Parse high (14-27) tracks pattern.
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .EQ.0) THEN 
          I4=0
      ELSE
          I4=IGETQ(JBUF,1)-48 
          IF (JBUF(1).NE.1 .OR. I4.LT.0 .OR. I4.GT.3) THEN
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (27,26, KOMMND(6,INDEX), I4) 
C     Parse pattern direction.
      CALL IPRSQ(IBUF,JBUF,4,ISTRC,2,KOMMA) 
      IF (JBUF(1).EQ.0 .OR. SAMEQ(JBUF,QFOR)) THEN
C         Default is forward. 
          I4=0
      ELSE IF (SAMEQ(JBUF,QREV)) THEN 
          I4=1
      ELSE
          KERR=-7 
          RETURN
      ENDIF 
      CALL I4PUT (22,22, KOMMND(6,INDEX), I4) 
C     Parse error insert field. 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .EQ.0) THEN 
          I4=0
      ELSE
          I4=IGETQ(JBUF,1)-48 
          IF (JBUF(1).NE.1 .OR. I4.LT.0 .OR. I4.GT.1) THEN
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (21,21, KOMMND(6,INDEX), I4) 
C     Parse error select field. 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,2,KOMMA)
      IF (JBUF(1) .EQ.0) THEN 
          I4=0
      ELSE
          I4=IGETQ(JBUF,1)-48 
          IF (JBUF(1).NE.1 .OR. I4.LT.0 .OR. I4.GT.3) THEN
              KERR=-7 
              RETURN
          ENDIF 
      ENDIF 
      CALL I4PUT (29,28, KOMMND(6,INDEX), I4) 
C 
      CALL TAPOT (INDEX,6,KERR) 
      RETURN
      END 
C     Subroutine TAPST- display transport status.  RJC 2/81 
      SUBROUTINE TAPST (LUOP,INDEX,IBUF,IPAR,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      LOGICAL SAMEQ,LALL,FIRST,OK 
      INTEGER*2 IPAR(5),QALL(3),JBUF(3),IBCODE(15),I45(0:3),MAPTRK(28), 
     .          IOFON(2),I12MAP(0:3)
      INTEGER*4 I4GET,IFIELD,IFOREV(2),LMOVE(8),INOBYP(0:1) 
      REAL*6    REMLOC(0:1),ALARM(0:1),BWCOD,OVFL(2)
      DATA IBCODE /5*0,300,2*0,1200,0,2400,0,4800,0,9600/,  
     .     REMLOC /'REMOTE','LOCAL'/,ALARM/' ',',ALARM'/, 
     .     I45 /'FOSP  VA'/,IFIELD/',4,4'/,BWCOD/'EQH124'/, 
     .     IOFON/'OFON'/,IFOREV/'FOR REV '/,OVFL/'      ',',OVFL'/, 
     .     LMOVE /'STOP','LOAD','8','15','30','60','120','240'/,
     .     MAPTRK/0,8,1,9,2,10,3,11,4,12,5,13,6,14,16,24,17,25,18,26, 
     .            19,27,20,28,21,29,22,30/, 
     .     I12MAP/0,8,4,12/,QALL/3,'ALL'/,INOBYP/'NOR,BYP,'/
C     Parse command for which status is desired.
      ISTRC=4 
      CALL IPRSQ (IBUF,JBUF,4,ISTRC,0,2H ,) 
      ICOM=JBUF(2)
      LALL=SAMEQ (JBUF,QALL)
      IF (.NOT.LALL .AND. JBUF(1) .NE.2) THEN 
          KERR=-7 
          RETURN
      ENDIF 
      OK=.FALSE.
C 
C         D E 
      IF (ICOM.EQ. 2HDE  .OR. LALL) THEN
          OK=.TRUE. 
          CALL TAPIN (INDEX,1,KERR) 
          IF (KERR .LT.0) RETURN
          ILOCL=I4GET (31,31,KSTATE(1,INDEX)) 
          IALRM=I4GET (30,30,KSTATE(1,INDEX)) 
          IPAR(2)=IDEVTB(2,INDEX) 
          IPAR(3)=IDEVTB(3,INDEX) 
          IPAR(4)=IBCODE(IDEVTB(4,INDEX)) 
          IPAR(5)=IDEVTB(5,INDEX) 
          WRITE(LUOP,11) (IPAR(I),I=2,5),REMLOC(ILOCL),ALARM(IALRM) 
 11       FORMAT ("DE=",A2,1H,,I2,1H,,I4,1H,,I1,1H,,2A6)
      ENDIF 
C 
C         A Q 
      IF (ICOM.EQ. 2HAQ  .OR. LALL) THEN
          OK=.TRUE. 
          CALL TAPIN (INDEX,1,KERR) 
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET (31,16,KSTATE(1,INDEX)) 
          IPAR(3)=I4GET (15,0,KSTATE(1,INDEX))  
          IA=10*I4GET( 5, 4,KSTATE(1,INDEX))+I4GET( 3,0,KSTATE(1,INDEX))
          IB=10*I4GET(13,12,KSTATE(1,INDEX))+I4GET(11,8,KSTATE(1,INDEX))
          WRITE (LUOP,'("AQ=",A4,I2,",",I2)') 
     .          INOBYP(I4GET(25,25,KSTATE(1,INDEX))),IA,IB
      ENDIF 
C 
C         D I 
      IF (ICOM.EQ. 2HDI  .OR. LALL) THEN
          OK=.TRUE. 
          CALL TAPIN (INDEX,3,KERR) 
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(3,0,KSTATE(3,INDEX))
     .            +10*(I4GET(7,4,KSTATE(3,INDEX)) 
     .            +10*(I4GET(11,8,KSTATE(3,INDEX))
     .            +10*(I4GET(15,12,KSTATE(3,INDEX)) 
     .            +10*I4GET(16,16,KSTATE(3,INDEX))))) 
          IPAR(3)=I4GET(31,16,KSTATE(3,INDEX))
          K=I4GET(21,20,KSTATE(3,INDEX))
          WRITE(LUOP,'("DI=",A2,":",I5)') I45(K),IPAR(2)
      ENDIF 
C 
C         E N 
      IF (ICOM.EQ. 2HEN  .OR. LALL) THEN
          OK=.TRUE. 
          CALL TAPIN (INDEX,2,KERR) 
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(31,16,KSTATE(2,INDEX))
          IPAR(3)=I4GET(15, 0,KSTATE(2,INDEX))
          FIRST=.TRUE.
          WRITE (LUOP,'("EN=_")') 
C         Loop over tracks. 
          DO 20 I=1,28
              IF (I4GET(MAPTRK(I),MAPTRK(I),KSTATE(2,INDEX)) .EQ.1) THEN
                  IF (FIRST) THEN 
                      WRITE (LUOP,'(I2,1H_)') I 
                      FIRST=.FALSE. 
                  ELSE
                      WRITE (LUOP,'(",",I2,1H_)') I 
                  ENDIF 
              ENDIF 
 20           CONTINUE
          WRITE (LUOP,'(1X)') 
      ENDIF 
C 
C         R P 
      IF (ICOM.EQ. 2HRP .OR. LALL) THEN 
          OK=.TRUE. 
          CALL TAPIN (INDEX,5,KERR) 
          IF (KERR.EQ.0) CALL TAPIN (INDEX,7,KERR)
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(31,16,KSTATE(5,INDEX))
          IPAR(3)=I4GET(15, 0,KSTATE(5,INDEX))
          IPAR(4)=I4GET(15, 0,KSTATE(7,INDEX))
          MODE=I4GET(24,24,KSTATE(5,INDEX)) 
          IF (MODE.EQ.0) THEN 
              WRITE (LUOP,'("RP=PAR_")')
          ELSE
              WRITE (LUOP,'("RP=COM_")')
          ENDIF 
          IF (I4GET(25,25,KSTATE(5,INDEX)) .EQ.1) 
     .        WRITE (LUOP,'(",BYP_")')
C         Decode track #s for each sub-group. 
          DO 30 I=1,2*(MODE+1)
              J=I-7*MOD(I,2)+10 
              K=I4GET(J+1,J,KSTATE(7,INDEX))
C             Flip odd-even code for even group.
              IEVOD=IXOR(K,1-MOD(I,2))
C             Now change 0-3:OD1/EV1/OD2/EV2 to 0,4,8,12:OD1/OD2/EV1/EV2
              J=I12MAP(IEVOD) 
              K=I4GET(J+3,J,KSTATE(5,INDEX))
              ITRK=2*(K-K/8)+1+J/8
 30           WRITE (LUOP,'(",",I2,"_")') ITRK
          WRITE (LUOP,'(1X)') 
      ENDIF 
C 
C         B S 
      IF (ICOM.EQ. 2HBS .OR. LALL) THEN 
          OK=.TRUE. 
          CALL TAPIN (INDEX,7,KERR) 
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(15,0,KSTATE(7,INDEX)) 
          ICHA=I4GET(3,0,KSTATE(7,INDEX))+48
          IF (ICHA .GE. 58) ICHA=ICHA+7 
          ICHB=I4GET(11,8,KSTATE(7,INDEX))+48 
          IF (ICHB .GE. 58) ICHB=ICHB+7 
          WRITE(LUOP,'("BS=",A1,1H,,A1)')ISHFT(ICHA,8),ISHFT(ICHB,8)
      ENDIF 
C 
C         R G 
      IF (ICOM.EQ. 2HRG .OR. LALL) THEN 
          OK=.TRUE. 
          CALL TAPIN (INDEX,4,KERR) 
          IF (KERR.EQ.0) CALL TAPIN (INDEX,5,KERR)
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(31,16,KSTATE(4,INDEX))
          IPAR(3)=I4GET(15, 0,KSTATE(4,INDEX))
          IPAR(4)=I4GET(31,16,KSTATE(5,INDEX))
          ITIMER=I4GET(3,0,KSTATE(4,INDEX)) 
     .           +10*(I4GET(7,4,KSTATE(4,INDEX))
     .           +10*(I4GET(11,8,KSTATE(4,INDEX)) 
     .           +10*I4GET(15,12,KSTATE(4,INDEX)))) 
          IRATE=I4GET(19,16,KSTATE(4,INDEX))
     .          +10*(I4GET(23,20,KSTATE(4,INDEX)) 
     .          +10*I4GET(27,24,KSTATE(4,INDEX))) 
          IBW=I4GET(18,16,KSTATE(5,INDEX))
          IF (I4GET(19,19,KSTATE(5,INDEX)) .EQ.1) THEN
              IEQS=IBW-1
          ELSE
              IEQS=I4GET(22,20,KSTATE(5,INDEX)) 
          ENDIF 
          CALL CMOVE (BWCOD,IBW-1,IFIELD,2,1) 
          CALL CMOVE (BWCOD,IEQS,IFIELD,4,1)
          WRITE (LUOP,'("RG=",I3,1H,,I4,A4)') IRATE,ITIMER,IFIELD 
      ENDIF 
C 
C         T E 
      IF (ICOM.EQ. 2HTE .OR. LALL) THEN 
          OK=.TRUE. 
          CALL TAPIN (INDEX,6,KERR) 
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(31,16,KSTATE(6,INDEX))
          IPAR(3)=I4GET(15, 0,KSTATE(6,INDEX))
          WRITE (LUOP,39) IOFON (I4GET(31,31,KSTATE(6,INDEX))+1), 
     .                           I4GET(23,23,KSTATE(6,INDEX)),
     .                           I4GET(25,24,KSTATE(6,INDEX)),
     .                           I4GET(27,26,KSTATE(6,INDEX)),
     .                    IFOREV(I4GET(22,22,KSTATE(6,INDEX))+1), 
     .                           I4GET(21,21,KSTATE(6,INDEX)),
     .                           I4GET(29,28,KSTATE(6,INDEX)),
     .                           I4GET(19, 0,KSTATE(6,INDEX)),
     .                    OVFL ( I4GET(20,20,KSTATE(6,INDEX))+1)
 39       FORMAT ("TE=",A2,1H,,3(I1,1H,),A3,2(1H,,I1),1H:,I7,A5)
      ENDIF 
C 
C         T M 
      IF (ICOM.EQ. 2HTM .OR. LALL) THEN 
          OK=.TRUE. 
          CALL TAPIN (INDEX,2,KERR) 
          IF (KERR.EQ.0) CALL TAPIN (INDEX,3,KERR)
          IF (KERR.EQ.0) CALL TAPIN (INDEX,4,KERR)
          IF (KERR.LT.0) RETURN 
          IPAR(2)=I4GET(31,16,KSTATE(3,INDEX))
          IPAR(3)=I4GET(31,16,KSTATE(4,INDEX))
          IPAR(4)=I4GET(31,16,KSTATE(2,INDEX))
          IPAR(5)=I4GET(15,00,KSTATE(4,INDEX))  !RG timer value 
          IF (LUOP .NE. 64) THEN   !really print it 
              IF (I4GET(23,23,KSTATE(3,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("TM=NOTREADY,_")')
              ELSE
                  WRITE (LUOP,'("TM=READY,_")') 
              ENDIF 
              IF (I4GET(30,30,KSTATE(3,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("TMLOCK,_")') 
              ELSE
                  WRITE (LUOP,'("NOTMLOCK,_")') 
              ENDIF 
              IF (I4GET(31,31,KSTATE(3,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("LOWTAPE,_")')
              ELSE
                  WRITE (LUOP,'("NOLOWTAPE,_")')
              ENDIF 
              IF (I4GET(29,29,KSTATE(3,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("MOVING,_")') 
              ELSE
                  WRITE (LUOP,'("NOTMOVING,_")')
              ENDIF 
              IF (I4GET(31,31,KSTATE(2,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("RECORD,_")') 
              ELSE
                  WRITE (LUOP,'("NORECORD,_")') 
              ENDIF 
              IF (I4GET(31,31,KSTATE(4,INDEX)) .EQ.1) THEN
                  WRITE (LUOP,'("FOR,_")')
              ELSE
                  WRITE (LUOP,'("REV,_")')
              ENDIF 
              IPS=I4GET(30,28,KSTATE(4,INDEX))
              WRITE (LUOP,'(A4)') LMOVE(IPS+1)
          ENDIF 
      ENDIF 
C 
      IF (.NOT.OK) KERR=-7
      RETURN
      END 
C     Subroutine TAPAS -sends an arbitrary ASCII string.  RJC 2/81
      SUBROUTINE TAPAS (LUOP,INDEX,IBUF,KERR) 
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 ITRAN(40),IRECV(20),IBUF(1) 
      LOGICAL FALSE,KECHO 
      DATA ITRAN/'#nn='/,FALSE/.FALSE./ 
C 
      KECHO=LUEK.NE.0 
C     MAT address 
      CALL CMOVE (IDEVTB(2,INDEX),1,ITRAN,2,2)
C     Command.
      CALL CMOVE (IBUF,6,ITRAN,5,IBUF(1)-3) 
      CALL DATAT (IDEVTB(5,INDEX),ITRAN,IBUF(1)+1,IDEVTB(3,INDEX),
     .          0,KECHO,LUEK,FALSE,IRECV,NRC,KERR)
      IF (KERR.GE.0) THEN 
          WRITE (LUOP,'(40A2)') (IRECV(I),I=1,(NRC+1)/2)
C         Return string to father.
          CALL EXEC (14,2,IRECV,-NRC) 
      ENDIF 
      RETURN
      END 
C     Subroutine TAPRA -resets alarm.  RJC 2/81 
      SUBROUTINE TAPRA (INDEX,KERR) 
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      LOGICAL FALSE,KECHO 
      INTEGER*2 ITRAN(3),IRECV(3) 
      DATA ITRAN/6H#nn"  /,FALSE/.FALSE./ 
C 
      KECHO=LUEK.NE.0 
C     Must bypass TAPOT, which checks alarm.
      CALL CMOVE (IDEVTB(2,INDEX),1,ITRAN,2,2)
      CALL DATAT (IDEVTB(5,INDEX),ITRAN,4,IDEVTB(3,INDEX),0,KECHO,
     .          LUEK,FALSE,IRECV,NRC,KERR)  
      RETURN
      END 
FTN4X 
C     Subroutine TAPQM -gives help from "VHELP file.  RJC 2/81  
      SUBROUTINE TAPQM (LUOP,IBUF,KERR) 
     .,VTAPE subroutine 
      INTEGER*2 IBUF(1),KODES(18) 
      DATA KODES /2HDE,2HAQ,2HDI,2HEN,2HRP,2HBS,2HRG,2HTE,2HTM,2HRA,
     .            2HAS,2HEK,2HOF,2HME,2H??,2HST,2HER,0/ 
C 
      KERR=0
      IF (IBUF(1) .EQ.2) THEN 
          WRITE (LUOP,'("Commands:"/"AQ - acquisition mode"/
     .          "AS - ASCII string"/"DE - define tape"/"DI - display"/
     .          "EN - enable tracks"/"RA - reset alarm"/
     .          "RG - rate generator"/"RP - reproduce mode"/
     .          "TE - test"/"TM - tape motion"/ 
     .          "ER - explain error codes"/"EK - enable echo"/
     .          "OF - disable echo"/"ME - display memory"/
     .          "??,XX - extra help for command XX")')
          RETURN
      ELSE IF (IBUF(1) .NE.5) THEN
          KERR=-7 
          RETURN
      ENDIF 
C 
      CALL CMOVE (IBUF,6,INPUT,1,2) 
      DO 10 I=1,32767 
          IF (KODES(I) .EQ. INPUT) THEN 
              CALL HLPEM (I,0,LUOP) 
              RETURN
          ELSE IF (KODES(I) .EQ. 0) THEN
              WRITE (LUOP,'("No help available for ",A2)') INPUT
              RETURN
          ENDIF 
 10       CONTINUE
      END 
FTN4X 
C     Subroutine TAPEK - turns on echo feature and sets its LU.  RJC 7/82 
      SUBROUTINE TAPEK (IBUF,LUOP,LUEK,KERR)
     .,VTAPE subroutine 
      INTEGER*2 IBUF(1) 
C 
      KERR=0
      ISTRC=4 
      LUEK=KVALQ (IBUF,IERR,ISTRC)
C     Null LU defaults to operator terminal.  
      IF (IERR .EQ.1) THEN
          IF (IBUF(1) .EQ.2) THEN 
              LUEK=LUOP 
          ELSE
              KERR=-7 
          ENDIF 
      ENDIF 
      RETURN
      END 
      BLOCK DATA TAPBD
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
      DATA NDFIND/0/,LUEK/0/
      END 
C     Subr. TAPOT -reads strobe table, sends ASCII commands. RJC 12/80
C                  After first checking status! 
      SUBROUTINE TAPOT (INDEX,ISTROB,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 ITRAN(8),ISTRBC(4),IBUF(4),IRECV(7) 
      INTEGER*4 I4GET 
      LOGICAL*2 KWVR,KECHO
      DATA ISTRBC/'!%()+-.;'/,KWVR/.FALSE./ 
C 
      KECHO=LUEK.NE.0 
C 
C     Interrogate controller to find out ALARM & REMOTE stati.
      CALL TAPIN (INDEX,5,KERR) 
      IF (KERR.GE.0) THEN 
          IF (I4GET(31,31,KSTATE(5,INDEX)) .EQ.1) THEN
C             Controller in LOCAL mode. 
              KERR=-2 
          ELSE IF (I4GET(30,30,KSTATE(5,INDEX)) .EQ.1) THEN 
C             Controller's ALARM condition is set.
              KERR=-1 
          ELSE
C             Build command string, piece by piece. 
              CALL CMOVE (1H#,1,ITRAN,1,1)
C             MAT address.
              CALL CMOVE (IDEVTB(2,INDEX),1,ITRAN,2,2)
              CALL CMOVE (1H=,1,ITRAN,4,1)
C             Move in strobe character. 
              CALL CMOVE (ISTRBC,ISTROB,ITRAN,5,1)
C             Put binary command word into ASCII-style hex. 
              CALL HEX (KOMMND(ISTROB,INDEX),IBUF,2)
              CALL CMOVE (IBUF,1,ITRAN,6,8) 
C             Command string built, send off to MAT.
              CALL DATAT (IDEVTB(5,INDEX), ITRAN,13,IDEVTB(3,INDEX),
     .                      0,KECHO,LUEK,KWVR,IRECV,NRC,KERR) 
          ENDIF 
      ENDIF 
      RETURN
      END 
      LOGICAL FUNCTION SAMEQ(XQ,YQ) 
     .,VTAPE subroutine 
C     SAMEQ returns TRUE iff XQ and YQ are identical.  RJC 12/80
      INTEGER*2 XQ,YQ 
      IF (XQ .EQ. YQ  .AND.  IPOSQ(XQ,YQ,1) .EQ.1) THEN 
          SAMEQ=.TRUE.
      ELSE
          SAMEQ=.FALSE. 
      ENDIF 
      END 
C     Subroutine TAPIN -gets requested strobe info.,plugs table RJC 1/81
      SUBROUTINE TAPIN (INDEX,ISTROB,KERR)
     .,VTAPE subroutine 
C 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 ITRAN(4),IRECV(7),ISTRBC(4) 
      LOGICAL KWVR,KECHO
      DATA ISTRBC/'!%()+-.;'/,KWVR/.FALSE./ 
C 
      KECHO=LUEK.NE.0 
      LUMAT=IDEVTB(3,INDEX) 
C     Build and send off the request, and transfer control. 
      CALL CMOVE (2H# ,1,ITRAN,1,1) 
      CALL CMOVE (IDEVTB(2,INDEX),1,ITRAN,2,2)
      CALL CMOVE (ISTRBC,ISTROB,ITRAN,4,1)
      CALL CMOVE (2H> ,1,ITRAN,5,1) 
      CALL IAT (ITRAN,5,LUMAT,0,KECHO,LUEK,KWVR,IRECV,NRC,KERR) 
C     If successful, find the response. 
      IF (KERR .GE.0) THEN
          CALL CMOVE (2H? ,1,ITRAN,4,1) 
          CALL IAT (ITRAN,4,LUMAT,0,KECHO,LUEK,KWVR,IRECV,NRC,KERR) 
          IF (KERR .GE.0) THEN
C             Convert ASCII hex digits to binary,flag invalid hex digits. 
              CALL HEXI (IRECV,KSTATE(ISTROB,INDEX),8,IERR) 
              IF (IERR .EQ.1) KERR=-5 
          ENDIF 
      ENDIF 
      RETURN
      END 
      FUNCTION IBCD(XQ) 
     .,VTAPE subroutine 
C     IBCD returns the value in BCD of the string XQ, left-padded with
C     zeroes to be one word long. If XQ is longer than 4 digits, or has 
C     any digits other than 0-9, IBCD is returned as -1.
      INTEGER*2 XQ(1) 
      LEN=XQ(1) 
      IF (LEN.LT.0 .OR. LEN.GT.4) THEN
          IBCD=-1 
      ELSE
          IBCD=0
          DO 20 I=1,LEN 
              IBCD=ISHFT(IBCD,4)
              IDIG=IGETQ(XQ,I)
              IF (IDIG.LT.48 .OR. IDIG.GT.57) THEN
                  IBCD=-1 
                  RETURN
              ENDIF 
              IDIG=IDIG-48
 20           IBCD=IOR(IBCD,IDIG) 
      ENDIF 
      RETURN
      END 
C     Subroutine TAPME - fetch contents of memory location. RJC 5/82
      SUBROUTINE TAPME (LU,INDEX,IBUF,IPAR,KERR)  
     .,VTAPE subroutine 
C 
      INTEGER*2 IBUF(1),IPAR(5) 
      COMMON/TAPCO/KOMMND,KSTATE,IDEVTB,NDFIND,LUEK 
      INTEGER*4 KOMMND(8,8),KSTATE(8,8) 
      INTEGER*2 IDEVTB(5,8) 
C 
      INTEGER*2 JBUF(4) 
C     Pad buffer with 0's, insert address, convert to binary. 
      CALL CMOVE (1H0,1,JBUF,1,1) 
      CALL CMOVE (JBUF,1,JBUF,2,7)
      LEN=MIN0 (IBUF(1)-3,8)
      CALL CMOVE (IBUF,6,JBUF,9-LEN,LEN)
      CALL HEXI (JBUF,KOMMND(8,INDEX),8,IERR) 
      IF (IERR .EQ.1) THEN
C         Invalid hex. number.
          KERR=-7 
      ELSE
C         Set address in tape controller. 
          CALL TAPOT (INDEX,8,KERR) 
          IF (KERR .GE.0) THEN
C             Now get contents of said address. 
              CALL TAPIN (INDEX,8,KERR) 
              IF (KERR .GE.0) THEN
                  CALL HEX (KSTATE(8,INDEX),JBUF,2) 
                  WRITE (LU,'("Value=",2A2)') JBUF(4),JBUF(3) 
                  IPAR(2)=KSTATE(8,INDEX) 
              ENDIF 
          ENDIF 
      ENDIF 
C 
      RETURN
      END 
C     Subroutine TAPHI - pushes or prints VTAPE command history. RJC 4/82 
      SUBROUTINE TAPHI (PUSH,INDEX,IBUF,LUOP) 
     .,VTAPE subroutine 
      LOGICAL PUSH
      INTEGER*2 IBUF(1),ISTAK(100,8),ITOP(8)
      DATA ITOP /8*0/   
      IF (PUSH) THEN
          LEN=(IBUF(1)+1)/2+1 
 10       IROOM=100-ITOP(INDEX) 
          IF (IROOM .GE. LEN) GOTO 20 
C             Not enough space, drop commands off bottom & shift. 
              ICHOP=(ISTAK(1,INDEX)+1)/2+1
              CALL WMOVE (ISTAK(ICHOP+1,INDEX), 
     .                    ISTAK(1,INDEX),ITOP(INDEX)-ICHOP) 
              ITOP(INDEX)=ITOP(INDEX)-ICHOP 
              GOTO 10 
C         Enough room (now), push new command.
  20      CALL WMOVE (IBUF, ISTAK(ITOP(INDEX)+1,INDEX), LEN)
          ITOP(INDEX)=ITOP(INDEX)+LEN 
      ELSE
C         Parse for optional LU for history printout. 
          ISTRC=4 
          LUPARS=KVALQ (IBUF,IERR,ISTRC)
          IF (IERR.NE.0 .OR. LUPARS.LT.0 .OR. LUPARS.GT.64) THEN
C             Syntax error, not present, or out of range; use default 
              LU=LUOP 
          ELSE                   !print to requested LU 
              LU=LUPARS 
          ENDIF 
C         Print all entries on stack for this drive.
          IPTR=1
  30      CALL WRITQ (LU, ISTAK(IPTR,INDEX))
          IPTR=IPTR+(ISTAK(IPTR,INDEX)+1)/2+1 
          IF (IPTR .LT. ITOP(INDEX)) GOTO 30
      ENDIF 
C 
      RETURN
      END 
FTN4X 
C     Subroutine I4PUT -sets bits in I*4 word.  RJC 12/80 
      SUBROUTINE I4PUT (I,J,ITEM,INSERT)
     .,VTAPE subroutine 
      INTEGER*2 I,J 
      INTEGER*4 ITEM,INSERT,MASK,ONES 
      DATA ONES/-1/ 
C     I4PUT puts the values of INSERT into the Ith thru Jth bits of 
C     ITEM. I is the MSB of the field, J the LSB. If I<J nothing is 
C     done. I or J >31 acts like 31; I or J <0 acts like 0. Normal bit
C     numbering conventions are followed, i.e.- bit 31 of ITEM is the 
C     MSB, while bit 0 is the LSB. Only the low-order I-J+1 bits of 
C     INSERT are used. Care must be taken when INSERT<0, since HP 
C     FORTRAN uses two's complement representation of integers. 
C 
      IF (I.GE.J) THEN
C         Force I and J to lie in 0-31 domain.
          II=MAX (0,MIN(31,I))
          JJ=MAX (0,MIN(31,J))
C         Create a masking-window of 1's from Ith thru Jth bits.
          MASK=IAND (ISHFT(ONES,II-31), ISHFT(ONES,JJ)) 
C         Clear out window area in result.
          ITEM=IAND (ITEM, NOT(MASK)) 
C         OR in a masked version of INSERT, shifted into window.
          ITEM=IOR (ITEM, IAND(MASK, ISHFT(INSERT,JJ))) 
      ENDIF 
      RETURN
      END 
C     Function I4GET -gets value of subfield in I*4 word. RJC 12/80 
      INTEGER*4 FUNCTION I4GET (I,J,ITEM) 
     .,VTAPE subroutine 
      INTEGER*2 I,J 
      INTEGER*4 ITEM
C     I4GET returns the value of the subfield from bit I thru bit J 
C     of ITEM. I is the MSB of the subfield, J is the LSB. I or J >31 
C     acts like 31; I or J <0 act like 0. Bit 31 of ITEM is the MSB,
C     bit 0 is the LSB. When I<J I4GET returns 0. 
C 
      IF (I.LT.J) THEN
          I4GET=0 
      ELSE
C         Force I and J to lie in 0-31 domain.
          II=MAX (0,MIN(31,I))
          JJ=MAX (0,MIN(31,J))
C         Shift unwanted bits off left end, then right-justify. 
          I4GET=ISHFT (ISHFT(ITEM,31-II), II-31-JJ) 
      ENDIF 
      RETURN
      END 
FTN4X 
C@DATAT 
C 
      SUBROUTINE DATAT(IMODE,ITRAN,NTR,LUMAT,LUWVR,KECHO,LU,KWVR, 
     .                 IRECV,NRC,IERR)
     .,VTAPE subroutine 
C 
C 1.1.   DATAT sends a data stream to the AT
C 
C     INPUT VARIABLES:
C 
C        IMODE  - mode of transmission, > 0 
C        NTR    - number of characters in transmission buffer 
      DIMENSION ITRAN(1)
C               - transmission buffer, all ready execpt for last char 
C        LUMAT  - LU of MAT daisy chain 
C        LUWVR  - LU of WVR 
      LOGICAL KECHO 
C               - true if terminal echo of communications is wanted 
C        LU     - unit for operator's terminal
      LOGICAL KWVR
C                - true if this is WVR communications 
C 
C     OUTPUT VARIABLES: 
C 
C        IERR   - error return
      DIMENSION IRECV(10) 
C               - buffer for response, if any 
C        NRC    - number of characters in response
C 
C     CALLING SUBROUTINES: MATCN
C 
C     CALLED SUBROUTINES: character utilities, IAT
C 
C 3.  LOCAL VARIABLES 
C 
      DIMENSION LASTCH(4) 
C               - terminal characters, depending on mode
C        IVERIF - transmitted to AT for verification response 
C        IUPDAT - transmitted to AT for updating pending data 
C 
C 4.  CONSTANTS USED
C 
C 
C 5.  INITIALIZED VARIABLES 
C 
      DATA LASTCH/2H$/,2H**,2H& ,2H  /
      DATA IVERIF/2H/ / 
      DATA IUPDAT/2H$ / 
C 
C 6.  PROGRAMMER: NRV (FROM ARW)
C     LAST MODIFIED:  800229
C 
C     PROGRAM STRUCTURE 
C 
C     1. Put the appropriate last character into the buffer.
C     Send buffer to AT via function IAT call.
C     If verification requested, get response and compare.
C     If update required, update and quit.
C 
      CALL ICHMV(ITRAN,NTR+1,LASTCH,IMODE+1,1)  
C 
      IF(IAT(ITRAN,NTR+1,LUMAT,LUWVR,KECHO,LU,KWVR,IRECV,NRC,IERR).LT.0)  
     .GOTO 990
D     I = IAT(ITRAN,NTR+1,LUMAT,LUWVR,KECHO,LU,KWVR,IRECV,NRC,IERR) 
D     WRITE(LU,9901) I,NRC,IRECV
D9901 FORMAT("IN DATAT: I,NRC,IREC="2I4,20A2) 
      IF (IMODE.EQ.0.OR.IMODE.EQ.2.OR.IMODE.EQ.4) GOTO 990
C 
      IF (IMODE.EQ.1) GOTO 200
C 
      IF (IAT(IVERIF,1,LUMAT,LUWVR,KECHO,LU,KWVR,IRECV,NRC,IERR).LT.0)
     .GOTO 990
C 
200   DO 210 I=1,NTR-2
        IF (IRECV(I).EQ.ITRAN(I+2)) GOTO 210
        IERR = -6 
        GOTO 990
210     CONTINUE
C 
      IF (IMODE.EQ.1) IDUM=IAT(IUPDAT,1,LUMAT,LUWVR,KECHO,LU,KWVR,
     .IRECV,NRC,IERR) 
C 
990   RETURN
      END 
FTN4X 
C@IAT 
C 
      FUNCTION IAT(ITRAN,NTR,LUMAT,LUWVR,KECHO,LU,KWVR,IRECV,NRC, 
     .             IERR)
     .,VTAPE subroutine 
C 
C   IAT handles communications with the MAT 
C 
C  WHO DATE    CHANGE 
C  NRV 810624 MODIFY FOR DVF00 TRIGGER CHAR IMMEDIATE TURNAROUND
C 
C     INPUT VARIABLES:
C 
C        NTR    - number of characters in ITRAN 
      DIMENSION ITRAN(1)
C               - buffer to be transmitted
C        LUMAT  - LU of MAT daisy chain 
C        LUWVR  - LU of WVR 
      LOGICAL KECHO 
C              - true if MAT communications echo desired
      LOGICAL KWVR
C              - true if this is a WVR communication
C        LU     - LU for operator's terminal
C 
C     OUTPUT VARIABLES: 
C 
C        NRC    - number of characters in received buffer 
      DIMENSION IRECV(1)
C               - buffer received from AT 
C        IERR   - error code
C 
C     CALLING SUBROUTINES: MATCN,DATAT
C 
C     CALLED SUBROUTINES: character utilities, REIO(1and 2)s
C 
C LOCAL VARIABLES 
C 
C        ILEN   - max length available in ITRAN buffer, characters. 
C                ***NOTE*** THIS MUST CORRESPOND TO THE LENGTH
C                           OF IBUF2 IN MATCN, LESS 1 WORD. 
C        IFRECV - 1 if we expect response, 0 if none expected 
C        IR     - which terminal character in IRSPN we find 
C     MAXTRY - maximum number of times we will try to communicate 
C     ITRY - count of attempts
      DIMENSION IREG(2) 
C               - registers from REIO 
C     LTRIG - termination character for trigger 
C     NCTRAN - number of char to be transmitted 
      DIMENSION NCHRC(8)
C               - number of characters received in responses
      DIMENSION IRSPN(4)
C               - terminal characters which generate a response 
C        NRSPN  - number of responses possible
      EQUIVALENCE (IREG(1),REG) 
C 
C   INITIALIZED VARIABLES 
C 
      DATA NCHRC/3,3,10,10,3,3,16,0/
      DATA IRSPN/2H$*,2H?/,2H>',002400B/
C                   Last char is <enq><null>
      DATA ILEN/78/ 
      DATA NRSPN/7/ 
      DATA MAXTRY/2/
C 
C 
C     1. Find the last character in the buffer to determine the 
C     type of response. 
C     Add a "_" to the end of the buffer to suppress CRLF 
C 
      IERR = 0
      ITRY = 0
      IFRECV = 0
      NRC = 0 
      NCTRAN = NTR
C 
      IF (KWVR) IFRECV = 1
C                   There is always a response to the WVR 
      I = ISCNC(ITRAN,1,NTR,72B)
      IF (I.NE.0) IFRECV = 1
C                   A colon in the message means a response 
      DO 100 IR=1,NRSPN 
        IF (ICHAR(ITRAN,NTR).EQ.ICHAR(IRSPN,IR)) GOTO 110 
100     CONTINUE
      GOTO 120
110   IFRECV = 1
C 
120   LTRIG = 0 
      IF (IFRECV.EQ.0) GOTO 125 
      IDUM=ICHMV(LTRIG,2,ITRAN,NCTRAN,1)
      IF(KWVR) LTRIG=15B
C                   Move the last char into a separate variable, lower byte 
      NCTRAN = NCTRAN-1 
C                   Don't count the last char any more
C 
125   IF(.NOT.KWVR) NCTRAN = ICHMV(ITRAN,NCTRAN+1,2H_ ,1,1)-1 
C     IF(     KWVR) NCTRAN = ICHMV(ITRAN,NCTRAN+1,6537B,1,2)-1
C 
C     2. Write the buffer to the MAT, and read response if expected.
C 
200   IF (KECHO) CALL REIO(2,LU,ITRAN,-(NCTRAN+1))
C                   Write message on the screen if echo is on 
C                   NOTE: write one more than number of characters
C                   to be transmitted so that trigger char appears
      IF (.NOT.KWVR) REG = REIO(2,LUMAT,ITRAN,-NCTRAN)
C     IF(KWVR) WRITE(LU,2000) (ITRAN(IWVR),IWVR=1,NCTRAN+1) 
      IF (     KWVR) REG = REIO(2,LUWVR,ITRAN,-(NCTRAN+1))
C2000 FORMAT(10O7/) 
C                   Write the buffer to the AT
      IF (IFRECV.EQ.0) GOTO 900 
C                   We're done now if there is to be no response
C 
C***NOTE THIS SHOULD BE 3200B+LUMAT FOR THE REAL THING******
C     For actual communications, use 3200B in the read request. 
C       3200B = 0 1 1 0 1 0 
C                 | | | | | ASCII read
C                 | | | | no master reset on initialization 
C                 | | | no echo 
C                 | | transmit spec. char. (LF, CR) 
C                 | buffer mode 
C***NOTE THIS SHOULD BE  400B+LUMAT FOR TERMINAL TESTS******
C     IF (.NOT.KWVR) REG = REIO(1,400B+LUMAT,IRECV,-ILEN) 
C     IF (     KWVR) REG = REIO(1,400B+LUWVR,IRECV,-ILEN) 
      IF (.NOT.KWVR) CALL EXEC(3,1200B+LUMAT,020000B+LTRIG) 
      IF (     KWVR) CALL EXEC(3,1200B+LUWVR,020000B+LTRIG) 
C                   Set up the trigger character
      IF (.NOT.KWVR) REG = REIO(1,3200B+LUMAT,IRECV,-ILEN)
      IF (     KWVR) REG = REIO(1,3200B+LUWVR,IRECV,-ILEN)
      NRC = MIN0(ILEN,IREG(2))
      IF (KECHO) CALL REIO(2,LU,IRECV,-NRC) 
C                   If echo requested, write response on screen 
C 
      ITRY = ITRY + 1 
C 
C 
C     8. Now check for errors.  If time-out or wrong number of characters,
C     try communications all over again.
C     If we got a 6B (ack) or 25B (nak) substitute readable ACK or NAK. 
C 
800   IF (IAND(IREG,10B).EQ.0) GOTO 810 
C     TIMEOUT 
      IF (ITRY.LT.MAXTRY) GOTO 200
      IERR = -4 
      GOTO 900
810   IF (NRC.EQ.NCHRC(IR).OR.KWVR) GOTO 820
C     WRONG NUMBER OF CHARACTERS IN RESPONSE
      IF (ITRY.LT.MAXTRY) GOTO 200
      IERR = -5 
      GOTO 900
820   IF ((.NOT.KWVR.AND.ICHAR(IRECV,1).NE.6B).OR.
     .     (KWVR.AND.NRC.NE.2)) GOTO 830
      IERR = +1 
      NRC = ICHMV(IRECV,1,3HACK,1,3) - 1
      GOTO 900
830   IF (KWVR.OR.ICHAR(IRECV,1).NE.25B) GOTO 840 
      IERR = +2 
      NRC = ICHMV(IRECV,1,3HNAK,1,3) - 1
      GOTO 900
840   IERR = 0
900   IAT = IERR
      RETURN
      END 
