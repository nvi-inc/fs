FTN4
      PROGRAM VERIF(2,85) 
C 
C     PROGRAM TO COMPARE CONTENTS OF TWO FILES. 
C     COMPARES FILES ON DISC OR FROM SPECIFIED LOGICAL UNIT.
C 
C     FOLLOWING MODS BY ARW 8/76: 
C     MODIFIED TO PROPERLY HANDLE TYPE 1 & 2 DISC FILES.
C     MODIFIED TO PROPERLY CLOSE DISC FILES WHEN FINISHED.
C     MULTIPLE-PASS CAPABILITY WITH SEPARATION OF INPUT AND 
C       OUTPUT CONTROL LU'S SO THAT, FOR EXAMPLE, A MULTIPLE- 
C       FILE MAG TAPE MAY BE EASILY VERIFIED BY SETTING UP
C       CONTROL INPUT ON CARDS OR PAPER TAPE, ETC.
C 
C     MODIFICATION RECORD:
C     WHEN   WHO  WHAT
C     770513 ARW  MODIFIED TO PROPERLY HANDLE TYPE 6 FILES (ARW)
C     790210 LNF  MODIFIED TO PROPERLY CLOSE AFTER VERIFY ABORT 
C     810313 CMA  MODIFIED TO PRINT ASCII ONLY
C 
C     TO RUN: "RU,VERIF,LUIN,LUOUT,LNAMR,KASC"
C        LUIN=UNIT FROM WHICH CONTROL INPUTS ARE TO BE MADE 
C        LUOUT=UNIT ON WHICH LOG OF RESULTS IS TO BE MADE,
C              IF DIFFERENT FROM LUIN.
C        LNAMR=NAMR OF A LIST THAT SHOULD BE COMPARED WHERE LIST
C              IS OF FORM 
C                   NAMR1,NAMR2 
C              KASC /= 0 - PRINT ASCII ONLY 
C 
        LOGICAL DEF 
C 
      DIMENSION IDCB1(144),IDCB2(144),IBUF1(128),IBUF2(128) 
      DIMENSION IPAR(5),NAME1(10),NAME2(10),IDCBL(144)
      DIMENSION IREG(2),NAMEL(10) 
      EQUIVALENCE (IREG,REG)
C 
      CALL RMPAR(IPAR)
      LUIN=IPAR 
      IF(LUIN.EQ.0) LUIN = 1
      LUOUT=LUIN
      IF (IPAR(2) .NE. 0) LUOUT=IPAR(2) 
        IF(IPAR(3) .EQ. 0)GO TO 10002 
        REG=EXEC(14,1,IBUF1,-256) 
C               GET THE INPUT STRING
        LEN=IREG(2) 
        ICM4=ISCNC(IBUF1,1+ISCNC(IBUF1,1+ISCNC(IBUF1,1
     .+ISCNC(IBUF1,1,LEN,54B),LEN,54B),LEN,54B),LEN,54B)+1
C               FIND FOURTH COMMA PLUS 1
        CALL NAMR(NAMEL,IBUF1,LEN,ICM4) 
C               GET THE LIST NAMR 
        CALL OPEN(IDCBL,IERR,NAMEL,0,NAMEL(5),NAMEL(6)) 
        IF(IERR .LT. 0)GO TO 10002
C               IF AN ERROR TREAT AS NO LIST PRESENT
10001   CALL READF(IDCBL,IERR,IBUF1,128,ILLEN)
        IF(ILLEN .LT. 0)GO TO 581 
        ISCRL=1 
        WRITE(LUOUT,1001) (IBUF1(I),I=1,ILLEN)
1001    FORMAT(" VERIF LIST REQUEST = ",40A2) 
        GO TO 10004 
10002   CONTINUE
        NAMEL=-1
10004   CONTINUE
C     GET LUIN DEVICE TYPE
      CALL EXEC(13,LUIN,IDEVIN) 
      IDEVIN=IAND(IDEVIN,37400B)/256
      IECHO=0 
      IF (IDEVIN .EQ. 0 .OR. IDEVIN .EQ. 5) IECHO=400B
C 
C     CHECK THAT MAG TAPE HAS NOT MISTAKENLY BEEN SPECIFIED FOR 
C     BOTH LUIN AND LUOUT.
      CALL EXEC(13,LUOUT,IDVOUT)
      IDVOUT=IAND(IDVOUT,37400B)/256
      IF (LUIN .NE. LUOUT) GO TO 5
      IF (IDVOUT .NE. 23B) GO TO 5
      WRITE(1,6)
6     FORMAT(" /VERIF: MAG TAPE FOR BOTH INPUT AND OUTPUT!!") 
      GO TO 581 
C 
C     GET THE FIRST FILE NAME OR LU#
C 
5     NRECRD=1
      IF(NAMEL .EQ. -1)CALL FNAME(NAME1,LUOUT,LUIN,IECHO,ITYPE) 
        IF(NAMEL .NE. -1)CALL NAMR(NAME1,IBUF1,2*ILLEN,ISCRL) 
      IF (NAME1.EQ.2H:: .AND.IAND(NAME1(4),177774B) .EQ. 0) GO TO 580 
C 
      IF(NAME1)10,20
C 
C     IF AN LU # , DUMMY UP A DCB 
C 
  10  CALL DCBDM(IDCB1,-NAME1,ITYPE)
      GO TO 30
C 
C     ELSE - OPEN THE NAMED FILE. 
C 
20    REG=OPEN(IDCB1,IERR,NAME1,1,NAME1(5),NAME1(6))
      IF (IERR) 22,26 
22    WRITE(LUOUT,24) IERR
24    FORMAT(" OPEN ERROR FILE A....IERR=",I4)
      GO TO 580 
C     IF TYPE 6 FILE, REOPEN WITH TYPE FORCED TO 1
26    IF(IERR.EQ.6)REG=OPEN(IDCB1,IERR,NAME1,5,NAME1(5),NAME1(6)) 
C 
C     GET THE SECOND FILE NAME
C 
  30  IF(NAMEL .EQ. -1)CALL FNAME(NAME2,LUOUT,LUIN,IECHO,ITYPE) 
        IF(NAMEL .NE. -1)CALL NAMR(NAME2,IBUF1,2*ILLEN,ISCRL) 
      IF (NAME2 .EQ. 2H::.AND.IAND(NAME2(4),177774B).EQ. 0) GO TO 580 
C 
      IF(NAME2)40,50
C 
C     IF AN LU # , DUMMY UP A DCB 
C 
  40  CALL DCBDM(IDCB2,-NAME2,ITYPE)
      GO TO 60
C 
C     ELSE - OPEN UP THE NAMED FILE 
C 
50      CONTINUE
        IF(.NOT. DEF(NAME2,1) )CALL ICHMV(NAME2,1,NAME1,1,6)
      REG=OPEN(IDCB2,IERR,NAME2,1,NAME2(5),NAME2(6))
      IF (IERR) 52,56 
52    WRITE(LUOUT,54) IERR
54    FORMAT(" OPEN ERROR FILE B....IERR=",I4)
      CALL CLOSE(IDCB1) 
      GO TO 580 
C     IF TYPE 6 FILE, REOPEN WITH TYPE FORCED TO 1
56    IF(IERR.EQ.6)REG=OPEN(IDCB2,IERR,NAME2,5,NAME2(5),NAME2(6)) 
C 
C     READ A RECORD FROM FILE A 
C 
60    REG=READF(IDCB1,IERR,IBUF1,128,LEN1)
      IF (IERR .NE. -12) GO TO 61 
C     EOF ON TYPE 2 FILE
      LEN1=-1 
      GO TO 65
61    IF (IERR) 62,65 
62    WRITE(LUOUT,63) IERR,LEN1 
63    FORMAT(" READ ERROR FILE A....IERR=",I4,"    LRECL=",I4)
      GO TO 69
C 
C     NOW GET ONE FROM FILE B 
C 
65    REG=READF(IDCB2,IERR,IBUF2,128,LEN2)
      IF (IERR .NE. -12) GO TO 66 
      LEN2=-1 
      GO TO 70
66    IF (IERR) 67,70 
67    WRITE(LUOUT,68) IERR,LEN2 
68    FORMAT(" READ ERROR FILE B....IERR=",I4,"    LRECL=",I4)
69    CALL CLOSE(IDCB1) 
      CALL CLOSE(IDCB2) 
      GO TO 580 
C 
C     IS EITHER FILE LENGTH = 0 ? 
C 
70    IF(LEN1.LT.0.OR.LEN2.LT.0)GO TO 200 
C 
C     ERROR IF FILE LENGTHS DO NOT AGREE. 
C 
      IF(LEN1.NE.LEN2) GO TO 700
C 
C     COMPARE THE CONTENTS OF THESE 2 RECORDS 
C 
C 
        IF(ICHCM(IBUF1,1,IBUF2,1,2*LEN1) .NE. 0)GO TO 700 
101   NRECRD = NRECRD + 1 
      GO TO 60
C 
200   IF(LEN1 .NE. LEN2) GO TO 700
C 
      WRITE(LUOUT,515)
515   FORMAT(" /VERIF: COMPARE GOOD !") 
      CALL CLOSE(IDCB2) 
      CALL CLOSE(IDCB1) 
        IF(NAMEL .NE. -1)GO TO 10001
      GO TO 5 
C 
700   WRITE(LUOUT,5000)NRECRD,LEN1,LEN2 
5000  FORMAT(" /VERIF: COMPARE ERROR--RECORD #",I6,/, 
     .       " /VERIF: RECORD LENGTHS - A",I6,"   B",I6)
      LUQ=1 
      IF (IDEVIN .EQ. 0 .OR. IDEVIN .EQ. 5) LUQ=LUIN
      IF (LUQ .EQ. 1) WRITE(LUOUT,550)
550   FORMAT(" /VERIF: SEE SYSTEM CONSOLE") 
      WRITE(LUQ,560)
560   FORMAT(" /VERIF: LIST RECORD? (Y/N) _") 
      CALL REIO(1,LUQ+400B,NYES,-1) 
C 
      IF(NYES .NE. 2HY ) GO TO 516
      IF(IPAR(4).NE.0) GO TO 511
      WRITE(LUOUT,505)(IBUF1(I),I=1,LEN1) 
505   FORMAT(/" RECORD A (OCTAL)" /(X,10K7))
      WRITE(LUOUT,510)(IBUF2(I),I=1,LEN2) 
510   FORMAT( " RECORD B (OCTAL)" /(X,10K7))
511   WRITE(LUOUT,512)(IBUF1(I),I=1,LEN1) 
512   FORMAT( " RECORD A (ASCII)" /(  40A2))
      WRITE(LUOUT,514)(IBUF2(I),I=1,LEN2) 
514   FORMAT( " RECORD B (ASCII)" /(  40A2))
      IF (LUQ .EQ. 1) WRITE(LUOUT,550)
516   WRITE(LUQ,520)
520   FORMAT(/" /VERIF: CONTINUE? (Y/N) _") 
      CALL REIO(1,LUQ+400B,NYES,-1) 
      IF (NYES .EQ. 2HY ) GO TO 101 
      GO TO 69
580     CONTINUE
        IF(NAMEL .NE. -1)GO TO 10001
581     CONTINUE
        WRITE(LUOUT,590)
590   FORMAT(" /VERIF: ENDED")
C 
      END 
C     SUBROUTINE FNAME
      SUBROUTINE FNAME(NAME,LUOUT,LUIN,IECHO,ITYP)
      DIMENSION NAME(10),IREG(2),IBUF(15) 
      DIMENSION MESS1(10),MESS2(4)
      EQUIVALENCE (REG,IREG)
      DATA MESS1/2HFI,2HLE,2H N,2HAM,2HE ,2HOR,2H L,2HU ,2H# ,2H _/ 
      DATA MESS2/2HFO,2HRM,2HAT,2H _/ 
C 
      IF (IECHO .NE. 0) CALL EXEC(2,LUIN,MESS1,10)
C 
C     CLEAR THE NAME ARRAY TO BLANKS
C 
      DO 1 I=1,15 
1     IBUF(I)=2H
      REG=REIO(1,IECHO+LUIN,IBUF,-30) 
      IF (LUIN .NE. LUOUT) WRITE(LUOUT,5) (IBUF(I),I=1,(IREG(2)+1)/2) 
5     FORMAT(3A2) 
C     CALL NAMR TO PARSE THE STRING 
      ISCR=1
      IF (NAMR(NAME,IBUF,IREG(2),ISCR) .LT. 0 .OR.
     .    IAND(NAME(4),3B) .EQ. 0) 6,8
6     NAME=2H:: 
      RETURN
C 
C IF THE FIRST CHARACTER IS NUMERIC, PROCESS THE LOGICAL
C UNIT NUMBER, ELSE RETURN. 
C 
8     IF (IAND(NAME(4),3B) .EQ. 1) GO TO 10 
C 
      RETURN
C 
C LOGICAL UNIT SPECIFIED SO, GET THE FILE FORMAT
C 
  10  IF (IECHO .NE. 0) CALL EXEC(2,LUIN,MESS2,4) 
      CALL REIO(1,IECHO+LUIN,ITYP,1)
      IF (LUIN .NE. LUOUT) WRITE(LUOUT,12) ITYP 
12    FORMAT(A2)
C 
C NOW RETURN A NEGATIVE LU # IN NAME(1).
C 
      NAME=-NAME
      RETURN
      END 
C     SUBROUTINE DCBDM
      SUBROUTINE DCBDM(IDCB,LU,ITYPE) 
      DIMENSION IDCB(144) 
C 
C CLEAR THE DCB TO ZEROES.
C 
      DO 10 I=1,144 
  10  IDCB(I) = 0 
C 
C WHAT TYPE OF DEVICE IS THIS DCB FOR ? 
C 
      CALL EXEC(13,LU,IDEV) 
C 
      IDEV = IAND(IDEV,37400B)/256
C 
      IF(IDEV.EQ.0) GO TO 100 
      IF(IDEV.EQ.1) GO TO 200 
      IF(IDEV.EQ.2) GO TO 300 
      IF(IDEV.EQ.5) GO TO 600 
      IF(IDEV.EQ.12B) GO TO 400 
      IF(IDEV.EQ.15B) GO TO 500 
      IF(IDEV.EQ.23B) GO TO 600 
C 
C UNRECOGNIZED DEVICE TYPE. 
C SET IDCB(1) TO -1 & RETURN TO CALLER. 
C 
      IDCB(1) = -1
      RETURN
C 
C FOR DVR00 
C 
  100 IDCB(7) = 100001B 
      GO TO 350 
C 
C FOR DVR01 
C 
  200 IDCB(7) = 100000B 
      GO TO 350 
C 
C FOR DVR02 
C 
  300 IDCB(7) = 1 
  350 IDCB(6) = 1 
      IDCB(5) = 1000B + LU
      GO TO 1000
C 
C FOR DVR12 
C 
  400 IDCB(7) = 1 
      IDCB(6) = 1 
      IDCB(5) = 1100B + LU
      GO TO 1000
C 
C FOR DVR15 
C 
  500 IDCB(7) = 100000B 
      IDCB(6) = 1 
      IDCB(5) = 100B + LU 
      GO TO 1000
C 
C FOR DVR23 AND DVR05(TAPE CARTRIDGES)
C 
  600 IDCB(7) = 100001B 
      IDCB(6) = 100001B 
      IDCB(5) = 100B + LU 
C 
C FINISH THIS SET UP. 
C 
 1000 IDCB(4) = LU
      IDCB(10) = IGET(1717B)
      IF(ITYPE.EQ.2HBA) IDCB(4) = LU + 2300B
      IF(ITYPE.EQ.2HBR) IDCB(4) = LU + 300B 
C 
      RETURN
      END 
C@DEF 
C 
        LOGICAL FUNCTION DEF(N,I),C#790718:00:38    # 
C 
C     DEF 
C 
C 1.  NAME PROGRAM SPECIFICATION
C 
C 1.1.   DEF
C               THIS LOGICAL FUNCTION TEST WHETHER A PARAMETER WAS DEFINED
C       FORM A NAMR INPUT BY THE USED.  THIS FUNCTION TESTS THE OUTPUT
C       OF THE SUBROUTINE TO DETERMINE IF IT FOUND A PARTICULAR COMPONENT 
C       PRESENT.
C 
C 1.2.   RESTRICTIONS - limits on use of routine
C 
C               THE ARRAY N IS ASSUMED TO BE STRUCTURED AS THE OUTPUT FROM
C       THE SYSTEM UTILITY NAMR WOULD BE AFTER A CALL.
C 
C 1.3.   REFERENCES - document cited
C 
C       1.  DOS/RTE RELOCATABLE LIBRARY HP #24998-90001 
C 
C 2.  NAME INTERFACE
C 
C 2.1.   CALLING SEQUENCE: LVAL=DEF(N,I)
C                     OR    DEF(N,I) IN A LOGICAL IF STATEMENT
C 
C     INPUT VARIABLES:
C 
C       I       - THE SELECTOR FOR THE COMPONENT WANTED 
C 
        DIMENSION N(10) 
C 
C       N      - THIS TEN WORD ARRAY IS THE OUTPUT FROM THEN AMR
C                ROUTINE WHICH PARSES AN INPUT FILE NAME FROM THE 
C                NAMER FORMAT USED BY THE FILE MANAGER.  THE FORMAT OF
C                THIS ARRAY IS DEFINED BELOW AND CAN BE FOUND IN REFERENCE
C                1.  THE TYPES REFERED TO ARE DEFINED IN WORD FOUR. 
C 
C                            N(1) TYPE= 0 - 0 
C                                       1 - 16 BIT TWO'S COMPLIMENT NUMB
C                                       2 - NOT IMPLIMENTTED YET
C                                       3 - CHARACTERS 1&2 OF INPUT 
C                            N(2) TYPE=0-2 - 0
C                                     3        - CHARACTERS 3&4 
C                            N(3) TYPE=0-2 - 0
C                                     3        - CHARACTERS 5&6 
C                            N(4) - PARAM TYPE OF ALL 7 PARAMETERS IN 2 
C                                  BIT PAIRS
C                                        0 - NULL 
C                                        1 - INTEGER NUMBER INPUT 
C                                        2 - NOT IMPLIMENTED YET
C                                        3 - LEFT JUSTIFIED ASCII CHARS.
C                        BITS FOR   ,FNAME : P1 : P2 : P3 : P4 : P5 : P6, 
C                                    0,1    2,3  4,5  6,7  8,9 10,11 12,13
C 
C                            N(5) - 1ST SUB PARAM AS IN BITS 2,3 OF WORD 4
C                            N(6) - 2ND  "    "   AS IN BITS 4,5 OF WORD 4
C                            N(7) - 3RD  "    "   AS IN BITS 6,7 OF WORD 4
C                            N(8) - 4TH  "    "   BITS 8,9 OF WORD 4
C                            N(9) - 5TH  "    "   BITS 10,11 OF WORD 4
C                            N(10) - 6TH "    "   BITS 12,13 OF WORD 4
C 
C     OUTPUT VARIABLES: 
C 
C       DEF     - .TRUE. IF COMPONENT I IS DEFINED
C                 .FALSE. IF COMPONENT I IS NOT DEFINED 
C 
C 2.5.   SUBROUTINE INTERFACE:
C 
C     CALLING SUBROUTINES: SCNED
C 
C     CALLED SUBROUTINES: IAND
C 
C 6.  PROGRAMMER: LEE N. FOSTER 
C     LAST MODIFIED:
C# LAST COMPC'ED  790718:00:38urrent date) #
C 
C     PROGRAM STRUCTURE 
C 
C               TEST IF COMPONENT DEFINED ON INPUT
C 
        DEF=IAND(N(4),3*4**MAX0(0,I-4)) .NE. 0
C 
C               RETURN TO USER
C 
      RETURN
      END 
