FTN4,X
C@RXDMO 
C 
      SUBROUTINE RXDMO(IP,ICLCM),               
     .RX DISPLAY C#780803:08:31#
C 
C     RXDMO gets data from the receiver and displays it 
C 
C     INPUT VARIABLES:
C 
      DIMENSION IP(1) 
C        IP(1)  - class number of buffer from MATCN 
C        IP(2)  - # records in class
C        IP(3)  - error return from MATCN 
C        IP(4)  - who, or 77B (?) 
C        IP(5)  - class with command
C      - code words and number of char. in each 
      DIMENSION LC(3) 
C 
C     OUTPUT VARIABLES: 
C 
C        IP(1) - error
C        IP(2) - class
C        IP(3) - number of records
C        IP(4) - who we are 
C 
C 2.2.   COMMON BLOCKS USED 
C 
      INCLUDE #FSCOM::FS
C 
C 2.5.   SUBROUTINE INTERFACE:
C 
C     CALLED SUBROUTINES: character utilities 
C 
C 3.  LOCAL VARIABLES 
C 
C     IAD - A/D channel 
C     IDCAL - delay cal heater
C     IBOX - box heater 
C     ICAL - cal status 
C     ILO - LO status 
      DIMENSION IFAMP(3)
      DIMENSION IBUF1(20),IBUF2(30) 
C               - input class buffers, output display buffer
C        ILEN   - length of buffers, chars
C     DIMENSION VFAC(32)
C     - voltage divide ratios 
C     DIMENSION LUNITS(32)
C     - units for readings
C     DIMENSION TMPK(30)
C     - temperature lookup table for 20K diode
C     DIMENSION PVOLT(30) 
C     - prom voltage lookup table for 20K diode 
C        NCH    - character counter 
      DIMENSION LUNLK(8)
      LOGICAL KCOM,KDATA
      DIMENSION IREG(2) 
C               - registers from EXEC 
      EQUIVALENCE (REG,IREG(1)) 
C 
C 4.  CONSTANTS USED
C 
C 5.  INITIALIZED VARIABLES 
C 
C     DATA VFAC/7*100.0,2.0,8*1.0,2*101.0,4*11.0,  1.0, 
C    .7*4.9,2*1.0/  
C     DATA LUNITS/7*2HC ,17*2HV ,6*2HmA,2*2HK / 
      DATA ILEN/40/,ILEN2/60/ 
C     DATA TMPK/  4.,  5.,  7.,  9., 14.,     
C    A           18., 22., 23., 24., 25., 
C    B           26., 27., 28., 29., 30., 
C    C           32., 34., 36., 38., 60., 
C    D           75., 95.,130.,170.,215., 
C    E          235.,265.,285.,305.,330./ 
C     DATA PVOLT/2.46386,2.37578,2.23248,2.12245,1.91202, 
C    A           1.66870,1.34993,1.28434,1.23212,1.18995, 
C    B           1.16027,1.14015,1.12689,1.11741,1.11007, 
C    C           1.09942,1.09178,1.08559,1.07992,1.02744, 
C    D           0.98892,0.93535,0.83936,0.72739,0.59901, 
C    E           0.54327,0.46292,0.40797,0.35078,0.27665/ 
      DATA LUNLK /015446B,2HdB,2HUN,2HLO,2HCK,2HED,015446B,2Hd@/  
C 
C 6.  PROGRAMMER: NRV  CREATED 830610 AT MOJAVE 
C 
C     WHO  WHEN    WHAT 
C 
C     WEH  830617  ADDED LOOKUP TABLE FOR 20K NOISE DIODE 
C                  FIXED TO DISPLAY EXACTLY 4 SIGNIFICANT DIGITS
C     NRV  840509  MADE CHANGES FOR NEW VERSION 
C                  USE SAME TABLE FOR 70K AS FOR 20K
C                  PRESSURE FORMULA FROM BEC
C     MWH  850121  PUT 'UNLOCKED' MESSAGE IN INVERSE VIDEO
C     NRV  880615  MODIFIED PER LAR'S CHANGES FOR (RXDEF FILE 
C 
C 
C 
C     1. Determine whether parameters from COMMON wanted and skip to
C     response section. 
C     Get RMPAR parameters and check for errors from our I/O request. 
C 
      KCOM = IP(4).EQ.77B 
D     WRITE(LU,9801) IP,ICLCM,KCOM
D9801 FORMAT("ENTERING RXDMO WITH IP,ICLCM,KCOM="6I5,1X,L1) 
C 
      ICLASS = IP(1)
      NCREC = IP(2) 
      IERR = IP(3)
C 
      IF (KCOM) GOTO 200
      IF (IERR.LT.0) GOTO 990 
      IF (ICLASS.EQ.0.OR.ICLCM.EQ.0) GOTO 990 
C 
C 
C     2. Get class buffer with command in it.  Set up first part
C     of output buffer.  Get buffer from MATCN. 
C 
200   REG = EXEC(21,ICLCM,IBUF2,-ILEN2) 
C 
      NCHAR = IREG(2) 
D     WRITE(LU,9802) NCHAR,(IBUF2(I),I=1,10)
D9802 FORMAT("NCHAR,IBUF2="I5,1X,10A2)
      NCH = ISCNC(IBUF2,1,NCHAR,75B)
C                   Scan for "="
      KDATA = NCH.EQ.0
C                   If our command was only "device" we are waiting for 
C                   data and know what to expect. 
      IF (NCH.EQ.0) NCH = NCHAR+1 
C                   If no "=" found, position after last character
      NCH = ICHMV(IBUF2,NCH,2H/ ,1,1) 
C                   Put / to indicate a response
C 
      IF (KCOM) GOTO 310
      IF (KDATA) GOTO 230 
C 
      DO 220 I=1,NCREC
        IF (I.NE.1) NCH=MCOMA(IBUF2,NCH)
C                   If not first parm, put comma before 
        REG = EXEC(21,ICLASS,IBUF1,-ILEN) 
        NCHAR = IREG(2) 
        NCH = ICHMV(IBUF2,NCH,IBUF1(2),1,NCHAR-2) 
C                   Move buffer contents into output list 
220     CONTINUE
      GOTO 500
C 
230   REG = EXEC(21,ICLASS,IBUF1,-ILEN) 
C                   Get the  buffers with data  
C 
C 
C     3. Now the buffer contains: RX/, and we want to add the data. 
C 
300   CALL MA2RX(IBUF1(2),LOSTRX,ICAL,IDCAL,IBOX,IADC,VADC) 
      GOTO 320
310   IADC = IADCRX 
      ICAL = LSWCAL 
      IDCAL = IDCHRX
      IBOX = IBXHRX 
320   IERR = 0
      IA = 1 + IA22H(IADC)
C 
      IAD = 2H-1
      CALL ICHMV(LC,1,5HUNDEF,1,5)
      NL = 5
      IF(IA.EQ.0) GOTO 322
        NL = IFLCH(LCODE(1,IA),6) 
        IAD = IADC
        CALL ICHMV(LC,1,LCODE(1,IA),1,NL) 
322   NCH = ICHMV(IBUF2,NCH,IAD,1,2)  
      NCH = ICHMV(IBUF2,NCH,2H( ,1,1) 
      NCH = ICHMV(IBUF2,NCH,LC,1,NL)  
      NCH = ICHMV(IBUF2,NCH,2H) ,1,1) 
      NCH = MCOMA(IBUF2,NCH)
      IF (IDCAL.EQ.0) NCH = ICHMV(IBUF2,NCH,3HOFF,1,3)
      IF (IDCAL.EQ.1) NCH = ICHMV(IBUF2,NCH,2HON,1,2) 
      NCH = MCOMA(IBUF2,NCH)
      IF (IBOX.EQ. 0) NCH = ICHMV(IBUF2,NCH,3HOFF,1,3)
      IF (IBOX.EQ. 1) NCH = ICHMV(IBUF2,NCH,1HA,1,1)    
      IF (IBOX.EQ.-1) NCH = ICHMV(IBUF2,NCH,1HB,1,1)    
      NCH = MCOMA(IBUF2,NCH)
      DO 321 I=1,3
        IF (IFAMRX(I).EQ.0) NCH=ICHMV(IBUF2,NCH,3HOFF,1,3)  
        IF (IFAMRX(I).EQ.1) NCH=ICHMV(IBUF2,NCH,2HON,1,2)   
        NCH=MCOMA(IBUF2,NCH)
321     CONTINUE
      IF (ICAL.EQ. 0) NCH = ICHMV(IBUF2,NCH,3HOFF,1,3)
      IF (ICAL.EQ. 1) NCH = ICHMV(IBUF2,NCH,2HON,1,2) 
      IF (ICAL.EQ. 2) NCH = ICHMV(IBUF2,NCH,3HEXT,1,3)
      IF (ICAL.EQ.-1) NCH = ICHMV(IBUF2,NCH,3HOON,1,3)
      IF (ICAL.EQ.-2) NCH = ICHMV(IBUF2,NCH,4HOOFF,1,4) 
      IF (KCOM) GOTO 500
      NCH = MCOMA(IBUF2,NCH)
      IF (LOSTRX.EQ.1) NCH=ICHMV(IBUF2,NCH,6HLOCKED,1,6)
      IF (LOSTRX.EQ.0) NCH=ICHMV(IBUF2,NCH,LUNLK,1,16)
      NCH = MCOMA(IBUF2,NCH)
C     VADCRX = VADC  *VFAC(IA)  
C 
C   LOOKUP AND INTERPOLATE FOR 20K DIODE
C   .. AND FOR 70K
C 
C     IF(IA.NE.31.AND.IA.NE.32) GO TO 341   
C     DO 325 IL=1,30
C        IF (VADCRX.GT.PVOLT(IL)) GO TO 330 
C325     CONTINUE 
C 
C   CHECK FOR OUT OF RANGE 20K VOLTAGES 
C 
C330  CONTINUE
C     IF(IL.LE.30.AND. IL.GT.1) GO TO 335 
C     NCH=ICHMV(IBUF2,NCH,6HXXXXXX,1,5) 
C     GO TO 345 
C 
C   DO THE INTERPOLATION
C 
C335  CONTINUE
C     TDIF=TMPK(IL)-TMPK(IL-1)
C     VDIF=PVOLT(IL)-PVOLT(IL-1)
C     VMID=VADCRX-PVOLT(IL-1) 
C     VADCRX=TMPK(IL-1)+VMID*TDIF/VDIF  
C     GOTO 342
C 
C     CALCULATE PRESSURE
C*****CHECK THIS EQUATION!
C341  IF (IA.NE.24) GOTO 342
C     PRES = 62.*(5.0/VADCRX - 1.0) 
C     IF (PRES.LT.0.0) PRES = 0.0 
C     VADCRX = PRES 
C 
C   CONVERT, PUT THE NUMBER OF CHARACTERS INTO A DUMMY VARIABLE 
C            (IT WON'T BE NEEDED) 
C 
C342  CONTINUE
C 
C************NOTE: ABOVE CODE REPLACED WITH SUBROUTINE CALL 
C 
      CALL RXV2T(IA,VADC,VADCRX)  
      NCHB= NCH + IR2AS(VADCRX,IBUF2,NCH,10,3)  
C 
C   PUT ONLY 4 SIGNIFICANT DIGITS + A DECIMAL POINT (+ A MINUS  
C                                   SIGN IF NEGATIVE) 
C 
C   THIS IS MADE SIMPLE BY THE FACTS THAT IR2AS LEFT JUSTIFIES
C   AND THAT ALL THE NUMBERS WE WORK HAVE THE LEAST SIGNIFICANT 
C   DIGIT TO THE LEFT OF THE .0001 DECIMAL PLACE
C   OTHERWISE WE WOULD NEED LOGS OR SOMETHING 
C 
      NCH = NCH + 5 
      IF(VADCRX.LT.0) NCH=NCH+1 
C 
C   MOVE IN THE UNITS 
C 
C345  CONTINUE
C     REMOVE UNITS SO THAT LOGEX DOESN'T GET CONFUSED!
C     NCH = ICHMV(IBUF2,NCH,LUNITS(IA),1,2) 
C 
C 
C     5. Now send the buffer to BOSS for logging. 
C 
500   ICLASS = 0
      NCH = NCH - 1 
      CALL EXEC(20,0,IBUF2,-NCH,2HFS,0,ICLASS)  
C 
980   IP(1) = ICLASS
      IP(2) = 1 
      IP(3) = IERR
      IP(4) = 2HQB
      IP(5) = 0 
990   RETURN
      END 
