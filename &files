FTN4,X  
C 
C 
      PROGRAM FILES(6,1),BRS C#840614:13:33# TRANSFER FILES TO THE HP 
     .<840614.1332> 
C 
C     TRANSFER A FILE TO THE HP FROM SOMEWHERE ELSE 
C 
C     LUCNTL IS THE LU THAT THE PROGRAM WILL ACCEPT COMMANDS FROM.
C     IT IS DEFINED TO BE THE LU THAT THE PROGRAM IS RUN FROM.
C 
C     LU IS WHERE THE FILE IS ACCEPTED FROM.  LU IS SPECIFIED 
C     AS THE FIRST RMPAR PARAMETER.  IF IT IS NOT SPECIFIED,
C     IT IS SET TO LUCNTL.
C 
C     IMPORTANT NOTE - LU may NOT be the system console. The program will 
C                      check this condition.
C 
C     ANOTHER IMPORTANT NOTE - LU absolutely must be on DVF00 
C                              (or one of its clones that support 
C                              a read without master reset of the 
C                              12966A card).  The program cannot check
C                              this condition.  If LU is not on DVF00,
C                              I don't have the faintest idea what will 
C                              happen (aside from the program not working), 
C                              but I suspect you won't like it. 
C 
C     THE FILE ACCEPTANCE IS ENDED BY A SPECIAL RECORD. 
C     IF NOT OTHERWISE SPECIFIED, A NULL RECORD (NO CHARACTERS, JUST
C     A CR) WILL FORCE THE FILE TO BE CLOSED.  THE ALTERNATE MEANS
C     OF TERMINATING THE FILE IS BY A RECORD CONTAINING A SINGLE
C     CHARACTER (PLUS A CR, NATURALLY).  THIS CHARACTER MAY BE
C     SPECIFIED AS THE SECOND RMPAR PARAMETER.
C 
C     The file acceptance may also be ended by an operator break. 
C     Type BR,FILES and wait for the pending read to complete (or timeout). 
C 
C     THE USER WILL BE PROMPTED ON LUCNTL FOR THE NAME OF THE 
C     FILE TO BE STORED INTO.  UNLESS OTHERWISE SPECIFIED,
C     THIS WILL BE A TYPE 4 FILE OF LENGTH 20 BLOCKS. 
C 
C     It is strongly recommended that the file be received to a hard
C     disc rather then a floppy.  The floppy is simply too slow.
C     If you use a floppy, you probably will lose information.
C 
C     Bruce R. Schupler 821121
C     Last revision - BRS <840614.1332> 
C 
      DIMENSION IDCB(528),IBUF(200),IPBUF(10),ISIZE(2),IAB(2) 
      DIMENSION IMPAR(5)
      EQUIVALENCE (ISIZE(1),IPBUF(8)),(IAB(1),RETRN)
C 
      LOGICAL LMBROK,LBADNM 
C 
      DATA JREADS /0/ 
      DATA ICLAS /0/
      DATA LEND /0/ 
      DATA LMBROK,LBADNM /2*.FALSE./
C 
C     WHO DO WE TALK TO?
C 
      CALL RMPAR(IMPAR) 
      LU = IMPAR(1) 
      LUCNTL = LOGLU(IDUM)
      IF(LU .EQ. 0) LU = LUCNTL 
C 
      CALL LIBER(LUCNTL)
C 
C     BE CERTAIN THAT LU ISN'T THE SYSTEM CONSOLE 
C 
      IF(LUTRU(LU) .EQ. 1) WRITE(LUCNTL,10) 
10    FORMAT("File may not be received from the system console.",/, 
     .       "Transfer terminated") 
      IF(LUTRU(LU) .EQ. 1) STOP 1 
      IF(LUTRU(LU) .LT. 0) WRITE(LUCNTL,15) LU
15    FORMAT("LU ",I4," not in current SST.  Transfer terminated")
      IF(LUTRU(LU) .LT. 0) STOP 2 
C 
C     WHAT IS THE END CHARACTER?  THE TRANSFER ENDS WITH A SINGLE CHARACTER 
C     RECORD CONTAINING THIS CHARACTER OR WITH A NULL RECORD IF THIS CHARACTER
C     IS NOT SPECIFIED.  IT MAY BE SPECIFIED IN THE RUN STRING IN OCTAL.
C     IF IT IS A PRINTING CHARACTER, JUST TYPE IT.
C 
      IF(IMPAR(2) .NE. 0 .AND. IMPAR(2) .GT. 377B) LEND = IAND(177400B, 
     .                                                         IMPAR(2))
      IF(IMPAR(2) .NE. 0 .AND. IMPAR(2) .LE. 377B) LEND = IAND(177400B, 
     .                                              ISHFT(IMPAR(2),8))
C 
C     WHAT FILE DO WE DUMP INTO?
C 
      WRITE(LUCNTL,20)
20    FORMAT("What is the complete NAMR you want to store into? _") 
      IF(IFNAM(LUCNTL,IPBUF) .LE. 0) LBADNM = .TRUE.
      IF(LBADNM) WRITE(LUCNTL,25) 
25    FORMAT("Invalid NAMR.  Transfer terminated.") 
      IF(LBADNM) STOP 3 
C 
C     IF NOT SPECIFIED, TYPE 4 FILE WITH 20 BLOCKS
C 
      IF(IPBUF(7) .EQ. 0) IPBUF(7) = 4
      IF(IPBUF(8) .EQ. 0) IPBUF(8) = 20 
C 
C     TRY TO CREATE THE OUTPUT FILE AFTER CHANGING THE FILE NAME TO 
C     UPPER CASE
C 
      CALL UP(IPBUF,3)
      CALL CREAT(IDCB,IERR,IPBUF(1),ISIZE,IPBUF(7),IPBUF(5),
     .           IPBUF(6),528)
      IF(IERR .LT. 0) WRITE(LUCNTL,30) IERR 
30    FORMAT("Error ",I4," creating output file") 
      IF(IERR .LT. 0) STOP 4  
      IERR = 0
C 
C     LOCK OURSELF INTO MEMORY
C 
      CALL EXEC(22,1) 
C 
C     SAY THE FILE WAS CREATED
C 
      WRITE(LUCNTL,40)
40    FORMAT("Output file created properly")
C 
C     SET ICNWD SO THAT MASTER RESET IS INHIBITED 
C     THE ECHO BIT IS OFF SO THE INTERFACE BUFFER DOESN'T 
C     GET CLOBBERED 
C 
      ICNWD = 200B + LU 
C 
C     DISABLE THE TERMINAL SO THAT WE DON'T GET SPURIOUS INTERRUPTS 
C     AFTER WAITING A SECOND SO THAT ALL OF THE PRECEDING 
C     MESSAGE HAS BEEN SENT 
C 
      CALL SUSP(2,1)  
      CALL CN21(LU) 
C 
C     LOCK THE LU SO THERE IS NO INTERFERENCE 
C 
      CALL LURQ(1,LU,1) 
C 
C     SAY GO
C 
      IF(LEND .EQ. 0) WRITE(LUCNTL,50)
50    FORMAT("Start sending data (null record", 
     .       " ends transmission)") 
      IF(LEND .NE. 0) WRITE(LUCNTL,60) LEND,LEND
60    FORMAT("Start sending data (record containing only """,A1,"""[=", 
     .       O6,"B ends transmission])")
C 
C     GET THE CLASS I/O PREPARED
C 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
C 
C     SAVE THE CLASS NUMBER THAT WE GOT 
C 
      ICLAS = IOR(20000B,ICLAS) 
C 
C     GET A FEW MORE READS QUEUED UP
C 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      JREADS = JREADS + 1 
C 
C     LOOP TO DO READS & THE CORRESPONDING NUMBER OF GETS 
C 
100   CONTINUE
      CALL EXEC(17,ICNWD,IBUF,-400,IDUM,IDUM,ICLAS) 
      RETRN = EXEC(21,ICLAS,IBUF,-400)
      IF(IAB(2) .EQ. 0 .AND. LEND .EQ. 0) GO TO 200 
      IBUF1 = IAND(IBUF(1),177400B) 
      IF(IAB(2) .EQ. 1 .AND. LEND .EQ. IBUF1 .AND. LEND .NE. 0) 
     .        GO TO 200 
C 
C     IF ODD NUMBER OF CHARACTERS, PAD THE LAST ONE TO BE A BLANK 
C 
      IWORDS = IAB(2) / 2 
      IF (2*IWORDS .NE. IAB(2)) CALL PUTC(IBUF,IAB(2)+1,40B)
      IF (2*IWORDS .NE. IAB(2)) IWORDS = IWORDS + 1 
      CALL WRITF(IDCB,IERR,IBUF,IWORDS) 
      IF(IERR .NE. 0) GO TO 200 
      IF(IFBRK(IDUM) .NE. 0) LMBROK = .TRUE.
      IF (LMBROK) GO TO 200 
      GO TO 100 
C 
C     END OF DATA 
C 
200   CONTINUE
C 
C     OK, NOW LET'S CLEANUP THE CLASS NUMBERS AND BUFFERS 
C 
C     SET THE TIMEOUT OF LU TO BE VERY SHORT
C 
      ISAVE = ITOX(LU,1)
C 
C     DO ENOUGH GETS TO CLEAR THE QUEUE 
C 
      DO 210 J=1,JREADS 
      IF(J .EQ. JREADS) ICLAS = IAND(157777B,ICLAS) 
210   CALL EXEC(21,ICLAS,IBUF,-400) 
C 
C     SET THE TIMEOUT BACK TO IT'S OLD VALUE
C 
      IDUM = ITOX(LU,ISAVE) 
C 
C     CLOSE THE FILE AND GO HOME
C 
      CALL CLOSE(IDCB,IDUM,0) 
C 
      IF(IERR .NE. 0) WRITE(LUCNTL,220) IERR
220   FORMAT("Error ",I6," writing file.  Transfer terminated") 
C 
      IF(IERR .EQ. 0 .AND. (.NOT. LMBROK)) WRITE(LUCNTL,230) IPBUF(1),
     .                                     IPBUF(2),IPBUF(3),IPBUF(5),
     .                                     IPBUF(6) 
230   FORMAT("Normal termination of file ",3A2,":",I6,":",I6) 
C 
      IF(IERR .EQ. 0 .AND. (LMBROK)) WRITE(LUCNTL,240)
240   FORMAT("Termination forced by operator break")
C 
C     REENABLE THE TERMINAL 
C 
      CALL EXEC(3,2000B+LU) 
C 
      END 
C 
C 
      FUNCTION ITOX(LU,IVAL),Get/change time-out of lu in EQT14/15
C 
C     CHANGE TIME-OUT VALUE OF LU TO IVAL.
C     ITOX RETURNS VALUE OF TIME-OUT BEFORE CHANGE. 
C     IF IVAL<0, ITOX RETURNS CURRENT TIME-OUT VALUE ONLY.
C     IF ILLEGAL LU, ITOX RETURNS =-1.
C 
C     ARW 781208
C     BRS 810727
C 
      ITOX=-1 
C     CHECK VALIDITY OF LU
      IF (LU .LT. 1 .OR. LU .GT. IGETS(1653B)) RETURN 
C 
C     GET EQT# FROM DEVICE REFERENCE TABLE
      IEQT=IAND(IGETS(IGETS(1652B)+LU-1),77B) 
C 
C     CHECK LEGAL EQT#
      IF (IEQT .LT. 1 .OR. IEQT .GT. IGETS(1651B)) RETURN 
C 
C     COMPUTE EQT14 AND EQT15 ADDRESSES 
      IEQT14=IGETS(1650B)+(IEQT-1)*15+13
      IEQT15=IGETS(1650B)+(IEQT-1)*15+14
C 
C     GET CURRENT TIME-OUT VALUE
      ITOX=-IGETS(IEQT14)-1 
      IF (ITOX .LT. 0) ITOX=0 
C 
C     SET NEW TIME-OUT VALUE
      JTO=0 
      IF (IVAL) 120,110,100 
100   JTO=-IVAL-1 
110   CALL PUTS(IEQT14,JTO) 
      IF(IGETS(IEQT15) .NE. 0) CALL PUTS(IEQT15,JTO)
120   RETURN
      END 
      SUBROUTINE UP(IBUF,ILEN),Change all characters to upper-case BRS
     1C#840614:13:33# 
C 
C     CHANGE FIRST ILEN*2 ALPHABETIC CHARACTERS IN IBUF TO UPPER-CASE.
C     ARW 801119
C     BRS 820108
C 
      DIMENSION IBUF(1) 
      IF (ILEN .LE. 0) RETURN 
      IDO = 2 * ILEN
      DO 100 I=1,IDO
      IC=IGETC(IBUF,I)
      IF (IC .GE. 141B .AND. IC .LE. 172B) CALL PUTC(IBUF,I,IC-40B) 
100   CONTINUE
      RETURN
      END 
