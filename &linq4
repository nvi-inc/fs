ASMB,R,B
      HED   LINQ CONTROLLER 
* 
* LINQ IS A GENERAL SEGMENT CONTROLLER WHICH ALLOWS THE USER TO CALL
* SPECIFIC SUBROUTINES IN A SEGMENT AND TO PASS AN ARGUMENT LIST BY 
* ADDRESS TO THE SUBROUTINE IN THE SEGMENT.  A SEGMENT IS RETAINED IN 
* CORE UNTIL IT IS NECESSARY TO GET A DIFFERENT SEGMENT.
* 
* THE USER CALL TO LINQ IS AS FOLLOWS:
* 
*   IN THE ROOT:
* 
*      CALL LINQA(NSEG,NAMSEG,NSUB,NARG,ARG1,ARG2,...)
* 
*   IN A SEGMENT: 
* 
*      CALL LINQS(NSEG,NAMSEG,NSUB,0) 
* 
* WHERE NSEG = SEGMENT NUMBER (ARBITRARY, ASSIGNED BY USER) 
*       NAMSEG = SEGMENT NAME (ASSIGNED BY USER)
*       NSUB = SUBROUTINE NUMBER (ARBITRARY, ASSIGNED BY USER)
*       NARG = NUMBER OF ARGUMENTS (PRESENTLY <= 15, CHANGE THE LINE
*                                   IARGS BSS  15 FOR DIFFERENT LIMIT)
*       ARG1,ARG2,... = ARGUMENTS FOR SUBROUTINE
* 
* THE MAIN PROGRAM IN A SEGMENT HAS THE FOLLOWING FORM: 
* 
*      PROGRAM SEGNN,5
*      CALL LINQB(NSUB) 
*      IF(NSUB.EQ.1) GO TO 100
*      IF(NSUB.EQ.2) GO TO 200
*      ...
*100   CALL LINQC 
*      CALL SUBR1(ARG1,ARG2,...)
*      CALL LINQD 
*200   CALL LINQC 
*      CALL SUBR2(ARG1,ARG2,...)
*      CALL LINQD 
*      ...
*      END
* 
* ENTRY LINQA SAVES THE ARGUMENT VECTOR AND OTHER INFORMATION INTERNALLY
* BEFORE GETTING THE SEGMENT (IF IT IS NOT IN CORE) OR TRANSFERRING DIRECTLY
* TO THE SEGMENT (IF IT IS ALREADY IN CORE).  THE SEGMENT NUMBER IS USED
* TO CHECK IF THE SEGMENT IS ALREADY IN CORE.  THE USER MUST MAKE SURE
* THAT THE SEGMENT NUMBER AND SEGMENT NAME CORRESPONDENCE IS MAINTAINED.
* 
* ENTRY LINQS IS IDENTICAL TO LINQA EXCEPT THAT IT IS USED TO CALL A
* DIFFERENT SEGMENT FROM A LOADED SEGMENT AND NO ARGUMENTS (CURRENTLY)
* CAN BE PASSED.  LINQA MUST NOT BE USED WITHIN A SEGMENT!!!
* 
* ENTRY LINQB PASSES THE SUBROUTINE NUMBER TO THE SEGMENT MAIN PROGRAM AND
* SETS UP THE ADDRESS FOR DIRECT TRANSFER TO THE SEGMENT.  ENTRY LINQB
* SHOULD BE CALLED AS THE FIRST EXECUTABLE STATEMENT OF THE SEGMENT MAIN. 
* ANY STATMENTS WHICH PRECEDE THE CALL TO LINQB WILL ONLY BE EXECUTED 
* IMMEDIATELY AFTER THE SEGMENT IS LOADED.  THE SUBROUTINE NUMBER IS USED 
* TO SELECT WHICH OF SEVERAL SUBROUTINES IS TO BE EXECUTED. 
* 
* ENTRY LINQC TRANSFERS THE SAVED ARGUMENT LIST TO THE REAL CALL TO THE 
* ACTUAL EXECUTED SUBROUTINE.  THE CALL TO THE SUBROUTINE MUST HAVE THE 
* CORRECT NUMBER OF ARGUMENTS AND MUST IMMEDIATELY FOLLOW THE CALL TO 
* LINQC.
* 
* ENTRY LINQD RETURNS TO THE USER ROOT PROGRAM AT THE POINT FOLLOWING THE 
* CALL TO LINQA.
* 
      NAM   LINQ,7 SEGMENT SUBROUTINE LINQER (780801 CM)
      ENT   LINQA,LINQB,LINQC,LINQD,LINQS 
      EXT   .ENTR,EXEC
LINQZ BSS   1          LINQA RETURN ADDRESS 
ASFLG DEC   -1         ROOT SEGMENT LINQA LINQS FLAG
IA    DEF   IARGS      ADDRESS OF SAVED ARGUMENT ADDRESS VECTOR 
NSEG  BSS   1          CURRENT SEGMENT NUMBER IN CORE 
D8    DEC   8          LITERAL FOR EXEC(8,NAMSEG) 
* 
ISEG  BSS   2          ADDRESSES OF SEGMENT NUMBER AD NAME
ISUB  BSS   1          ADDRESS OF SUBROUTINE NUMBER 
INARG BSS   1          ADDRESS OF NUMBER OF ARGUMENTS 
IARGS BSS   15         ARGUMENTS OF ACTUAL SUBROUTINE TO BE EXECUTED
* 
LINQA NOP              ENTRY TO PASS INFORMATION FROM ROOT CALL 
      JSB   .ENTR      GET ADDRESSES FROM CALLING SEQUENCE
      DEF   ISEG       SAVE IN VECTOR STARTING AT ISEG
      ISZ   ASFLG      CHECK FLAG FOR ROOT OR SEGMENT CALL
      JMP   *+3        SEGMENT CALL 
      LDA   LINQA      ROOT CALL
      STA   LINQZ      SAVE RETURN ADDRESS IN ROOT OF LINQA CALL
      LDA   =D-1       RESET ROOT SEGMENT FLAG
      STA   ASFLG      TO INTIAL VALUE FOR NEXT LINQA/LINQS CALL
      LDA   ISUB,I     GET SUBROUTINE NUMBER
      STA   ISUB       SAVE INTERNALLY
      LDA   INARG,I    GET NUMBER OF ARGUMENTS
      STA   INARG      SAVE INTERNALLY
      LDA   ISEG,I     GET SEGMENT NUMBER 
      CPA   NSEG       COMPARE WITH CURRENT SEGMENT NUMBER
      JMP   SAMQ       SEGMENT ALREADY IN CORE - TRANSFER SUBROUTINE NUMBER 
DIFQ  STA   NSEG       SEGMENT NOT IN CORE - SAVE NEW SEGMENT NUMBER
      LDA   ISEG+1     GET ADDRESS OF SEGMENT NAME
      STA   *+4        STORE IN  EXEC CALLING SEQUENCE
      JSB   EXEC       CALL EXEC(8,NAMSEG) TO GET SEGMENT INTO CORE 
      DEF   *+3 
      DEF   D8
      BSS   1 
* 
ILSUB BSS   1          ADDRESS OF SUBROUTINE NUMBER IN SEGMENT MAIN 
LINQB NOP              ENTRY TO PASS SUBROUTINE NUMBER TO SEGMENT AND 
*                      TO SAVE DIRECT TRANSFER ADDRESS
      JSB   .ENTR      GET SUBROUTINE NUMBER ADDRESS IN SEGMENT MAIN
      DEF   ILSUB 
SAMQ  LDA   ISUB       GET SUBROUTINE NUMBER FROM INTERNAL STORAGE
      STA   ILSUB,I    STORE IN SEGMENT MAIN
      JMP   LINQB,I    RETURN TO SEGMENT MAIN 
* 
LINQC NOP              ENTRY TO TRANSFER ARGUMENT ADDRESS VECTOR TO ACTUAL
*                      CALL IN SEGMENT MAIN 
      JSB   .ENTR      GET LOCATION OF CALL TO LINQC
      DEF   *-2 
      LDB   LINQC      LOAD LOCATION IMMEDIATELY AFTER CALL TO LINQC
      ADB   =D2        INCREMENT TO REFERENCE CALLING SEQUENCE OF REAL CALL 
      LDA   IA         LOAD ADDRESS OF ARGUMENT ADDRESS VECTOR
      MVW   INARG      TRANSFER PROPER NUMBER OF ADDRESSES TO REAL CALL 
      JMP   LINQC,I    RETURN TO SEGMENT MAIN 
* 
LINQD NOP              ENTRY TO RETURN TO ORIGINAL LINQA CALL 
      JMP   LINQZ,I    RETURN VIA SAVED RETURN ADDRESS
* 
LINQS NOP              ENTRY TO CALL ANOTHER SEGMENT FROM WITHIN A SEGMENT
      LDA   LINQS      GET CALLING ADDRESS
      STA   LINQA      STORE IN LINQA ENTRY TO REUSE CODE 
      LDA   =D0        SET FLAG FOR CALL FROM SEGMENT 
      STA   ASFLG 
      JMP   LINQA+1    JUMP TO LINQA FOR ACTUAL EXECUTION 
* 
      END 
