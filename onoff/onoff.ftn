FTN77,I,Y  
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      PROGRAM ONOFF(3,48),ONOFF CONTROL PROGRAM C#870115:05:24# 
C 
C   SOURCE RADIOMETERY PROGRAM
C 
C This program utilizes the Field System and is highly dependent on it. 
C 
C 
      DOUBLE PRECISION AVG1,AVG2,SIG1,SIG2,DTEMP1,DTEMP2,DRI,DIM1 
      DOUBLE PRECISION DRDRM1,TSYAV1,TSYAV2,TSYSI1,TSYSI2 
      DIMENSION LBUF(40),IT(6)
C 
D     DIMENSION OFFO(31)
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
      INCLUDE /FS/INCLUDE/DPI.FTNI
C 
C NOTE: THE FOLLOWING VARIABLES ARE READ FROM THE FSCOM:
C 
C       XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF,
C       DIAMAN, 
C       NREPNF, INTPNF, LDV1NF, LDV2NF, FRQ1NF, FRQ2NF, CTOFNF
C       CAL1NF, CAL2NF
C 
C       ADDITONALLY, CHECK THE CALLED SUBROUTINES 
C 
      DIMENSION VONS(2),VOFS(2),VCAL(2),SIGONS(2),SIGOFS(2),SIGCAL(2) 
      DIMENSION VZER(2),SIGZER(2) 
C 
      DATA NWAIT/30/,LWHO/2HNF/ 
      DATA IERR/0/,VONOFF/1.00/,ISBUF/80/ 
C
C  GET RID OF ANY BREAKS THAT WERE HANGING AROUND
C
      IF(IFBRK(IDUM).LT.0) GO TO 1
1     CONTINUE
C
C   0. Set-up and do preliminary work
C
C        Beamwidth Calculation
C
      BW1 = BM1NF_FS
      BW2 = BM2NF_FS
      BW= AMAX1(BW1,BW2)
      ISGN=1
C
D     ORA=RADAT*180./PI
D     ODEC=DECDAT*180./PI
D     WRITE(LU,991) ORA,ODEC
D991  FORMAT(" ONOFF: RA, DEC ",2F12.3)
C
C        Write SOURCE, SITE, and ONOFF log entries
C 
      CALL EXEC(11,IT,IT(6))
      RUT=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.0+FLOAT(IT(2)) 
      CALL SORCE(RUT,IT(5),IT(6),LBUF,ISBUF)
      CALL SITE(VONOFF,LBUF,ISBUF)
      CALL ONOF(LBUF,ISBUF) 
C 
C        Save old offsets 
C 
      XOSAV=XOFF
      YOSAV=YOFF
      AZOSAV=AZOFF
      ELOSAV=ELOFF
      HAOSAV=-RAOFF 
      DCOSAV=DECOFF 
C 
      CALL ORIGN(XOSAV,YOSAV,AZOSAV,ELOSAV,HAOSAV,DCOSAV,LBUF,ISBUF)
C 
      NWT=NWAIT 
      IF(IPGST(6HAQUIR ).LE.0) NWT=300
      CALL ONSOR(NWT,IERR)
      IF(IERR.NE.0) GO TO 80010 
C 
C MAKE SURE THE CAL IS OFF
C 
      CALL SCMDS(8HCALOFFNF,8)  
C 
C  REMEMBER WHERE WE ARE
C 
      CALL LOCAL(AZ,EL,4HAZEL,IERR) 
      IF(IERR.NE.0) GO TO 80010 
      COSEL=COS(EL) 
C 
D     OEL=EL*180./PI
D     OAZ=AZ*180./PI
D     WRITE(LU,9855) OAZ,OEL,COSEL
D9855 FORMAT(3F20.10) 
C 
C    MAIN LOOP
C 
      AVG1=0
      AVG2=0
      SIG1=0
      SIG2=0
      TSYAV1=0
      TSYAV2=0
      TSYSI1=0
      TSYSI2=0
      DO 10 I=1,NREPNF
C 
C   2.ON SOURCE POINT 
C 
      CALL VLTS2(VONS,SIGONS,TMONS,INTPNF,RUT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
      CALL DPNT2(4HON  ,4,I,TMONS,0.0,0.0,VONS,SIGONS,INTPNF,LBUF,ISBUF)
C 
      ISGN=-ISGN
      IF(EL.GT.CTOFNF) GO TO 20 
      ASTEP=(ISGN*BW*STEPNF)/COSEL
      ESTEP=0.0 
      GO TO 30
C 
20    CONTINUE
      ASTEP=0.0 
      ESTEP=ISGN*BW*STEPNF
C 
30    CONTINUE
D     WRITE(LU,9956) ASTEP,ESTEP,BW 
D9956  FORMAT("ASTEP, ESTEP, BW = ",3E12.6) 
      CALL GOOFF(AZOSAV+ASTEP,ELOSAV+ESTEP,4HAZEL,NWAIT,IERR) 
      IF(IERR.NE.0) GO TO 80010
C
      CALL VLTS2(VOFS,SIGOFS,TMOFS,INTPNF,RUT,IERR)
D     WRITE(LU,9957) VOFS,SIGOFS
D9957  FORMAT(" VOFS, SIGOFS = ",4F15.1)
      IF(IERR.NE.0) GO TO 80010
      CALL DPNT2(4HOFF ,4,I,TMOFS,ASTEP,ESTEP,VOFS,SIGOFS,INTPNF,LBUF,
     +           ISBUF)
C
C       TURN CAL ON
C
      CALL SCMDS(8HCALONNF ,7)
      CALL VLTS2(VCAL,SIGCAL,TMCAL,INTPNF,RUT,IERR)
      IF(IERR.NE.0) GO TO 80010
C
      CALL DPNT2(4HCAL ,4,I,TMCAL,ASTEP,ESTEP,VCAL,SIGCAL,INTPNF,LBUF,
     +            ISBUF)
C
C  TURN CAL OFF
C
      CALL SCMDS(8HCALOFFNF,8)
C
      DTEMP1=CAL1NF*((VONS(1)-VOFS(1))/(VCAL(1)-VOFS(1)))
      DTEMP2=CAL2NF*((VONS(2)-VOFS(2))/(VCAL(2)-VOFS(2)))
D     WRITE(LU,9958) DTEMP1,DTEMP2
D9958 FORMAT(" DTEMP1, DTEMP2 = ",2F10.1)
      DRI=1.D0/DBLE(FLOAT(I))
      DIM1=DBLE(FLOAT(I-1))
      AVG1 =(AVG1*DIM1+DTEMP1)*DRI
      AVG2 =(AVG2*DIM1+DTEMP2)*DRI
      SIG1 =(SIG1*DIM1+DTEMP1*DTEMP1)*DRI
      SIG2 =(SIG2*DIM1+DTEMP2*DTEMP2)*DRI
C
      IF(I.GT.1) GO TO 9
      CALL TZER(VZER,SIGZER,TMZER,INTPNF,RUT,IERR)
      IF(IERR.NE.0) GO TO 80010
      CALL DPNT2(4HZERO,4,I,TMZER,ASTEP,ESTEP,VZER,SIGZER,INTPNF,
     +           LBUF,ISBUF)
C
9     CONTINUE
      DTEMP1=CAL1NF*((VOFS(1)-VZER(1))/(VCAL(1)-VOFS(1))) 
      DTEMP2=CAL2NF*((VOFS(2)-VZER(2))/(VCAL(2)-VOFS(2))) 
      TSYAV1 =(TSYAV1*DIM1+DTEMP1)*DRI
      TSYAV2 =(TSYAV2*DIM1+DTEMP2)*DRI
      TSYSI1 =(TSYSI1*DIM1+DTEMP1*DTEMP1)*DRI 
      TSYSI2 =(TSYSI2*DIM1+DTEMP2*DTEMP2)*DRI 
      CALL GOOFF(AZOSAV,ELOSAV,4HAZEL,NWAIT,IERR) 
      IF(IERR.NE.0) GO TO 80010 
C 
C    LOOP BACK FOR MORE REPITIONS 
C
10    CONTINUE
C
      CALL LOCAL(AZ2,EL2,4HAZEL,IERR)
      IF(IERR.NE.0) GO TO 80010
      IF(AZ2.GT.PI*1.5.AND.AZ .LT.PI*.5) AZ2=AZ2-2.*PI
      IF(AZ .GT.PI*1.5.AND.AZ2.LT.PI*.5) AZ =AZ -2.*PI
      AZ=(AZ+AZ2)*.5
      EL=(EL+EL2)*.5
C
      IF(NREPNF.GT.1) GO TO 50
      SIG1=0
      SIG2=0
      TSYSI1=0
      TSYSI2=0
      GO TO 60
C
50    CONTINUE
      DRDRM1=DBLE(FLOAT(NREPNF))/DBLE(FLOAT(NREPNF-1))
      SIG1=DSQRT(DABS(SIG1-AVG1*AVG1)*DRDRM1)
      SIG2=DSQRT(DABS(SIG2-AVG2*AVG2)*DRDRM1)
      TSYSI1=DSQRT(DABS(TSYSI1-TSYAV1*TSYAV1)*DRDRM1)
      TSYSI2=DSQRT(DABS(TSYSI2-TSYAV2*TSYAV2)*DRDRM1)
C
60    CONTINUE
      SAVG1=TSYAV1
      SAVG2=TSYAV2
      SSIG1=TSYSI1
      SSIG2=TSYSI2
      CALL RESLT(8HTSYS    ,7,10H          ,10,AZ,EL,SAVG1,SAVG2,SSIG1,
     +           SSIG2,NREPNF,LBUF,ISBUF)
      SAVG1=AVG1
      SAVG2=AVG2
      SSIG1=SIG1
      SSIG2=SIG2
      CALL RESLT(8HSIGNAL  ,7,LSORNA,10,AZ,EL,SAVG1,SAVG2,SSIG1,
     +           SSIG2,NREPNF,LBUF,ISBUF)
C
      SDC1=AVG1/CAL1NF
      SDC1S=SIG1/CAL1NF
      SDC2=AVG2/CAL2NF
      SDC2S=SIG2/CAL2NF
      CALL RESLT(8HSRC/CAL ,7,LSORNA,10,AZ,EL,SDC1,SDC2,SDC1S,SDC2S,
     +           NREPNF,LBUF,ISBUF)
      FX1=MAX(FX1NF_FS,0.0)
      FX2=MAX(FX2NF_FS,0.0)
      SEFD1=0.0
      SEFD2=0.0
      SEFD1S=0.0
      SEFD2S=0.0
      IF(AVG1.GT.1E-6.AND.FX1.GT.0.0) THEN
        SEFD1=TSYAV1*(FX1/AVG1)
        SEFD1S=(FX1/AVG1)*SQRT(TSYSI1**2+(SIG1*(TSYAV1/AVG1))**2)
      ENDIF
      IF(AVG2.GT.1E-6.AND.FX1.GT.0.0) THEN
        SEFD2=TSYAV2*(FX2/AVG2)
        SEFD2S=(FX2/AVG2)*SQRT(TSYSI2**2+(SIG2*(TSYAV2/AVG2))**2)
      ENDIF
      IF(FX1NF_FS.GT.0.0.OR.FX2NF_FS.GT.0.0) THEN
        CALL RESLT(8HSEFD    ,7,LSORNA,10,AZ,EL,SEFD1,SEFD2,SEFD1S,
     +             SEFD2S,NREPNF,LBUF,ISBUF)
      ENDIF
      AE1=0.0D0
      AE2=0.0D0
      AE1S=0.0D0
      AE2S=0.0D0
      IF(FX1.GT.1E-6.AND.AVG1.GT.1E-6) THEN
        AE1 =AVG1*2.0*1.380662E0/(FX1*1E-3*DPI*(DIAMAN/2.0)**2)
        AE1S=SIG1*2.0*1.380662E0/(FX1*1E-3*DPI*(DIAMAN/2.0)**2)
      ENDIF
      IF(FX2.GT.1E-6.AND.AVG2.GT.1E-6) THEN
        AE2 =AVG2*2.0*1.380662E0/(FX2*1E-3*DPI*(DIAMAN/2.0)**2)
        AE2S=SIG2*2.0*1.380662E0/(FX2*1E-3*DPI*(DIAMAN/2.0)**2)
      ENDIF
      IF(FX1NF_FS.GT.0.OR.FX2NF_FS.GT.0) THEN
        CALL RESLT(8HETA     ,7,LSORNA,10,AZ,EL,AE1,AE2,AE1S,
     +             AE2S,NREPNF,LBUF,ISBUF)
        EDTS1=1000.*AE1/TSYAV1
        EDTS1S=SQRT(AE1S**2+(TSYSI1/TSYAV1)**2)*1000./TSYAV1
        EDTS2=1000.*AE2/TSYAV2
        EDTS2S=SQRT(AE2S**2+(TSYSI2/TSYAV2)**2)*1000./TSYAV2
        CALL RESLT(8H1k*E/TS ,7,LSORNA,10,AZ,EL,EDTS1,EDTS2,
     +             EDTS1S,EDTS2S,NREPNF,LBUF,ISBUF)
      ENDIF
      GO TO 90000
C
C   ERROR
C
80010 CONTINUE
      XOFF=XOSAV
      YOFF=YOSAV
      AZOFF=AZOSAV
      ELOFF=ELOSAV
      RAOFF=-HAOSAV
      DECOFF=DCOSAV
      ITRY=2
C
80011 CONTINUE
      JERR=0
      CALL GOOFF(AZOSAV,ELOSAV,4HAZEL,NWAIT,JERR) 
      ITRY=ITRY-1 
      IF(JERR.GT.0.AND.ITRY.GT.0) GO TO 80011 
C 
      IF(IERR.GT.0) GO TO 89990 
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IERR,LWHO,2HER)
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-100,LWHO,2HER)
      GO TO 90000 
C 
C BREAK DETECTED
C 
89990 CONTINUE
      IERR=-1 
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IERR,LWHO,2HBR)
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-100,LWHO,2HER)
      GO TO 90000 
C 
C CLEAN UP AND EXIT 
C 
90000 CONTINUE
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ONSOR(NWAIT,IERR)
      DIMENSION IT(5) 
C 
C  WAIT FOR ONSOURCE CONDITION
C 
C  INPUT: 
C 
C         NWAIT  = NUMBER OF SECONDS TO WAIT AT MOST FOR CONDITION
C               < 0 MEANS WAIT INDEFINITELY 
C  OUTPUT:
C 
C        IERR = 0 IF NO ERROR OCCURRED
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C         IONSOR
C 
C  MAIN LOOP
C 
D     CALL EXEC(2,LU,14HENTERING ONSOR,-14) 
      CALL EXEC(11,IT)
      TIM=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.+FLOAT(IT(2))
10    CONTINUE
C 
C  TRY TO DETERMINE ONSOURCE STATUS 
C 
      CALL ANTCN(5,IERR)
      IF(IERR.NE.0) RETURN
      IF(IONSOR.NE.0) RETURN
C     IF(NWAIT.NE.0) CALL SUSP(2,1) 
      CALL EXEC(11,IT)
      TIM2=FLOAT(IT(4))*3600.+FLOAT(IT(3))*60.+FLOAT(IT(2)) 
      IF(TIM2.LT.TIM) TIM2=TIM2+86400.
      IF(TIM2.LT.TIM+FLOAT(NWAIT).OR.NWAIT.LT.0) GO TO 10 
C 
C  DIDN'T REACH ONSOURCE
C 
      IERR=-20
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE LOCAL(LONPOS,LATPOS,LAXIS,IERR)
      REAL LONPOS,LATPOS
C 
C  GET LOCAL ANTENNA COORDINATES
C 
C  OUTPUT:
C 
C         LONPOS = CALCULATED LONGITUDE-LIKE COORDINATE 
C 
C         LATPOS = CALCULATED LATITUDE-LIKE COORDINATE
C 
C         IERR = 0 IF NO ERROR OCCURRED 
C 
       DOUBLE PRECISION DLAT,DLON,RA,DEC,AZ,EL,X,Y,DHA,DPI,REFR 
       DIMENSION IT(6)
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C        XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, LAXNF, RADAT, DECDAT
C 
      DATA DPI/3.141592653589D0/
C 
C  CALCULATE THE POSITION IN THE LOCAL X/Y NS SYSTEM
C 
D     CALL EXEC(2,LU,14HENTERING LOCAL,-14) 
D     ORA=RADAT*180./PI 
D     ODC=DECDAT*180./PI
D     WRITE(LU,995) ORA,ODC,PI,DPI
D995  FORMAT(" RA DEC PI DPI",4F10.3) 
      DLAT=ALAT
      DLON=WLONG
      CALL EXEC(11,IT,IT(6))
C 
      RA=RADAT
      DEC=DECDAT
D     ORA=RA*(180.0/PI)
D     ODC=DEC*180.0/PI
D     WRITE(LU,992) ORA,ODC,PI
D992  FORMAT(" RA, DEC, PI",3F12.4)
D     OLAT=DLAT*180./PI
D     OLON=DLON*180./PI
D     WRITE(LU,993) IT,OLAT,OLON
D993  FORMAT(" IT, DLAT, DLON ",6I5,2F12.3)
      CALL CNVRT(1,RA,DEC,AZ,EL,IT,DLAT,DLON)
      EL=EL+(DPI/180.0D0)*REFR(EL*(180.0D0/DPI))
      CALL CNVRT(5,AZ,EL,X,Y,IT,DLAT,DLON)
D     OAZ=AZ*180.0/PI
D     OEL=EL*180.0/PI
D     OX=X*180.0/PI
D     OY=Y*180./PI
D     OCR=REFR(EL*(180.D0/DPI))
D     WRITE(LU,991) OAZ,OEL,OX,OY,OCR
D991  FORMAT(" AZ, EL, X, Y, REFR ",5F10.4)
C
C  NOW CONVERT BACK TO WHAT WE WERE ASKED FOR
C
C  HA/DEC, NOT RA/DEC
C
D     CALL EXEC(2,LU,14HLOCAL HADC    ,-14)
      IF(ICHCM(LAXIS,1,4HHADC,1,4).NE.0) GO TO 200
      CALL CNVRT(6,X,Y,DHA,DEC,IT,DLAT,DLON)
      LONPOS=DHA
      LATPOS=DEC
      RETURN
C
C  AZ/EL
C
200   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL AZEL    ,-14)
      IF(ICHCM(LAXIS,1,4HAZEL,1,4).NE.0) GO TO 400
      CALL CNVRT(4,X,Y,AZ,EL,IT,DLAT,DLON)
      LONPOS=AZ
      LATPOS=EL
      RETURN
C
C  X/Y NS
C
400   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL XYNS    ,-14)
D     CALL EXEC(2,LU,LAXIS,-4)
      IF(ICHCM(LAXIS,1,4HXYNS,1,4).NE.0) GO TO 600
      LONPOS=X
      LATPOS=Y
      RETURN
C 
C  X/Y EW 
C 
600   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL XYEW    ,-14) 
C      IF(ICHCM(LAXIS,1,4HXYEW,1,4).NE.0) GO TO 800 
C 
C   WE DON'T SUPPORT THIS YET WEH 840728
C 
      GO TO 800 
C      LONPOS=X 
C      LATPOS=Y 
C      RETURN 
C 
C UNKNOWN AXIS SYSTEM 
C 
800   CONTINUE
D     CALL EXEC(2,LU,14HLOCAL ERROR   ,-14) 
      IERR=-40
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE GOOFF(LONOFF,LATOFF,LAXIS,NWAIT,IERR)
      REAL LONOFF,LATOFF
C 
C  GO TO THE INDICATED OFFSET 
C 
C  INPUT: 
C 
C            NWAIT = NUMBER OF SECONDS TO WAIT FOR ONSOURCE 
C 
C  OUTPUT:
C 
C            LONOFF = LONIGITUDE AXIS OFFSET
C 
C            LATOFF = LATITUDE AXIS OFFSET
C 
C            IERR = 0 IF NO ERROR 
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  THE FOLLOWING VARIABLES ARE READ FROM FSCOM: 
C 
C        XOFF, YOFF, AZOFF, ELOFF, RAOFF, DECOFF, 
C 
C  HA/DEC, NOT RA/DEC 
C 
D     CALL EXEC(2,LU,14HENTERING GOOFF,-14) 
      IF(ICHCM(LAXIS,1,4HHADC,1,4).NE.0) GO TO 200
      RAOFF=-LONOFF 
      DECOFF=LATOFF 
      GO TO 10000 
C 
C  AZ/EL
C 
200   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/200 ,-10)
      IF(ICHCM(LAXIS,1,4HAZEL,1,4).NE.0) GO TO 400
      AZOFF=LONOFF
      ELOFF=LATOFF
      GO TO 10000 
C 
C  X/Y NS 
C 
400   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/400 ,-10)
      IF(ICHCM(LAXIS,1,4HXYNS,1,4).NE.0) GO TO 600
      XOFF=LONOFF 
      YOFF=LATOFF 
      GO TO 10000 
C 
C  X/Y EW 
C 
600   CONTINUE
D          CALL EXEC(2,LU,10HGOOFF/600 ,-10)
      IF(ICHCM(LAXIS,1,4HXYEW,1,4).NE.0) GO TO 80000
      XOFF=LONOFF 
      YOFF=LATOFF 
      GO TO 10000 
C 
C  NOW DO THE OFF 
C 
10000 CONTINUE
      CALL ANTCN(2,IERR)
      IF(IERR.NE.0) RETURN
C 
C WAIT FOR ONSOURCE 
C 
      CALL ONSOR(NWAIT,IERR)
      RETURN
C 
C UNKNOWN AXIS SYSTEM 
C 
80000 CONTINUE
D          CALL EXEC(2,LU,12HLOCAL/80000 ,12) 
      IERR=-60
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE VLTS2(TPIA,SIG,TIMA,INTP,RUT,IERR) 
      DIMENSION TPIA(2),SIG(2)
C 
C   TOTAL POWER INTEGERATION ROUTINE, THIS ROUTINE READS THE TPI
C       FOR THE SPECIFIED DEVICE
C 
C   INPUT:
C 
C       INTP   - INTEGRATION PERIOD IN SECONDS
C 
C       NTRY   - EXTRA TRIES TO ALLOW, IF AN ERROR OCCURS 
C 
C       RUT    - REFERENCE UT TIME OF DAY IS SECONDS
C 
C   OUTPUT: 
C 
C       TPIA   - MEASURED TPI LEVEL 
C 
C       SIG    - POPULATION SIGMA 
C 
C       TIMA   - TIME IN SECONDS OF MEASUREMENT RELATIVE TO RUT 
C 
C       IERR = 0 IF NO ERROR OCCURRED 
C 
      DOUBLE PRECISION TPIA1,TPIA2,SIG1,SIG2,TIMTA,TIMT 
      DOUBLE PRECISION DRI,DIM1,DIDIM1,DTPI1,DTPI2
      DIMENSION ICMND(4,17),IREG(2),IT(5),INDATA(10),INDAT2(10),ITI(5)
D     DIMENSION COUNT(2,10) 
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE USE THE FOLLOWING VARIABLES FROM FSCOM
C 
C      LDV1NF, LDV2NF, LUMAT
C 
      EQUIVALENCE (REG,IREG)
      DATA ICMND/ 2HV1, 2H#0,2H1%,2H__, 
     +            2HV2, 2H#0,2H2%,2H__, 
     +            2HV3, 2H#0,2H3%,2H__, 
     +            2HV4, 2H#0,2H4%,2H__, 
     +            2HV5, 2H#0,2H5%,2H__, 
     +            2HV6, 2H#0,2H6%,2H__,
     +            2HV7, 2H#0,2H7%,2H__,
     +            2HV8, 2H#0,2H8%,2H__,
     +            2HV9, 2H#0,2H9%,2H__,
     +            2HVA, 2H#0,2HA%,2H__,
     +            2HVB, 2H#0,2HB%,2H__,
     +            2HVC, 2H#0,2HC%,2H__,
     +            2HVD, 2H#0,2HD%,2H__,
     +            2HVE, 2H#0,2HE%,2H__,
     +            2HVF, 2H#0,2HF%,2H__,
     +            2HI1, 2H#9,2H3!,2H__,
     +            2HI2, 2H#9,2H3!,2H__/
      DATA IQUES/2H??/,NDEV/17/,LWHO/2HNF/,LWHAT/2HVO/,NTRY/1/
      DATA NIN/10/
C
C  0. INITIALIZE
C
C       LOCK INTO MEMORY
C
D     CALL EXEC(2,LU,14HENTERING VOLTS,-14)
      CALL EXEC(22,1)
C 
C       WHICH DEVICE? 
C 
      DO 8 I=1,NDEV 
           IF(ICMND(1,I).NE.LDV1NF) GO TO 8 
           ID1=I
           GO TO 11 
8          CONTINUE 
C 
C            DEVICE NOT FOUND 
C 
      GO TO 80000 
C 
C            GOT IT 
C 
11    CONTINUE
C 
      DO 12 I=1,NDEV
           IF(ICMND(1,I).NE.LDV2NF) GO TO 12
           ID2=I
           GO TO 13 
12         CONTINUE 
C 
C            DEVICE NOT FOUND 
C 
      GO TO 80000 
C 
C            GOT IT 
C 
13    CONTINUE
C 
C       SET UP OTHER THINGS 
C 
      TPIA1=0 
      TPIA2=0 
      SIG1=0
      SIG2=0
      TIMTA=0 
C 
C  WAIT ONE SECOND TO CYCLE THE INTEGERATOR 
C   (WE WILL WAIT ON MORE SECOND AT THE BEFORE THE FIRST SAMPLE AS WELL)
C 
      CALL SUSP(1,102)
      CALL EXEC(11,ITI) 
C 
C   1. LOOP GETTING DATA
C 
      DO 20 I=1,INTP
C 
C       WAIT TILL THE NEXT SECOND AT LEAST
C 
       IF(IFBRK(IDUM).LT.0)GO TO 80040
       CALL EXEC(11,IT) 
       ITV1=IT(1)-ITI(1)                    
       ITV2=IT(2)-ITI(2)                    
       ITIM=ITV1*100+ITV2+102 
       IF(ITIM.LT.0) ITIM=ITIM+6000.            
           CALL SUSP(1,ITIM)
D      WRITEVLU,9901 ITIM,ITV1,ITV2,I 
D9901  FORMAT(" ITIM, ITV1 , ITV2, I = ",4I7)         
C 
C      GET THE STUFF
C 
           ITRY=NTRY
15         CONTINUE 
           CALL MATCN(ICMND(2,ID1),-5,IQUES,INDATA,NIN, 9,IERR) 
           IF(.NOT. (ID1.GT.15.AND.ID2.GT.15))
     +     CALL MATCN(ICMND(2,ID2),-5,IQUES,INDAT2,NIN, 9,IERR) 
           CALL EXEC(11,ITI)  
           IF(IERR.NE.0) RETURN 
C 
C      CONVERT TO COUNTS
C 
           IF(ID1.EQ.17) DTPI1=FLOAT(IA22H(INDATA(1)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(2)))
           IF(ID1.NE.17) DTPI1=FLOAT(IA22H(INDATA(3)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(4)))
           IF(.NOT. (ID1.GT.15.AND.ID2.GT.15))
     +                       IDUM=ICHMV(INDATA,1,INDAT2,1,10) 
           IF(ID2.EQ.17) DTPI2=FLOAT(IA22H(INDATA(1)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(2)))
           IF(ID2.NE.17) DTPI2=FLOAT(IA22H(INDATA(3)))*256.0+ 
     +                       FLOAT(IA22H(INDATA(4)))
C 
C       CHECK FOR TPI SATURATION
C 
           IF(DTPI2.LT.65534.5D0.AND.DTPI2.LT.65534.5D0) GO TO 16 
           CALL LOGIT(IDUM,IDUM,IDUM,-1,-80,LWHO,LWHAT) 
           ITRY=ITRY-1
           IF(ITRY.LE.0) GO TO 80010
           GO TO 15 
C 
C       CALCULATE TIME
C 
16         CONTINUE 
D          COUNT(1,I)=DTPI1 
D          COUNT(2,I)=DTPI2 
           DIM1=DBLE(FLOAT(I-1))
           DRI=1.0D0/DBLE(FLOAT(I)) 
           TPIA1=(TPIA1*DIM1+DTPI1)*DRI 
           TPIA2=(TPIA2*DIM1+DTPI2)*DRI 
           SIG1=(SIG1*DIM1+DTPI1*DTPI1)*DRI 
           SIG2=(SIG2*DIM1+DTPI2*DTPI2)*DRI 
           TIMT=FLOAT(ITI(2))+FLOAT(ITI(3))*60.0+ 
     +          FLOAT(ITI(4))*3600.0  
           IF(TIMT.LT.DBLE(RUT)) TIMT=TIMT+86400.0D0
           TIMTA=(TIMTA*DIM1+TIMT)*DRI
D       WRITE(LU,9920) INDATA,DTPI1,DTPI2,TIMT,ID,INTP
D9920   FORMAT(" INDATA, DTPI1, DTPI2, TIMT ID1 ID2 INTP= "/
D    +         ,10A2,3F10.3,3I7)
20         CONTINUE 
C 
C        AVERAGE TIME AND COUNTS
C 
      IF(INTP.GT.1) GO TO 30
      SIG1=0
      SIG2=0
      GO TO 35
C 
30    CONTINUE
D     WRITE(LU,9987) ((COUNT(J,K),J=1,2),K=1,INTP)
D9987  FORMAT(" COUNT FOR 1 AND COUNTS FOR 2 = "/10(2F10.1/)) 
      DIDIM1=DBLE(FLOAT(INTP))/DBLE(FLOAT(INTP-1))
      SIG1=DSQRT(DABS(SIG1-TPIA1*TPIA1)*DIDIM1) 
      SIG2=DSQRT(DABS(SIG2-TPIA2*TPIA2)*DIDIM1) 
C 
35    CONTINUE
      TPIA(1)=TPIA1 
      TPIA(2)=TPIA2 
      SIG(1)=SIG1 
      SIG(2)=SIG2 
      TIMA=TIMTA
      GO TO 90000 
C 
C        UNKNOWN DEVICE ERROR 
C 
80000 CONTINUE
      IERR=-81
      GO TO 90000 
C 
C        SATURATION ERRORS
C 
80010 CONTINUE
      IERR=-82
      GO TO 90000 
C 
C  BREAK DETECTED 
C 
80040 CONTINUE
      IERR=-1 
      GO TO 90000 
C 
C        CLEAN UP AND EXIT
C 
90000 CONTINUE
      CALL EXEC(22,0) 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE MATCN(ICMND,NOUT,ITRIG,INDATA,NIN,NREQ,IERR) 
C 
C  MAT COMMUNICATION ROUTINE
C 
C  INPUT: 
C 
C        ICMND = BUFFER HOLDING DATA TO GO OUT
C 
C        NOUT = POSITIVE WORDS OR NEGATIVE CHARACTERS IN ICMND
C 
C        ITRIG = TRIGGER CHARATER IN LOWER BYTE, UPPER BYTE NULL
C 
C        NIN = POSITIVE WORDS OR NEGATIVE CHARACTERS IN INDATA
C 
C        NREQ = NUMBER OF REQUIRED CHARACTERS IN RESPONSE, POSITIVE 
C 
C  OUTPUT:
C 
C        INDATA = RETURN BUFFER 
C 
C        IERR = 0 IF NO ERROR 
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE READ THE FOLLOWING VARIABLES FROM FSCOM 
C 
C        LUMAT
C 
      DIMENSION IREG(2) 
      EQUIVALENCE (REG,IREG)
C 
      DATA IDUM/0/,LWHO/2HNF/,LWHAT/2HMA/,NTRY/2/ 
  
C 
C  LOCK THE BUS WITH WAIT 
C 
D     CALL EXEC(2,LU,14HENTERING MATCN,-14)
C     CALL LURQ(000001B,LUMAT,1)
C
      ITER=NTRY
      NI=NIN
      IF(NIN.GT.0) NI=-2*NIN
12    CONTINUE
      ITER=ITER-1
      IF(ITER.LT.0) GO TO 80000
      IF(IFBRK(IDUM).LT.0) GO TO 80010
      CALL EXEC(3,2600B+LUMAT)
      REG=REIO(2,2000B+LUMAT,ICMND,NOUT+1)
      REG=REIO(2,2000B+LUMAT,ITRIG,-1)
      REG=REIO(1,2000B+LUMAT,INDATA,NI)
C
C      CHECK FOR TIME OUT
C
      IF(IAND(IREG(1),02B).EQ.0) GO TO 14
      CALL LOGIT(IDUM,IDUM,IDUM,-1,-70,LWHO,LWHAT)
      GO TO 12
C
C       CHECK FOR CHARACTER COUNT ERROR
C
14    CONTINUE
      IF(IREG(2).EQ.NREQ) GO TO 90000 
      CALL LOGIT(IDUM,IDUM,IDUM,-1,-71,LWHO,LWHAT)
      GO TO 12
C 
C  FAILED 
C 
80000 CONTINUE
      IERR=-72
      GO TO 90000 
C 
C BREAK DETECTED
C 
80010 CONTINUE
      IERR=-1 
      GO TO 90000 
C 
C CLEAN UP AND EXIT 
C 
90000 CONTINUE
C     CALL LURQ(100000B,LUMAT,1)
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ANTCN(IP1,IERR)
C 
C ANTCN SCHEDULING SUBROUTINE 
C 
C INPUT:
C 
C       IP1 = THE FIRST PARAMETER IN THE RUN STRING 
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C OUTPUT: 
C 
C       IERR = 0 IF NO ERROR OCCURRED 
C 
      DIMENSION IP(5) 
C 
      DATA NTRY/2/,IDUM/0/
C 
D     CALL EXEC(2,LU,14HENTERING ANTCN,-14) 
      ITRY=NTRY 
15    CONTINUE
      IF(IFBRK(IDUM).LT.0) GO TO 80010
      CALL EXEC(23,6HANTCN ,IP1,0,0,0,0)
      CALL RMPAR(IP)
      IF(IP(3).GE.0) RETURN 
      CALL LOGIT(IDUM,IDUM,IDUM,-1,IP(3),IP(4),2HNF)
      ITRY=ITRY-1 
      IF(ITRY.GT.0) GO TO 15
      GO TO 80020 
C 
C BREAK DETECTED
C 
80010 CONTINUE
      IERR=-1 
      RETURN
C 
C FAILED COMMUNICATION
C 
80020 CONTINUE
      IERR=-30
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SORCE(RUT,IDOY,IYR,LBUF,ISBUF) 
      DIMENSION LBUF(1) 
C 
C WRITE SOURCE LOG ENTRY
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE READ THE FOLLOWING FROM FSCOM:
C 
C    LSORNA,  DEC50, RA50, EP1950,
C 
C  SOURCE ENTRY IDENTIFIER
C 
D     CALL EXEC(2,LU,14HENTERING SORCE,-14) 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,8HSOURCE  ,1,7)
C 
C  SOURCE NAME
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,LSORNA,1,10) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C RA
C 
      ICNEXT=IPTRA(RA50,LBUF,ICNEXT)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C DECLINATION 
C 
      ICNEXT=IPTDC(DEC50,LBUF,ICNEXT) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C EPOCH 
C 
      ICNEXT=ICNEXT+JR2AS(EP1950,LBUF,ICNEXT,-6,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  TIME 
C 
      IH=INT(RUT/3600.0)
      RUT1=RUT-3600.0*FLOAT(IH) 
      IM=INT(RUT1/60.0) 
      RUT2=RUT1-60.0*FLOAT(IM)
      IS=INT(RUT2+0.5)
D     WRITE(LU,9010) RUT,IH,IM,IS 
D9010 FORMAT(" RUT, IH, IM, IS = ",F10.1,3I4) 
C 
      IY=MOD(IYR,100) 
      ICNEXT=ICNEXT+IB2AS(IY,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H/  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IDOY,LBUF,ICNEXT,40000B+400B*3+3) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H.  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IH,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H:  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IM,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H:  ,1,1) 
      ICNEXT=ICNEXT+IB2AS(IS,LBUF,ICNEXT,40000B+400B*2+2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C EVEN OFF THE LAST WORD AND SEND IT
C 
      NCHAR=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHAR)
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ONOF(LBUF,ISBUF) 
      DIMENSION LBUF(1) 
C 
C WRITE ONOFF  LOG ENTRY
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C WE READ THE FOLLOWING FROM FSCOM: 
C 
C     NREPNF, INTPNF, LDV1NF, LDV2NF, CTOFNF, FRQ1NF, FRQ2NF, 
C     CAL1NF, CAL2NF
C 
C ONOFF LOG ENTRY IDENTIFIER
C 
D     CALL EXEC(2,LU,14HENTERING ONOF ,-14) 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,6HONOFF ,1,6)
C 
C REPITITONS
C 
      ICNEXT=ICNEXT+IB2AS(NREPNF,LBUF,ICNEXT,2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C INTEGRERATION PERIOD
C
      ICNEXT=ICNEXT+IB2AS(INTPNF,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C DEVICE MNEMONIC 1
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LDV1NF,1,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C DEVICE MNEMONIC 2
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LDV2NF,1,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CUTOFF ELEVATION
C
      ICNEXT=ICNEXT+JR2AS(CTOFNF*180./PI,LBUF,ICNEXT,-2,0,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C STEP SIZE
C
      ICNEXT=ICNEXT+JR2AS(STEPNF,LBUF,ICNEXT,-2,0,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CALIBRATION NOISE SOURCE 1
C
      ICNEXT=ICNEXT+JR2AS(CAL1NF,LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CALIBRATION NOISE SOURCE 2
C
      ICNEXT=ICNEXT+JR2AS(CAL2NF,LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C FREQUENCY 1
C
      ICNEXT=ICNEXT+JR2AS(BM1NF_FS*180./PI,LBUF,ICNEXT,-4,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C FREQUENCY 2
C
      ICNEXT=ICNEXT+JR2AS(BM2NF_FS*180./PI,LBUF,ICNEXT,-4,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C DIAMETER OF DISH
C
      ICNEXT=ICNEXT+JR2AS(FX1NF_FS,LBUF,ICNEXT,-7,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C DIAMETER OF DISH
C
      ICNEXT=ICNEXT+JR2AS(FX2NF_FS,LBUF,ICNEXT,-7,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C CLEAN UP AND OUTPUT THE RESULT
C
      NCHARS=ICNEXT-1
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
      CALL LOGIT(LBUF,NCHARS)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SITE(VFIVPT,LBUF,ISBUF)
      DIMENSION LBUF(1)
C
      INCLUDE /FS/INCLUDE/DPI.FTNI
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C  WRITE SITE RECORD TO LOG
C
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,1,6HSITE  ,1,5)
C
C  ANTENNA NAME
C
      ICNEXT=ICHMV(LBUF,ICNEXT,LNAANT,1,8)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C  LONGITUDE
C
      ICNEXT=ICNEXT+JR2AS(SNGL(WLONG*RAD2DEG),LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C  LATITIUDE
C
      ICNEXT=ICNEXT+JR2AS(SNGL(ALAT*RAD2DEG),LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
C  DIAMETER
C
      ICNEXT=ICNEXT+JR2AS(DIAMAN,LBUF,ICNEXT,-6,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  AXIS TYPE
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,4HXXXX,1,4)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  POINTING MODEL NUMBER
C 
      ICNEXT=ICNEXT+IB2AS(0,LBUF,ICNEXT,3)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  FIVPT VERSION NUMBER 
C 
      ICNEXT=ICNEXT+JR2AS(VFIVPT,LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C  FS VERSION 
C 
      ICNEXT=ICNEXT+JR2AS(FSVER,LBUF,ICNEXT,-5,2,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C CLEAN UP AND SEND 
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE DPNT2(LMESS,MCHARS,I,TIM,AOFF,BOFF,VLT,SIG,NP,LBUF,
     +                ISBUF)
      DIMENSION LMESS(2),LBUF(1),VLT(2),SIG(2)
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,LMESS,1,MCHARS)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+IB2AS(I,LBUF,ICNEXT,2)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(TIM,LBUF,ICNEXT,-6,0,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(AOFF*180./PI,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(BOFF*180./PI,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(VLT(1),LBUF,ICNEXT,-8,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(VLT(2),LBUF,ICNEXT,-8,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      IF(NP.LE.1) GO TO 100 
      ICNEXT=ICNEXT+JR2AS(SIG(1),LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICNEXT+JR2AS(SIG(2),LBUF,ICNEXT,-5,2,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
100   CONTINUE
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE RESLT(IMES,NC,IMES2,NC2,AZ,EL,AVG1,AVG2,SIG1,SIG2, 
     +                 NP,LBUF,ISBUF) 
      DIMENSION LBUF(1),IMES(1),IMES2(1)
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,IMES,1,NC) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
      ICNEXT=ICHMV(LBUF,ICNEXT,IMES2,1,NC2) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(AZ*180./PI,LBUF,ICNEXT,-5,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(EL*180./PI,LBUF,ICNEXT,-4,1,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(AVG1,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(AVG2,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      IF(NP.LE.1) GO TO 100
      ICNEXT=ICNEXT+JR2AS(SIG1,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
      ICNEXT=ICNEXT+JR2AS(SIG2,LBUF,ICNEXT,-7,3,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C
100   CONTINUE
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
      RETURN
      END 
      FUNCTION JR2AS(RE,LBUF,ICN,IT,ID,ISBUF) 
      DIMENSION LBUF(1) 
C 
      JR2AS=IR2AS(RE,LBUF,ICN,IT,ID)
      IF(.NOT. JCHAR(LBUF,ICN).EQ.36) RETURN
      ITA=MIN0(IABS(IT)+IABS(ID)+1,ISBUF*2-ICN+1) 
      JR2AS=IR2AS(RE,LBUF,ICN,ITA,ID) 
      JR2AS=IABS(IT)
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE ORIGN(XO,YO,AZO,ELO,HAO,DCO,LBUF,ISBUF)
      DIMENSION LBUF(1) 
C 
C WRITE ORIGIN LOG ENTRY
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C INPUT:
C 
C XO = XOFFSET
C YO  =Y  OFSET 
C AZO = AZ OFFSET 
C ELO = EL OFFSET 
C HAO = HA OFFSET 
C DECO = DEC OFFSET 
C 
C     WRITE ORIGIN IDENTIFIER 
C 
D     CALL EXEC(2,LU,14HENTERING ORIGN,-14) 
      ICNEXT=1
      ICNEXT=ICHMV(LBUF,ICNEXT,8HORIGIN  ,1,7)
C 
C HAOFFSET
C 
      ICNEXT=ICNEXT+JR2AS(HAO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C DECLINATION OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(DCO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C AZIMUTH OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(AZO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C ELEVATION OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(ELO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF)
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C X OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(XO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C Y OFFSET
C 
      ICNEXT=ICNEXT+JR2AS(YO*180.0/PI,LBUF,ICNEXT,-8,4,ISBUF) 
      ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1)
C 
C CLEAN UP AND SEND IT
C 
      NCHARS=ICNEXT-1 
      IF(1.NE.MOD(ICNEXT,2)) ICNEXT=ICHMV(LBUF,ICNEXT,2H  ,1,1) 
      CALL LOGIT(LBUF,NCHARS) 
C 
      RETURN
      END 
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE TZER(VZERO,SIGZER,TIMZER,INTP,RUT,IERR)
      DIMENSION VZERO(2),SIGZER(2)
C 
C  GET TPZERO 
C 
C  INPUT: 
C 
C        INTP = INTEGRATION PERIOD IN SECONDS 
C 
C        RUT  = REFERENCE UT TIME OF DAY IN SECONDS 
C 
C  OUTPUT:
C 
C        VZERO = VOLTAGE OF ZERO READING
C 
C        SIGZER= SIGMA OF ZERO IF MORE THAN 1 INTEGRATION 
C 
C        TIMZER= SECONDS SINCE RUT
C 
C        IERR = O IF NO ERROR OCCURRED
C 
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C 
C  WE READ THE FOLLOWING VALUES FROM FSCOM
C 
C
      DIMENSION ICMND(3),INDATA(10),ISAV(10),IZERO(10)
      DATA ICMND/ 2H#9,2H3%,2H__/,IQUES/2H??  /,IDOLR/2H$$  /
      DATA ISAV/2H#9,2H3=,0,0,0,0,2H__,0,0,0/
      DATA IZERO/2H#9,2H3=,2H00,2H00,2H3F,2H3F,2H__,0,0,0/
      DATA NIN/-20/
C
C  READ EXISTING IFD ATTENUATOR SETTINGS
C
D     CALL EXEC(2,LU,14HENTERING TZERO ,-14)
      CALL MATCN(ICMND,-5,IQUES,INDATA,NIN, 9,IERR)
      IF(IERR.NE.0) RETURN
      CALL ICHMV(ISAV,5,INDATA,1,8)
C
C  TURN ON ALL THE ATTENUATORS
C
      CALL ICHMV(IZERO,5,INDATA,1,4)
      CALL MATCN(IZERO,-13,IDOLR,INDATA,NIN,2,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  OKAY GET THE VOLTS
C
      CALL VLTS2(VZERO,SIGZER,TIMZER,INTP,RUT,IERR)
      IF(IERR.NE.0) GO TO 8000
C
C  RESET THE ATTENUATORS
C
      CALL MATCN(ISAV,-13,IDOLR,INDATA,NIN,2,IERR)
      IF(IERR.NE.0) GO TO 8000
C
      RETURN
C
C  ERROR RETURN, RESET ATTENUATORS
C
8000  CONTINUE
      JTRY=2
C
8001  CONTINUE
      JERR=0
      CALL MATCN(ISAV,-13,IDOLR,INDATA,NIN,2,JERR)
      JTRY=JTRY-1
      IF(JERR.GT.0.AND.JTRY.GT.0) GO TO 8001
      IF(JERR.NE.0) CALL LOGIT(IDUM,IDUM,IDUM,-1,-110,LWHO)
      RETURN
      END
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE SCMDS(IMESS,IC)
      DIMENSION IMESS(1)
C
      CALL COPIN(IMESS,IC)
C
      CALL EXEC(7)
      RETURN
      END
