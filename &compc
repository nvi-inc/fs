MACRO 
      NAM COMPC,3,96 Dummy to reserve array space 
      EXT EXEC,RMPAR,COMXX,PRTN,LIMEM 
      ENT .NFOP,.NFCL,.NFIN,.FFOP,.FFCL,.FFIN,.FFCN 
      ENT .DNOP,.DNCL,.DNIN,.DNCN,.DSOP,.DSCL,.DSIN,.DSCN 
* 
*     This is a dummy 'header' program which simply finds the amount of 
*     available partition space and 'passes' the largest array possible 
*     to the main program.
* 
*     ARW 801215
* 
.NFOP EQU 0 
.NFCL EQU 0 
.NFIN EQU 0 
.FFOP EQU 0 
.FFCL EQU 0 
.FFIN EQU 0 
.FFCN EQU 0 
.DNOP EQU 0 
.DNCL EQU 0 
.DNIN EQU 0 
.DNCN EQU 0 
.DSOP EQU 0 
.DSCL EQU 0 
.DSIN EQU 0 
.DSCN EQU 0 
* 
IPAR  BSS 5 
D6    DEC 6 
CODE  OCT 0 
IBUFL BSS 1 
* 
COMPC NOP 
      JSB RMPAR     Get RMPAR parameters
      DEF *+2 
      DEF IPAR
* 
      JSB LIMEM     Get current memory space remaining in partition 
      DEF *+4 
      DEF CODE
      DEF IBUF
      DEF IBUFL 
* 
      JSB COMXX     Call main program 
      DEF *+4 
      DEF IPAR
IBUF  BSS 1 
      DEF IBUFL 
      JSB PRTN      Return parameters 
      DEF *+2 
      DEF IPAR
* 
      JSB EXEC      Terminate 
      DEF *+2 
      DEF D6
* 
      END COMPC 
MACRO 
      HED   BYPASS FOR SPECIAL RETURN 
      NAM   IBYP Subroutine for COMPC 
      ENT   IBYP1,IBYP2 
      EXT   .ENTR 
II    BSS   1              ARGUMENT ADDRESS 
IBYP1 NOP                  FIRST ENTRY POINT
      JSB   .ENTR          RESOLVE RETURN ADDRESS 
      DEF   II             AND ARGUMENT ADDRESS 
      LDA   =D1            LOAD ARGEMENT = 1
      STA   II,I           STORE IN CALLING PROGRAM 
      JMP   IBYP1,I        RETURN 
IBYP2 NOP                  SECOND ENTRY POINT 
      JSB   .ENTR          RESOLVE ADDRESS OF RETURN NOT USED 
      DEF   IBYP2 
      LDA   =D2            LOAD ARGUMENT = 2
      STA   II,I           STORE IN PROGRAM THAT CALLED FIRST ENTRY 
      JMP   IBYP1,I        RETURN TO FIRST ENTRY POINT CALL 
      END 
FTN66 
      SUBROUTINE COMXX(IPAR,LPR,MXPAR)
C# LAST COMPC'ED  870105:21:16 *
C 
C  MODIFIED 790426 BY ARW TO USE IGETS INSTEAD OF IGET SO THAT COMPC CAN
C     BE LOADED AS A LB PROGRAM 
C  MODIFIED 790705 BY ARW TO NOT UPDATE C# CARD IF SECURITY CODE WRONG
C  MODIFIED 790722 BY ARW TO FIX BUG IN PARSING NAME OF ASMB ROUTINE
C  MODIFIED 790823 BY ARW SO "X" OR "Y" CONTROL IN FTN4 CONTROL STATEMENT 
C     IS AUTOMATICALLY PASSED THROUGH REGARDLESS
C  MODIFIED 800108 BY CMA FOR OUTPUT NAMELIST 
C  MODIFIED 800129 BY CMA TO CLOSE CPCPCP AFTER BREAK 
C  MODIFIED 800604 BY CMA TO FIX BLOCK DATA IN EMA SOURCE AND 
C     IMPLEMENT OTHERWISE IN CASE STRUCTURE 
C  MODIFIED 800923 BY ARW TO SUPPORT FTN4X
C  MODIFIED 801006 BY ARW TO ALLOW ALPHA CARTRIDGE LABEL
C  MODIFIED 801111 BY ARW TO SUPPORT $FILES DIRECTIVE AND $STRUC DIRECTIVE
C     (old STRUCTURED format still supported, but obsolete) 
C  MODIFIED 801112 BY ARW TO NAME SCRATCH FILES ACCORDING TO NAME OF CURRENT
C     COPY OF COMPC, AND TO PURGE ALL SCRATCH FILES ON TERMINATION
C     REMOVE ROUTINE WAITX TO PREVENT QUEUE-SCHEDULING BECAUSE NOT NEEDED 
C     ANY MORE
C  MODIFIED 810120 BY CMA TO HAVE SUMMARY LUII
C  MODIFIED 810205 BY CMA TO ALLOW STRING REPLACEMENT USING $PARM AND $PARMF
C     $INCLUDE TO ALLOW INCLUDING ENTIRE ROUTINES WITH NESTING
C  MODIFIED 810217 BY ARW TO GENERALIZE $INCLUDE, REMOVE $PARMF FEATURE,
C     AND ADD CAPABILITY TO SPECIFY SECURITY CODE FOR RELOCATABLES
C  MODIFIED 810304 BY ARW TO ALLOW UNCONDITIONAL OVERRIDE OF CARTRIDGE
C     SPECIFICATION IN $INCLUDE STATEMENTS
C  MODIFIED 810306 BY ARW TO ALLOW USE OF $PAGE AND $TITLE DIRECTIVES 
C     IN FTN4X
C  MODIFIED 810313 BY CMA TO MULTICOPY LITERAL FILE AND CHECK READ ERRORS 
C  MODIFIED 810331 BY CMA TO PROMPT FOR UNSUBSTITUTED $INCLUDE XX, CHANGE 
C     READI TO BLANK BUFFER UP TO 72
C  MODIFIED 810409 BY ARW TO PROPERLY IDENTIFY FTN4X FUNCTIONS WITH *n IN 
C     FUNCTION DECLARATION STATEMENT
C  MODIFIED 810428 BY CMA TO ALLOW :SC:CARTREF FOR COMPOSITE RELOCATABLE, 
C     CORRECT MINOR INCONVENIENCES
C  MODIFIED 810521 BY ARW TO SUPPORT RAT4 
C  MODIFIED 810626 BY CMA TO INSERT LI,%%GSFC::21 IN LOADR COMMAND FILES, 
C     CORRECT REPLACEMENT OF LABELED COMMONS IN COMBINED RELOCATABLE FILES
C  MODIFIED 810630 BY CMA TO RP AND OF FTN4X AS NEEDED
C  MODIFIED 810717 BY CMA TO ALLOW ADDING RELOCATABLES BEFORE SPECIFIED 
C     ROUTINES
C  MODIFIED 810722 BY ARW TO DO MORE SOPHISTICATED SELECTION OF SCRATCH CART
C  MODIFIED 810812 BY CMA TO HANDLE INCLUDE LIKE $INCLUDE AND TO ALLOW
C     SOURCE NAMR AS FIRST PARAMETER INTERACTIVELY
C  MODIFIED 810826 BY CMA TO PACK $PARM STRINGS AND RESTRICT $INCLUDE 
C  MODIFIED 810830 BY CMA TO HANDLE $INCLUDE IN FIRST LINE OF INCLUDED
C     FILE AND TO FIX BUG IN $PARM IN STRUCTURED CODE 
C  MODIFIED 810902 BY CMA TO FIX BUG WITH $PARM AND LITERAL DATA
C     AND DUPLICATE $PARM DEFINITIONS 
C  MODIFIED 810929 BY CMA TO FIX BUG WITH DEBUG FOR INCLUDE LINE
C  MODIFIED 811026 BY ARW TO TRIM LEADING AND TRAILING SPACES IN ALL
C     $PARM TARGET AND REPLACEMENT FIELDS 
C  Modified 821130 by ARW to unconditionally pass comments to scratch file
C     so line# references by compiler will be correct.
C  Modified 821130 by ARW so all lower-case operator entries are converted
C     to upper case.
C  Modified 821130 by ARW so LPR array, which holds $PARM info, is dynamically
C     allocated according to partition size.
C  Modified 821214 by ARW --
C     Semi-major modifications to allow full use of FTN7X/MACRO under RTE-6.
C  Modified 830210 by CMA --
C     Corrections to DCB buffer limits for $INCLUDE push-down, WRITF length 
C     for LOADR command file RE,%.., $PARM overflow message position. 
C     Change in READI to handle $PARM substitution of longer string and 
C     to retain original record length if no substitution.
C  Modified 830215 by CMA --
C     Buffer before keyword parse in PROUT cut to 72 for serialized END.
C  Modified 830624 by ARW 
C     Lower-case prog/subr name after control statement not being 
C     recognized, and other minor bugs fixed. 
C  Modified 870105 by ARW - make scratch file names unique for multiple 
C     users, including RTE-A. Support $CDS and $TRACE directives. 
C 
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER LPR(1),IPAR(5)
      EQUIVALENCE (REG,IREG)
C GET RMPAR PARAMETERS
      CALL WMOVE(IPAR,IMPAR,5)
C GET BUFFER
      REG=EXEC(14,1,IB(2),-158) 
      IB=IREG(2)
      CALL UCASE(IB,-IB)
C     Clear LPR ($PARM) array 
      CALL AFILL(LPR,1,0,0,MXPAR) 
C GET NAME OF COPY OF COMPC 
      CALL PNAME(NAMC)
C Create potential unique scratch-file names
C     L2C=IOR(IAND(NAMC(2),177B)*400B,IAND(NAMC(3),77400B)/400B)
C     NAMO(4)=L2C 
C     NAMP(4)=L2C 
C     NAML(4)=L2C 
C     NAMD(4)=L2C 
      CALL UNAME(NAMO(2),1) 
      CALL UNAME(NAMP(2),2) 
      CALL PUTQ(NAMP,1,2H %)
      CALL UNAME(NAML(2),3) 
      CALL UNAME(NAMD(2),4) 
      CALL UNAME(NAMDD(1),5)
      CALL PUTQ(NAMDD,-1,2H %)
C     WRITE(1,6012) (NAMO(IZ),IZ=2,4),(NAMP(IZ),IZ=2,4),
C    .              (NAML(IZ),IZ=2,4),(NAMD(IZ),IZ=2,4),
C    .              (NAMDD(IZ),IZ=1,3)
C6012 FORMAT("NAMO,NAMP,NAML,NAMD,NAMDD=",5(3A2,1X))
C SET RECORD SIZE FOR $INCLUDE IDCBI SAVES
      CALL STOPN(IDCBIS+4)
C INITIALIZE BYPASS RETURN
      CALL IBYP1(II)
      IF(II.EQ.2) GO TO 500 
C TERMINAL INPUT
100   CALL INTRM
C IMMEDIATE EXIT WITHOUT PROCESSING IF FLAG SET (ABORT OR NO ROUTINES)
      IF(KGO.EQ.1000) GO TO 1000
C ERROR EXIT FROM INPUT - PRINT MESSAGE AND CLEAN UP
      IF(KGO.GT.0) GO TO 500
C FIND ROUTINES 
200   CALL FROUT(LPR,MXPAR) 
C IF FINISHED OR ERROR, CLEAN UP
      IF(KGO.GT.0) GO TO 500
C PROCESS ROUTINE AND PASS TO OUTPUT FILE 
300   CALL PROUT(LPR) 
C IF IRRECOVERABLE ERROR, CLEAN UP - OTHERWISE, COMPILE 
      IF(KGO.GT.0) GO TO 500
400   CALL COMPP
C IF IRRECOVERABLE ERROR, EXIT - OTHERWISE, FIND NEXT ROUTINE 
      IF(KGO.GT.0) 500,200
C CLEAN UP SECTION
500   CALL CLEAN
C END OF PROCESSING 
1000  CONTINUE
C CLOSE TRACKS USED FOR $INCLUDE IDCBI SAVES
      CALL STOPN(0) 
C RETURN GLOBALS
      CALL WMOVE(IBB,IPAR,5)
      END 
      SUBROUTINE INTRM
C# LAST COMPC'ED  870105:21:16 *
C ROUTINE FOR TERMINAL INPUT OR PARSING OF NONINTERACTIVE RUN STRING
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER INBUF(10),IPBUF(10),IT(7),KCNCX(8),ICRLX(3),CINFO 
      INTEGER SPACQ(2),COMQ(2),DOTQ(2),DQ(2), 
     1  CQ(2),LQ(2),KQ(2),ZERQ(2),OQ(2),IPARMQ(11)
      INTEGER LCMPC(3)
      EQUIVALENCE (REG,IREG)
      DATA LCMPC  /2HCO,2HMP,2HC /
      DATA SPACQ  /   1,2H  / 
      DATA ZERQ   /   1,2H0 / 
      DATA COMQ   /   1,2H, / 
      DATA DOTQ   /   1,2H. / 
      DATA DQ     /   2,2H,D/ 
      DATA CQ     /   1,2HC / 
      DATA KQ     /   1,2HK / 
      DATA LQ     /   1,2HL / 
      DATA OQ     /   1,2HO / 
C SET LAST CHARACTER OF VERSION NAME ZERO FOR NEATER PRINTING 
      CALL PUTQ(NAMC(3),0,0)
C 
C     CHECK IF STRING BUFFER HAS BEEN PASSED
C     IF SO, "RU,PROG,...,...,.." IS ASSUMED TO HAVE BEEN PASSED. 
      LUI=LOGLU(IDUM) 
      LUO=IMPAR(2)
      IF (LUO .EQ. 0) LUO=LUI 
C     CHECK FOR SUMMARY LU - <0 AND NOT ' OR "
      LUII=LUI
      IF(LUO.GT.0) GO TO 19 
      LUII=-LUO 
      LUO=LUI 
19    CONTINUE
C     IF NO STRING FOUND, ASSUME INTERACTIVE MODE 
      ILOG=IB+2 
      IF (IREG .NE. 0 .OR. IB .EQ. 0) GO TO 170 
C     PARSE STRING BUFFER 
C     MOVE PAST "RU,PROG," AND GET FIRST PARAMETER, WHICH MAY BE NAMR 
      ISTRC=3 
      DO 101 I=1,3
101   IDUM=NAMR(NAMI,IB,ILOG,ISTRC) 
C     GET THIRD PARAMETER 
      DO 102 I=1,2
102   IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
C     CHECK FOR NON-INTERACTIVE MODE
      IF (IAND(IPBUF(4),3) .NE. 3) GO TO 170
C     NON-INTERACTIVE MODE - SEPARATE INPUT FILE NAMR 
      IMPAR(2)=-1 
      NAMI=IPBUF
      NAMI(2)=IPBUF(2)
      NAMI(3)=IPBUF(3)
      ISECUI=IPBUF(5) 
      ICRI=IPBUF(6) 
C CHECK RELOCATABLE LU FOR SEPARATE FILES OR COMBINED FILE FLAGS
      JS=ISTRC
      IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
      IF (IAND(IPBUF(4),3) .NE. 0) GO TO 120
          IPBUF=IPBUF(6)
          IPBUF(6)=0
120   KCNC=IPBUF
      LUD=IPBUF 
      CALL CNVT(LUD,LUDX,0) 
      ISECUP=IPBUF(5) 
      NAMA=0
      IF (KCNC.EQ.1HN.OR.KCNC.EQ.1HR) GO TO 130 
      IF (KCNC .NE. 1HA .AND. KCNC .NE. 1HD) GO TO 160
C     Parse 'add before' name, if specified 
      INBUF=ISTRC-JS-1
      CALL CMOVE(IB,JS,INBUF,3,INBUF) 
      IDUM=IXQ(INBUF,SPACQ,0,0) 
      JS=1
      IDUM=KPRSQ(INBUF,IDUM,0,JS,2,2H :)
      IDUM=KPRSQ(INBUF,NAMA,5,JS,2,2H :)
      CALL FILLQ(NAMA,NAMA+1,6) 
C COMBINED RELOCATABLE FILE 
130   IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
      LUD=IPBUF 
      CALL CNVT(LUD,LUDX,0) 
      ISECUP=IPBUF(5) 
C LU SPECIFIED - USE DEFAULT NAME 
      IF(IAND(IPBUF(4),3).EQ.1) GO TO 139 
C %FILE SPECIFIED 
      NAMM=IPBUF
      NAMM(2)=IPBUF(2)
      NAMM(3)=IPBUF(3)
      ISECUP=IPBUF(5) 
      LUD=IPBUF(6)
      CALL CNVT(LUD,LUDX,0) 
139   CONTINUE
      GO TO 162 
C     NOT N,A,D, OR R, SO SEPARATE RELOCATABLES 
160   KCNC=0
      IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
C DATING CONTROL FLAG 
162   IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
      KDATE=IPBUF 
      KINCR=IPBUF(5)
      KINCR1=IPBUF(6) 
C     PARSE COMPILER PARAMETERS 
      JSTRC=ISTRC 
      IDUM=NAMR(IBB(2),IB,ILOG,ISTRC) 
      IBB=ISTRC-JSTRC 
      IPARMQ=0
      IF (IAND(IBB(5),3) .NE. 3) GO TO 190
      CALL MERGQ(IPARMQ,IBB)
C     EXCHANGE PERIODS FOR COMMAS 
      IDUM=IXQ(IPARMQ,DOTQ,COMQ,0)
      GO TO 190 
C     INTERACTIVE RUN 
170   KDATE=IPBUF 
      KINCR=IPBUF(5)
      KINCR1=IPBUF(6) 
C CHECK IF SOURCE NAMR ALREADY ENTERED ON RUN LINE
      IF(NAMI.NE.0.AND.NAMI.NE.LUI) GO TO 190 
C GET FILE NAME 
175   WRITE(LUI,180)
180   FORMAT("Source File NAMR? _") 
      READ(LUI,181) INBUF 
181   FORMAT(40A2)
C EXIT IF END MARK
      IF(INBUF(1).EQ.2H::) GO TO 1000 
C DECODE NAME, SECURITY CODE, AND LU
      CALL UCASE(INBUF,-20) 
      ISTRC=1 
      IDUM=NAMR(IPBUF,INBUF,20,ISTRC) 
      NAMI=IPBUF
      NAMI(2)=IPBUF(2)
      NAMI(3)=IPBUF(3)
      ISECUI=IPBUF(5) 
      ICRI=IPBUF(6) 
C 
190   CALL CNVT(ICRI,ICRIX,0)  !Convert to ASCII
C OPEN INPUT FILE FOR UPDATE SO COMPC DATE CARD CAN BE REWRITTEN
      CALL OPEN(IDCBI,IERR,NAMI,2,ISECUI,ICRI,IDCBIS) 
      IF (ICRI .EQ. 0 .AND. IERR .NE. -6) ICRI=-IAND(IDCBI,77B) 
      CALL CNVT(ICRI,ICRIX,0) 
C IF ERROR, ERROR MESSAGE AND POSSIBLE EXIT 
      IF(IERR.GT.0) GO TO 192 
      WRITE(LUII,191) NAMC,IERR,NAMI,ICRIX
191   FORMAT(3A2,": Error",I4," opening file ",3A2,"::",3A2)
C IF INTERACTIVE, READ NAME AGAIN 
      IF(IMPAR(2).NE.-1) GO TO 175
C NON-INTERACTIVE - SET FLAG FOR EXIT 
      KGO=991 
      GO TO 999 
192   IDUM=CINFO(IBB,256,ICRI,IDUM,IDUM,ICRI)   !Get source cartref 
      CALL CNVT(ICRI,ICRIX,0)               !Convert to ASCII 
C     Determine cartridge for COMPC scratch files 
      ICRO=ISCRT(ICRI,ICRO,IDCBO) 
      IF(LUII.NE.LUI) WRITE(LUII,9192) NAMC,NAMI,ICRIX
9192  FORMAT(3A2,": Opened ",3A2,"::",3A2)
      NM=NAMI 
C IF INTERACTIVE, NEXT PROMPT 
      IF(IMPAR(2).NE.-1) GO TO 195
C NON-INTERACTIVE, BRANCH TO PROCESS RELOCATABLE FILE IF REQUESTED
      IF(KCNC.EQ.0) GO TO 208 
C RELOCATABLE FILE REQUESTED - USE DEFAULT NAME OR INPUT NAME 
      IF(NAMM.EQ.2H  .OR.NAMM.EQ.0) 201,202 
C GET LU FOR RELOCATABLES 
195   WRITE(LUI,9195) 
9195  FORMAT("CARTREF for %FILES (<>=None, <N>ew, <A>dd, <R>eplace)? _")
      REG=EXEC(1,400B+LUI,KCNCX(2),-14) 
      IF (KCNCX(2) .EQ. 2H:: .AND. IREG(2) .EQ. 2) GO TO 980  
      KCNCX=IREG(2) 
      CALL UCASE(KCNCX(2),-KCNCX) 
      ISTRC=3 
      IDUM=NAMR(IDCBO,KCNCX,IREG(2)+2,ISTRC)
      IF (IAND(IDCBO(4),3) .NE. 0) GO TO 197
          IDCBO=IDCBO(6)
          IDCBO(6)=0
197   KCNC=IDCBO
      NAMA=0
      IF (KCNC.EQ.1HN.OR.KCNC.EQ.1HR) GO TO 199 
      IF (KCNC .NE. 1HA .AND. KCNC .NE. 1HD) GO TO 198
C     Parse 'add before' module name, if specified
      IDUM=IXQ(KCNCX,SPACQ,0,0) 
      JS=1
      IDUM=KPRSQ(KCNCX,IDUM,0,JS,2,2H :)
      CALL FILLQ(NAMA,1,16) 
      IDUM=KPRSQ(KCNCX,NAMA,16,JS,2,2H :) 
      IDUM=IXQ(NAMA,SPACQ,0,0)    !Delete all spaces
      GO TO 199 
198   KCNC=0
      LUD=IDCBO 
      ISECUP=IDCBO(5) 
      IF (KCNCX .EQ. 2H   .OR. IDCBO .EQ. 0) LUD=0
      CALL CNVT(LUD,LUDX,0) 
      GO TO 208 
C CONCATENATED PROCESSING FOR COMBINED RELOCATABLE FILE 
199   WRITE(LUI,9199) 
9199  FORMAT("CARTREF or NAMR for composite output? _") 
      READ(LUI,181) INBUF 
      IF(INBUF.EQ.2H::.AND.INBUF(2).EQ.2H  ) GO TO 980
      CALL UCASE(INBUF,-20) 
      ISTRC=1 
      IDUM=NAMR(IPBUF,INBUF,20,ISTRC) 
C IF LU, SKIP NAME PARSE
      IF(IAND(IPBUF(4),3).EQ.1) GO TO 200 
      NAMM=IPBUF
      NAMM(2)=IPBUF(2)
      NAMM(3)=IPBUF(3)
      ISECUP=IPBUF(5) 
      LUD=IPBUF(6)
      CALL CNVT(LUD,LUDX,0) 
      IF(NAMM.EQ.0) 201,202 
200   LUD=IPBUF 
      CALL CNVT(LUD,LUDX,0) 
      ISECUP=IPBUF(5) 
C KCNC = 0 - SEPARATE RELOCATABLES
C      = N - CREATE NEW FILE OR REWRITE EXISTING FILE 
C      = A - ADD TO EXISTING RELOCATABLE FILE 
C      = R - REPLACE WITHIN EXISTING RELOCATABLE FILE 
C      = D - DELETE SPECIFIED MODULES WITHIN RELOCATABLE FILE 
C     LUD SPECIFIES DISC LU FOR SAVING RELOCATABLES 
C 
C REPLACE 1st CHARACTER OF SOURCE FILE NAME WITH %
201   CALL PUTQ(NAMI,-1,45B)
      CALL MOVEQ(NAMI,-1,NAMM,-1,6) 
C CHECK IF RELOCATABLE FILE ALREADY EXISTS
202   CALL OPEN(IDCBP,IERR,NAMM,0,ISECUP,LUD) 
C IF ADDING TO OR REPLACING WITHIN EXISTING FILE, OPEN SHOULD SUCCEED 
      IF(KCNC.EQ.1HN) GO TO 205 
      IF(IERR.LT.0) GO TO 204 
C IF DELETING MODULE, SIMPLY GO DO IT 
      IF (KCNC .NE. 1HD .OR. NAMA .EQ. 0) GO TO 8202
         CALL CCMPL 
         CALL CLEAN 
         CALL PRTN(IBB) 
         CALL EXEC(6) 
C OPEN GOOD - POSITION TO END OF FILE IF ADDING 
8202  IF(KCNC.EQ.1HR.OR.(KCNC.EQ.1HA.AND.NAMA.NE.0)) GO TO 208
      DO 203 II=1,32767 
      CALL READF(IDCBP,IERR,IBB,0,LEN)
      IF(LEN.EQ.-1) GO TO 208 
203   CONTINUE
C OPEN FAILED - MESSAGE AND EXIT UNLESS NON-INTERACTIVE IN WHICH CASE CREATE
204   WRITE(LUII,191) NAMC,IERR,NAMM,LUDX 
      IF(IMPAR(2).NE.-1) GO TO 989
      KCNC=1HN
      GO TO 207 
C NEW FILE - IF OPEN GOOD, CHECK IF OVERWRITE PERMITTED UNLESS NON-INTERACTIVE
205   LYN=0 
      IF (IERR .GT. 0 .OR. IERR .EQ. -8) 206,207
206   IF (IMPAR(2) .EQ. -1) GO TO 208 
      IF (LUD .EQ. 0) LUD=-IAND(IDCBP,77B)
      IDUM=CINFO(IBB,256,LUD,IDUM,IDUM,LUD)    !Get LUD cartref 
      CALL CNVT(LUD,LUDX,0)                !Convert to ASCII
211   WRITE(LUI,274) NAMM,LUDX
      READ(LUI,276) LYN 
      CALL UCASE(LYN,-2)
      IF (LYN .EQ. 2HY  .OR. LYN .EQ. 2H  ) THEN
          GO TO 208 
      ELSE IF (LYN .EQ. 2HN  .OR. LYN .EQ. 2H::) THEN 
          GO TO 980 
      ELSE
          GO TO 211 
      ENDIF 
C IF NEW FILE AND DOES NOT EXIST, CREATE IT 
207   CALL CREAT(IDCBP,IERR,NAMM,48,5,ISECUP,LUD) 
C     WRITE(1,6031) (NAMM(IZ),IZ=1,3),LUD,IERR
C6031 FORMAT("1-NAMM,LUD,IERR=",3A2,1X,O7,I6) 
      IF(IERR.GT.0) GO TO 208 
      WRITE(LUII,9207) NAMC,IERR,NAMM,LUDX
9207  FORMAT(3A2,": Error",I4," creating file ",3A2,"::",3A2) 
      GO TO 989 
C IF LIST FILE REQUESTED, CREATE IT ON EITHER THE RELOCATABLE LU OR SOURCE LU 
208   IF(LUO.NE.1H') GO TO 209
      ICRL=LUD
      IF(LUD.EQ.0) ICRL=ICRI
      CALL PUTQ(NAMI,-1,47B)
      CALL CREAT(IDCBL,IERR,NAMI,48,3,0,ICRL) 
C     WRITE(1,6032) (NAMI(IZ),IZ=1,3),ICRL,IERR 
C6032 FORMAT("2-NAMI,ICRL,IERR=",3A2,1X,O7,I6)
      IF(IERR.EQ.-2) CALL OPEN(IDCBL,IERR,NAMI,0,0,ICRL)
      CALL CNVT(ICRL,ICRLX,0) 
      IF(IERR.LT.0) WRITE(LUII,9207) NAMC,IERR,NAMI,ICRLX 
      IF(IERR.LT.0) LUO=LUI 
209   NAMI=NM 
210   IF(IMPAR(2).EQ.-1) GO TO 214
      WRITE(LUI,9210) 
9210  FORMAT("Control Parameters (<>=NONE)_") 
      CALL READQ(LUI,IPARMQ,20,IERR)
      CALL UCASE(IPARMQ(2),-IPARMQ) 
C     EXIT IF END MARK
      IF (IPARMQ(2) .EQ. 2H::) GO TO 980
      IA=IGETQ(IPARMQ,1)
      IF (IA .EQ. 40B .OR. IA .EQ. 60B) IPARMQ=0
C     TRIM TRAILING SPACES AND ADD LEADING COMMA
214   CALL TRIMQ(IPARMQ)
      IF (IPARMQ .GT. 0) CALL MERGQ(IPARMQ,COMQ,IPARMQ) 
C     CHECK FOR DEBUG MODE IN FORTRAN OR RAT4 
      IDEBUG=0
      IF (IXQ(IPARMQ,DQ,0,0) .GT. 0) IDEBUG=1 
      ILIST=0 
      IF (IPOSQ(IPARMQ,LQ,0) .GT. 0 .OR. IPOSQ(IPARMQ,CQ) .GT. 0)ILIST=1
C CHECK FOR K OPTION - DELETES COMMENTS FROM LISTING
      IF (IPOSQ(IPARMQ,KQ,0) .GT. 0) ILIST=2
C CHECK FOR PREPROCESSOR SOURCE OUTPUT
      IF (IPOSQ(IPARMQ,OQ,0) .GT. 0) 215,216
215   ILIST=1 
      KCP=1 
C REPLACE K OR O BY L FOR PROCESSING
216   IDUM=IXQ(IPARMQ,KQ,LQ,1)
      IDUM=IXQ(IPARMQ,OQ,LQ,1)
C     Add parameters to control statement card images 
      DO 217 I=1,8
      CALL MERGQ(LFTN4(1,I),LFTN4(1,I),IPARMQ)
217   CONTINUE
C 
C READ ROUTINE NAMES. "::" TO END LIST. 
      NN=0
C     IF NON-INTERACTIVE MODE, CONTINUE PARSING INPUT BUFFER FOR ROUTINE NAMES
      IF (IMPAR(2) .NE. -1) GO TO 220 
      JSTRC=ISTRC-2    !Prepare to parse IB as a string 
      JSTRC0=JSTRC
      IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)    !Update ISTRC 
      IP=KPRSQ(IB,IPBUF,16,JSTRC,2,2H ,)
C     CHECK FOR "ALL" MODE
      IF (NN .EQ. 0 .AND. 
     .    (IP.EQ.0.OR.IPBUF.EQ.0.OR.KMPRQ(IPBUF,ZERQ).EQ.1)) GO TO 260  
      JSTRC=JSTRC0        !Restore value of JSTRC 
      GO TO 234 
220   IF (IMPAR(2) .EQ. -1) GO TO 290 
      WRITE(LUI,230)
230   FORMAT("Routine Names (<>=ALL, <::>=END)? _") 
      IB(2)=2H
      REG=REIO(1,400B+LUI,IB(2),-128) 
      IB=IREG(2)
      CALL UCASE(IB(2),-IB) 
      IF (IB.LE.2.AND.IB(2).EQ.2H  .AND.NN.EQ.0) GO TO 260
      IF (IB(2) .EQ. 2H:: .AND. NN .EQ. 0) GO TO 980
      JSTRC=1 
234   DO 250 I=1,32767
      IF (NN .GE. NAMSX) GO TO 290
      CALL FILLQ(IPBUF,1,16)
      IF (KPRSQ(IB,IPBUF,16,JSTRC,0,2H ,) .EQ. 0) GO TO 220 
      IF (IPBUF(2) .EQ. 2H::) GO TO 290 
      NN=NN+1 
      IDUM=IXQ(IPBUF,SPACQ,0,0) 
      CALL WMOVE(IPBUF,NAMS(1,NN),8)
250   CONTINUE
      GO TO 290 
C 
C "ALL" MODE
260   NAMT=0
      NN=1
      IF (LUD .EQ. 0 .OR. KCNC .NE. 0) GO TO 280
C     CHECK FOR NON-INTERACTIVE MODE
      IF (IMPAR(2) .NE. -1) GO TO 268 
C     CONTINUE PARSING TO GET COMMAND FILE NAME, IF ANY 
      IDUM=NAMR(IPBUF,IB,ILOG,ISTRC)
      IF (IAND(IPBUF(4),3) .NE. 3) GO TO 280
      NAMT=IPBUF
      NAMT(2)=IPBUF(2)
      NAMT(3)=IPBUF(3)
      LUNAMT=LUD
      IF (IPBUF(6) .GT. 0) LUNAMT=IPBUF(6)
      GO TO 280 
C     INTERACTIVE MODE
268   WRITE(LUI,270)
270   FORMAT("LINK Command File NAMR (<>=NONE)? _") 
      IF (IFNAM(LUI,IPBUF)) 278,980,271 
271   IF (IPBUF .EQ. 2H0  .OR. IPBUF .EQ. 2H  ) GO TO 278 
      CALL UCASE(IPBUF,-6)
      CALL WMOVE(IPBUF,NAMT,3)
      LUNAMT=LUD
      IF (IPBUF(6) .GT. 0) LUNAMT=IPBUF(6)
C     CHECK FOR EXISTING FILE WITH NAME NAMT. 
      CALL OPEN(IDCBO,IERR,NAMT,1,0,LUNAMT) 
      CALL CLOSE(IDCBO) 
      IF (IERR .GT. 0 .OR. IERR .EQ. -8) 272,280
272   IF (LUNAMT .EQ. 0) LUNAMT=-IAND(IDCBO,77B)
      IDUM=CINFO(IBB,256,LUNAMT,IDUM,IDUM,LUNAMT)  !Get cartref 
      CALL CNVT(LUNAMT,LUNAMX,0)               !Convert to ASCII
273   WRITE(LUI,274) NAMT,LUNAMX
274   FORMAT("OK to overwrite existing file ",3A2,"::",3A2,"? [Y] _")   
      READ(LUI,276) LYN 
276   FORMAT(A2)
      CALL UCASE(LYN,-2)
      IF (LYN .EQ. 2HY  .OR. LYN .EQ. 2H  ) THEN
          GO TO 280 
      ELSE IF (LYN .EQ. 2H::) THEN
          GO TO 980 
      ELSE IF (LYN .NE. 2HN ) THEN
          GO TO 273 
      ENDIF 
278   NAMT=0
C SET "ALL" PARAMETERS
280   KALL=1HY
      IN=0
C 
C EXIT IF NO ROUTINES CALLED FOR
290   IF(NN.EQ.0) GO TO 980 
C 
C     GET CURRENT DATE AND TIME AND CONSTRUCT DATE/TIME STRING
      CALL IDATE(IT)
      CALL CODE 
      WRITE(LCDQ,295) IT
295   FORMAT(2X,I4,2I2,":",I2,":",3I2)
      LCDQ=18 
      IDUM=IXQ(LCDQ,SPACQ,ZERQ,0) 
      GO TO 999 
C ABORT EXITS 
980   KGO=980 
      GO TO 999 
989   KGO=989 
      GO TO 999 
C 
C IMMEDIATE EXIT FROM COMPC 
1000  KGO=1000
999   RETURN
      END 
      SUBROUTINE FROUT(LPR,MXPAR) 
C# LAST COMPC'ED  870105:21:31    : 
C SUBROUTINE TO FIND INDIVIDUAL ROUTINES WITHIN A FILE
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER LPR(1)
      INTEGER COMQ(2),FUNCQ(5),LPQ(2),
     1  NAMQ(3),PRGQ(5),SPACQ(2),SUBQ(6)
      INTEGER LBD(6),LBDBD(3),LFNC(9),LFND(13),LFNI(9),LFNL(9),LFNR(7), 
     .        LFTN4X(10),LCHR(6)
      INTEGER LOPTNS(6,13)
      INTEGER LP(13,10),ITITLE(42),STAR2(2),STAR4(2),STAR6(2),STAR8(2), 
     .        STAR16(3),LALIAS(22,5),LLIST(22),LCODE(22),LMSEG(22), 
     .        LCDS(12),LTRACE(12) 
      EQUIVALENCE (LP(1,1),PRGQ),(LP(1,2),SUBQ),(LP(1,3),FUNCQ),
     1  (LP(1,4),LFNI),(LP(1,5),LFNR),(LP(1,6),LFNL),(LP(1,7),LFND),
     2  (LP(1,8),LFNC),(LP(1,9),LBD),(LP(1,10),LCHR)
      DATA PRGQ   /   7,8HPROGRAM / 
      DATA SUBQ   /  10,10HSUBROUTINE/
      DATA FUNCQ  /   8,8HFUNCTION/ 
      DATA LFNI   /  15,16HINTEGERFUNCTION /
      DATA LFNR   /  12,12HREALFUNCTION/
      DATA LFNL   /  15,16HLOGICALFUNCTION /
      DATA LFND   /  23,24HDOUBLEPRECISIONFUNCTION /
      DATA LFNC   /  15,16HCOMPLEXFUNCTION /
      DATA LBD    /   9,10HBLOCKDATA /
      DATA LCHR   /   9,10HCHARACTER /
C 
      DATA COMQ   /   1,2H, / 
      DATA LPQ    /   1,2H( / 
      DATA NAMQ   /   3,4HNAM / 
      DATA SPACQ  /   1,2H  / 
      DATA LBDBD  /   4,4HBDBD/ 
      DATA LOPTNS /   4,10H$EMA      ,
     .                6,10H$FILES    ,
     .                6,10H$STRUC    ,
     .                5,10H$PARM     ,
     .                5,10H$PAGE     ,
     .                6,10H$TITLE    ,
     .                6,10H$ALIAS    ,
     .                5,10H$LIST     ,
     .                5,10H$CODE     ,
     .                5,10H$MSEG     ,
     .                4,10H$CDS      ,
     .                6,10H$TRACE    ,
     .               10,10H      STRU/
      DATA STAR2  /   2,2H*2/ 
      DATA STAR4  /   2,2H*4/ 
      DATA STAR6  /   2,2H*6/ 
      DATA STAR8  /   2,2H*8/ 
      DATA STAR16 /   3,4H*16 / 
C 
C MAIN LOOP TO SEARCH FOR BEGINNING OF ROUTINE
300   CONTINUE
C CHECK BREAK FLAG
      IF(IFBRK(IDUM)) 978,301 
C SET FLAG TO IGNORE $INCLUDE UNTIL ROUTINE FOUND 
301   LEN=-32767
      CALL READI(IDCBI,IERR,IB,40,LEN,LPR)
C SKIP OUT IF END OF FILE 
      IF(LEN.EQ.-1) GO TO 770 
C CHECK FOR CONTROL STATEMENT 
      CALL MERGQ(IBB,IB)
      CALL UCASE(IBB(2),-IBB)          !Convert to upper case 
      IF(ICPR(IBB,LFTN4,10,8,-5,ICN,2H ,).EQ.0) 
     1  GO TO (300,350) ICNTRL+1
C     IF 'FTN5' (OBSOLETE), CHANGE TO POINT TO FTN4 COMPILER
      IF (ICN .EQ. 4) ICN=3 
      ICNTRL=ICN
      LF4XY=0 
      LF4IJ=0 
      GO TO (320,310,320,320,322,320,320,310) ICNTRL
C            F4X ASM F4  F5  RAT4  F6 F7 MAC
C     ASMB
310   ICOMNT=52B
      ICDATE=2H*# 
      GO TO 330 
C     FORTRAN 
320   ICOMNT=103B 
      ICDATE=2HC# 
      GO TO 326 
C     RAT4
322   ICOMNT=43B
      ICDATE=2H#! 
C     CHECK FOR ",X" OR ",Y" IN FTN CONTROL STATEMENT.
C     IF FOUND, ATTACH TO FTN4 CONTROL STATEMENT AUTOMATICALLY. 
326   IF (IPOSQ(IBB,LF4X,5) .GT. 0) CALL MERGQ(LF4XY,LF4X)  
      IF (IPOSQ(IBB,LF4Y,5) .GT. 0) CALL MERGQ(LF4XY,LF4Y)  
C     SIMILARLY, CHECK FOR ",I" OR ",J" IN FTN4X CONTROL STATEMENT
C     AND ATTACH TO FTN4X CONTROL STATEMENT AUTOMATICALLY.
      IF (IPOSQ(IBB,LF4I,5) .GT. 0) CALL MERGQ(LF4IJ,LF4I)  
      IF (IPOSQ(IBB,LF4J,5) .GT. 0) CALL MERGQ(LF4IJ,LF4J)  
      KFILES=0
      KSTRUC=0
      KPAGE=0 
      KTITLE=0
      KALIAS=0
      NALIAS=0
      KCDS=0
      KTRACE=0
      NDIR=0
C SET $PARM POINTER TO INDICATE PREVIOUS $PARM'S EXIST
      KPAR=-KPAR
      KEMA=0
330   CALL READI(IDCBI,IERR,IB,40,LEN,LPR)
      IF(LEN.EQ.-1) GO TO 770 
      CALL MERGQ(IBB,IB)
      CALL UCASE(IBB(2),-IBB)     !Convert to upper case
      IF (ICNTRL .EQ. 2 .OR. ICNTRL .EQ. 8) GO TO 420 
C     CHECK FOR, AND IGNORE, COMMENTS 
      IC1=IOR(020000B,IGETQ(IB,1))
      IF (IC1 .EQ. 2H C .OR. IC1 .EQ. 2H *) GO TO 330 
C CHECK FOR '$' directives
      IF (ICPR(IBB,LOPTNS,6,13,0,ICN,2H () .NE. 0)  
     .   GO TO (332,334,336,340,346,347,348,349,351,352,353,354,336) ICN  
      GO TO 350 
C     $EMA found
332   KEMA=NDIR+1 
      NDIR=KEMA 
      CALL MERGQ(LLEMA,IB)
      CALL FILLQ(LLEMA,LLEMA+1,LLEMA+2) 
      GO TO 330 
C     $FILES found
334   KFILES=NDIR+1 
      NDIR=KFILES 
      CALL MERGQ(LLFILE,IB) 
      CALL FILLQ(LLFILE,LLFILE+1,LLFILE+2)
      GO TO 330 
C     $STRUC found
336   KSTRUC=1
      ISTRC=1 
      ILABEL=KVALQ(IB,IERR,ISTRC) 
      IF (IERR .EQ. 1) ILABEL=32000 
      GO TO 330 
C     $PARM FOUND 
340   IF(JPAR.LT.MXPAR-24) GO TO 342
345   WRITE(LUII,9345) NAMC 
9345  FORMAT(3A2,": Too many $PARM's - increase partition size!") 
      CALL CLOSE(IDCBP) 
      GO TO 989 
342   IF(KPAR.GE.0) GO TO 343 
      KPAR=0
      JPAR=1
343   KPAR=KPAR+1 
C     GET DELIMITER AFTER BLANKS AFTER $PARM
      ISTRC=6 
      LDLM=IGETQ(IB,NFNBQ(IB,IBB,1,ISTRC))
C     GET TARGET AND REPLACEMENT STRINGS
      IDUM=KPRSQ(IB,LPR(JPAR),40,ISTRC,0,LDLM)
      CALL TRIMQ(LPR(JPAR)) 
      CALL LTRMQ(LPR(JPAR)) 
      JPAR=(LPR(JPAR)+1)/2+JPAR+1 
      IDUM=KPRSQ(IB,LPR(JPAR),40,ISTRC,0,LDLM)
      CALL TRIMQ(LPR(JPAR)) 
      CALL LTRMQ(LPR(JPAR)) 
      JPAR=(LPR(JPAR)+1)/2+JPAR+1 
      GO TO 330 
C     $PAGE directive found 
346   KPAGE=NDIR+1
      NDIR=KPAGE
      GO TO 330 
C     $TITLE directive found
347   KTITLE=NDIR+1 
      NDIR=KTITLE 
      IB=MIN0(IB,80)
      CALL MERGQ(ITITLE,IB) 
      CALL FILLQ(ITITLE,ITITLE+1,ITITLE+2)
      GO TO 330 
C     $ALIAS found
348   IF (NALIAS .EQ. 0) THEN 
          KALIAS=NDIR+1 
          NDIR=KALIAS 
      ELSE IF (NALIAS .EQ. 5) THEN
          WRITE(LUII,9348) NAMC 
9348      FORMAT(3A2,":Too many $ALIAS's - aborting!")
          GO TO 989 
      ENDIF 
      NALIAS=NALIAS+1                !# of $ALIAS statements
      IB=MIN0(IB,40)
      CALL MERGQ(LALIAS(1,NALIAS),IB) 
      CALL FILLQ(LALIAS(1,NALIAS),LALIAS(1,NALIAS)+1,LALIAS(1,NALIAS)+2)
      GO TO 330 
C     $LIST found 
349   KLIST=NDIR+1
      NDIR=KLIST
      IB=MIN0(IB,40)
      CALL MERGQ(LLIST,IB)
      CALL FILLQ(LLIST,LLIST+1,LLIST+2) 
      GO TO 330 
C     $CODE found 
351   KCODE=NDIR+1
      NDIR=KCODE
      IB=MIN0(IB,40)
      CALL MERGQ(LCODE,IB)
      CALL FILLQ(LCODE,LCODE+1,LCODE+2) 
      GO TO 330 
C     $MSEG found 
352   KMSEG=NDIR+1
      NDIR=KMSEG
      IB=MIN0(IB,40)
      CALL MERGQ(LMSEG,IB)
      CALL FILLQ(LMSEG,LMSEG+1,LMSEG+2) 
      GO TO 330 
C     $CDS found
353   KCDS=NDIR+1 
      NDIR=KCDS 
      IB=MIN0(IB,20)
      CALL MERGQ(LCDS,IB) 
      CALL FILLQ(LCDS,LCDS+1,LCDS+2)
      GO TO 330 
C     $TRACE found
354   KTRACE=NDIR+1 
      NDIR=KTRACE 
      IB=MIN0(IB,20)
      CALL MERGQ(LTRACE,IB) 
      CALL FILLQ(LTRACE,LTRACE+1,LTRACE+2)
      GO TO 330 
C 
350   IF (ICNTRL .EQ. 2 .OR. ICNTRL .EQ. 8) GO TO 420 
C FORTRAN/RAT4 CHECK FOR BEGINNING OF ROUTINE 
      IF (IAND(IB(2),177400B) .NE. 020000B) GO TO 300 
C CHECK FOR PROGRAM CARD WITH FIRST 28 CHARACTERS 
      ISTRC=2 
      IDUM=NFNBQ(IB,IBB,39,ISTRC) 
      CALL UCASE(IBB(2),-IBB) 
C     EXCHANGE *2,*4,*6, OR *8 WITH NULL STRING 
      IDUM=IXQ(IBB,STAR2,0,1) 
      IDUM=IXQ(IBB,STAR4,0,1) 
      IDUM=IXQ(IBB,STAR6,0,1) 
      IDUM=IXQ(IBB,STAR8,0,1) 
      IDUM=IXQ(IBB,STAR16,0,1)
      IF(ICPR(IBB,LP,13,10,0,ICP,0).EQ.0) GO TO 300 
      IF (ICP .EQ. 10) THEN      !Character function
          IP=IPOSQ(IBB,FUNCQ,10)  !Look for 'function'
          IF (IP .EQ. 0) GO TO 300
          CALL SEGQ(IBB,IP+8,IBB,IBB)  !Delete 'character function' 
      ELSE
          IDUM=IXQ(IBB,LP(1,ICP),0,1)  !Delete program word 
      ENDIF 
C IF BLOCK DATA AND NO NAME, REPLACE WITH "BDBD"
      IF(ICP.EQ.9.AND.IBB.EQ.0) CALL MERGQ(IBB,LBDBD) 
C RESET $PARM POINTER IN CASE NO NEW $PARM'S
      KPAR=IABS(KPAR) 
      IF (IPOSQ(IBB,LPQ,1) .GT. 0) IBB=IPOSQ(IBB,LPQ,1)-1 !Terminate at '(' 
      ICFLAG=1
      GO TO 435 
C ASMB - CHECK FOR NAM STATEMENT
420   IF (IGETQ(IB,1) .EQ. ICOMNT) GO TO 300
C     GET FIRST 3 CHARACTERS FOLLOWING FIRST SPACE IN LINE
      ISTRC=IPOSQ(IB,SPACQ,1) 
      IF (ISTRC .LE. 0) GO TO 300 
      IDUM=NFNBQ(IB,IBB,3,ISTRC)
      IF (IBB .LT. 3 .OR. IPOSQ(IBB,NAMQ,1) .NE. 1) GO TO 300 
C     GET ROUTINE NAME
      CALL FILLQ(IBB,1,16)
      IDUM=KPRSQ(IB,IBB,5,ISTRC,0,2H  ) 
      ICFLAG=1
435   IF (IPOSQ(IBB,COMQ,1) .GT. 0) IBB=IPOSQ(IBB,COMQ,1)-1 !Terminate at ',' 
      IF (IBB .GT. 16) IBB=16 
      IF(KALL.NE.1HY) GO TO 460 
C 
C CHECK FOR NAME ARRAY OVERFLOW IN "ALL" MODE 
      IF (IN .LT. NAMSX) GO TO 450
      WRITE(LUII,440) NAMC,NAMSX,(IBB(I),I=2,8) 
440   FORMAT(3A2,": More than",I4," routines found. ",8A2,
     1  " is first not done.")
      GO TO 780 
C STEP NUMBER OF ROUTINES FOUND 
450   IN=IN+1 
      NN=IN 
C     SAVE ROUTINE NAME 
      CALL FILLQ(NAMS(1,IN),1,16) 
      CALL MERGQ(NAMS(1,IN),IBB)
      GO TO 480 
C 
C     "SPECIFIED ROUTINES" MODE. SEARCH NAMS FOR MATCH. 
460   I=0 
      DO 470 IN=1,NN
      IF (NAMS(1,IN).LE.0) GO TO 470
      I=1 
      IF (KMPRQ(NAMS(1,IN),IBB) .EQ. 0) GO TO 470 
      GO TO 480 
470   CONTINUE
C     IF I=0, ALL NAMES HAVE BEEN FOUND 
      IF (I .EQ. 0) GO TO 970 
C     NO NAMS MATCH FOUND. CONTINUE SEARCHING FILE. 
      GO TO 300 
C 
C FOUND ROUTINE. OPEN SCRATCH FILE NON-EXCLUSIVE, NON-UPDATE
C OPEN ONLY ONCE IF PREPROCESSOR SOURCE OUTPUT
480   IF(KCP.GT.1) GO TO 489
      CALL OPEN(IDCBO,IERR,NAMO(2),1,0,ICRO,IDCBOS) 
C     WRITE(1,6039) (NAMO(IZ),IZ=2,4),ICRO,IERR 
C6039 FORMAT("9-OPEN NAMO,ICRO,IERR=",3A2,1X,O7,I6) 
      IF(KCP.NE.0) KCP=KCP+1
      IF (IERR .GE. 0) GO TO 488
      IF (IERR .NE. -6) GO TO 485 
C     ATTEMPT TO CREATE SCRATCH FILE
      ISIZE=100 
      CALL CREAT(IDCBO,IERR,NAMO(2),ISIZE,3,0,ICRO,IDCBOS)
C     WRITE(1,6033) (NAMO(IZ),IZ=2,4),ICRO,IERR 
C6033 FORMAT("3-NAMO,ICRO,IERR=",3A2,1X,O7,I6)
      IF(IERR.GE.0) GO TO 488 
485   WRITE(LUII,486) NAMC,IERR,NAMO
486   FORMAT(3A2,": Error",I4," opening ",4A2)
      GO TO 989 
C 
C START FILE WITH COMPILER CONTROL CARD.
488   CALL MERGQ(LFTN4X,LFTN4(1,ICNTRL))
      GO TO (484,487,484,484,484,484,484,487) ICNTRL
C     ADD ",X" OR ",Y" TO FTN4/FTN4X CONTROL STATEMENT IF NECESSARY 
484   IF (IPOSQ(LFTN4X,LF4X,5) .EQ. 0 .AND. IPOSQ(LFTN4X,LF4Y,5) .EQ. 0)
     .    CALL MERGQ(LFTN4X,LFTN4X,LF4XY) 
      IF (IPOSQ(LFTN4X,LF4I,5) .EQ. 0 .AND. IPOSQ(LFTN4X,LF4J,5) .EQ. 0)
     .    CALL MERGQ(LFTN4X,LFTN4X,LF4IJ) 
487   CALL MERGQ(LFTN4X,LFTN4X,SPACQ) 
      CALL WRITF(IDCBO,IERR,LFTN4X(2),LFTN4X/2) 
C IF NOT ASMB OR BLOCK DATA, WRITE $EMA OR $FILES DIRECTIVE IF USED 
      IF (ICNTRL .EQ. 2 .OR. ICNTRL .EQ. 8) GO TO 489 
      DO 490 I=1,NDIR 
      IF (ICP .EQ. 9) GO TO 491      !BLOCK DATA
      IF (KEMA .EQ. I) CALL WRITF(IDCBO,IERR,LLEMA(2),(LLEMA+1)/2)
      IF (KFILES .EQ. I) CALL WRITF(IDCBO,IERR,LLFILE(2),(LLFILE+1)/2)
      IF (KALIAS .EQ. I) THEN 
          DO 492 J=1,NALIAS 
          CALL WRITF(IDCBO,IERR,LALIAS(2,J),(LALIAS(1,J)+1)/2)
492       CONTINUE
      ENDIF 
      IF (KLIST .EQ. I) CALL WRITF(IDCBO,IERR,LLIST(2),(LLIST+1)/2) 
      IF (KCODE .EQ. I) CALL WRITF(IDCBO,IERR,LCODE(2),(LCODE+1)/2) 
      IF (KMSEG .EQ. I) CALL WRITF(IDCBO,IERR,LMSEG(2),(LMSEG+1)/2) 
      IF (KCDS .EQ. I) CALL WRITF(IDCBO,IERR,LCDS(2),(LCDS+1)/2)
      IF (KTRACE .EQ. I) CALL WRITF(IDCBO,IERR,LTRACE(2),(LTRACE+1)/2)
491   IF (KPAGE .EQ. I) CALL WRITF(IDCBO,IERR,6H$PAGE ,3) 
      IF (KTITLE .EQ. I) CALL WRITF(IDCBO,IERR,ITITLE(2),(ITITLE+1)/2)
490   CONTINUE
      KPAGE=0 
C WRITE COMPILER MESSAGE
489   WRITE(LUI,730) NAMC,(NAMS(I,IN),I=2,9)
730   FORMAT(3A2,": ",8A2," in progress (_")
      CALL PUTQ(LFTN4X,LFTN4X,2H )) 
      CALL WRITQ(LUI,LFTN4X)
C     WRITE(1,735) NAMC,(NAMS(I,IN),I=2,9)
C735  FORMAT("/",3A2,"/",8A2,"_") 
      GO TO 999 
C NORMAL END OF INPUT FILE - SET FLAG FOR CLEAN UP
770   KGO=770 
      GO TO 999 
780   KGO=780 
      GO TO 999 
970   KGO=970 
      GO TO 999 
C BREAK 
978   KGO=978 
      GO TO 999 
C ERROR RETURN
989   KGO=989 
999   RETURN
      END 
      SUBROUTINE PROUT(LPR) 
C# LAST COMPC'ED  870105:21:16
C SUBROUTINE TO PROCESS A SINGLE ROUTINE TO OUTPUT FILE 
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER IST1(51),IST2(51),IST3(51),IST4(51),LPR(1)
      DATA IST1 /2HIF,48,3,48*0/
      DATA IST2 /2HWH,48,3,48*0/
      DATA IST3 /2HFO,48,3,48*0/
      DATA IST4 /2HCA,48,3,48*0/
C INITIALIZE STRUCTURED COMPILATION ERROR FLAG
      KSERR=0 
C INITIALIZE LABEL SEQUENCE 
      ILABLI=ILABEL 
C INITIALIZE NAMELIST FLAG
      KNML=-1 
C LOOP FOR COPYING ROUTINE
500   CONTINUE
C CHECK BREAK FLAG
      IF(IFBRK(IDUM)) 978,501 
501   CONTINUE
C CHECK FOR DATE CARD 
      CALL CDATE(IB,IDCBI,ICNTRL,KDATE,ICFLAG,ICDATE,LCDQ)
C IF COMMENT OR CONTINUATION CARD SKIP SPECIAL PREPROCESSING AND END CHECK
      GO TO (502,515,520),IWCL(IB,ICOMNT,ICNTRL,ILIST,IDEBUG) 
C STRIP FIRST CHARACTERS FOR CHECKING 
502   ISTRC=7 
      IB11=IB(1)
      IF(IB(1).GT.72) IB(1)=72
      IDUM=NFNBQ(IB,IBB,7,ISTRC)
      IB(1)=IB11
      CALL UCASE(IBB(2),-IBB)    !Convert to upper case 
C CHECK FOR LITERAL STRINGS 
      IF (ICNTRL.EQ.2 .OR. ICNTRL.EQ.5 .OR. ICNTRL.EQ.8) GO TO 503
      GO TO (503,520),LTRL(IB,IBB,IDCBI,IB(42),NAMC,NAMD,ICRO,LPR)
503   CONTINUE
C CHECK FOR STRUCTURED INSTRUCTIONS IF FLAG SET 
      IF(KSTRUC.EQ.0) GO TO 504 
      GO TO (500,504,520),ISTRU(IB,IBB,IBB(42),IDCBI,ILIST,IDEBUG,
     1  ILABLI,IST1,IST2,IST3,IST4,LPR) 
504   CONTINUE
C CHECK FOR END CARD
      GO TO (506,999),IENDC(IB,IBB,ISTRC,ICNTRL,ICP,KCP,
     1  KSTRUC,IST1,IST2,IST3,IST4) 
506   CONTINUE
C CHECK FOR NAMELIST
      GO TO (500,507,520),NMLST(IB,IBB,IDCBI,KNML,LUI,LPR)
507   CONTINUE
C WRITE LINE
515   CALL WRIT(IB) 
C 
C READ NEXT CARD OF ROUTINE 
520   CALL READI(IDCBI,IERR,IB,40,LEN,LPR)
C LOOP BACK FOR PROCESSING UNLESS END OF FILE 
      IF (LEN .EQ. -1) GO TO 540
      GO TO 500 
540   KGO=760 
      GO TO 999 
C BREAK 
978   KGO=978 
999   RETURN
      END 
      SUBROUTINE COMPP
C# LAST COMPC'ED  870105:21:16 :
C SUBROUTINE TO COMPILE OUTPUT FILE 
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER NAMSQ(4)
C IF PREPROCESSOR SOURCE OUTPUT, SKIP COMPILATION 
C AND FILE CLOSE BUT FLAG ROUTINE AS DONE 
C LIKEWISE IF STRUCTURED ERROR AND NO LISTING AND NO LISTING FILE REQUESTED 
      IF(KCP.NE.0.OR.(KSERR.NE.0.AND.ILIST.EQ.0.AND.LUO.NE.1H".AND. 
     1                LUO.NE.1H')) 541,542
C SET ERROR FLAG
541   NAMS(1,IN)=-KSERR 
      GO TO 999 
C IF NO STRUCTURED, $PARM, OR ($)INCLUDE ERROR, PROCEED WITH COMPILATION
542   IF(KSERR.EQ.0) GO TO 610
C LISTING REQUESTED - WRITE SCRATCH FILE TO OUTPUT UNIT OR FILE 
      CALL RWNDF(IDCBO) 
      IF(LUO.EQ.6) WRITE(LUO,9500)
9500  FORMAT(1H1) 
C IF LISTING TO FILE, OPEN OR CREATE FILE 
      IF(LUO.EQ.1H") 550,570
550   NAMSQ=1 
      CALL PUTQ(NAMSQ,1,47B)
      CALL MERGQ(NAMSQ,NAMSQ,NAMS(1,IN))
      CALL FILLQ(NAMSQ,NAMSQ+1,6) 
      CALL OPEN(IBB,IERR,NAMSQ(2),0,0,LUD)
      IF(IERR .LT. 0) THEN
          CALL CREAT(IBB,IERR,NAMSQ(2),24,3,0,LUD)
C         WRITE(1,6034) (NAMSQ(IZ),IZ=2,4),LUD,IERR 
C6034     FORMAT("4-NAMSQ,LUD,IERR=",3A2,1X,O7,I6)
      ENDIF 
      IF(IERR.LT.0) 560,565 
C SET ERROR FLAG FOR FINAL LISTING
560   NAMS(1,IN)=-KSERR 
      WRITE(LUII,9560) NAMC,IERR,NAMSQ(2),NAMSQ(3),NAMSQ(4),LUDX
9560  FORMAT(3A2,": Error",I4," creating list file ",3A2,"::",3A2)
      GO TO 999 
565   CONTINUE
C SET ERROR FLAG
570   NAMS(1,IN)=-KSERR 
      DO 600 II=1,32767 
      CALL READF(IDCBO,IERR,IB,40,LEN)
      IF(LEN.EQ.-1) GO TO 605 
      IF(LUO.NE.1H'.AND.LUO.NE.1H") WRITE(LUO,9600) (IB(I),I=1,LEN) 
      IF(LUO.EQ.1H") CALL WRITF(IBB,IERR,IB,LEN)
      IF(LUO.EQ.1H') CALL WRITF(IDCBL,IERR,IB,LEN)
9600  FORMAT(1X,40A2) 
600   CONTINUE
605   IF(LUO.EQ.1H") CALL CLOSE(IBB)
      GO TO 999 
C CLOSE SCRATCH FILE
610   CALL CLOSE(IDCBO) 
C SCHEDULE FTN4/4X OR ASMB
      CALL CCMPL
999   RETURN
      END 
      SUBROUTINE CCMPL
C# LAST COMPC'ED  870105:21:16: 
C SUBROUTINE TO RUN FTN4/4X/ASMB AND TO ADD TO COMBINED RELOCATABLE OR LISTING
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER IFLAG(5),LROUT(7),NAMSR(9),NAMOQ(9) 
      INTEGER LCM(2),LCC(2),LQ1(2),LPRR(2),LC(2),LC5C50(4)
      LOGICAL NAMRC 
      DATA LROUT /2HRO,2HUT,2HIN,2HE-,3*2H  / 
      DATA LCM /1,1H,/, LCC /2,2H::/, LQ1 /1,1H'/, LPRR /1,1H%/,
     .     LC /2,2H: /,LC5C50/5,2H:5,2H:5,2H0 / 
      IF (KCNC .EQ. 1HD) GO TO 5112 
C CREATE DUMMY RUN STRING TO BE PARSED BY FTN4/4X/ASMB WITH EXEC 14 
C ,,NAMO::
      CALL MERGQ(IB,LCM,LCM,NAMO,LCC) 
C ,,NAMO::ICRO
      ISTRC=IB+1
      CALL KSTRQ(ICRO,IB,0,ISTRC) 
C ,,NAMO::ICRO, 
      CALL MERGQ(IB,IB,LCM) 
C LIST LU OR FILE 
      IF(LUO.EQ.1H'.OR.LUO.EQ.1H") 100,150
C FILE -
100   IF(LUO.EQ.1H") 110,120
C ,,NAMO::ICRO,'NAMS::LUD/ICRI
110   CALL MERGQ(IB,IB,LQ1,NAMS(1,IN),LCC)
      ISTRC=IB+1
      IF(LUD.EQ.0) CALL KSTRQ(ICRI,IB,0,ISTRC)
      IF(LUD.NE.0) CALL KSTRQ(LUD,IB,0,ISTRC) 
      GO TO 190 
C COMBINED - USE SCRATCH FILE ,,NAMO::ICRO,NAML 
C ,,NAMO::ICRO,NAML::ICRO 
120   CALL MERGQ(IB,IB,NAML,LCC)
      ISTRC=IB+1
      CALL KSTRQ(ICRO,IB,0,ISTRC) 
      GO TO 190 
C OUTPUT LU - ,,NAMO::ICRO,LUO
150   ISTRC=IB+1
      CALL KSTRQ(LUO,IB,0,ISTRC)
C ,,NAMO::ICRO,%N/LUO,
190   CONTINUE
C RELOCATABLE FILE OR NONE
      IF(LUD.NE.0.OR.KCNC.NE.0) 210,290 
C FILE - SEPARATED OR TO BE COMBINED
210   CALL MERGQ(IB,IB,LCM) 
      IF(KCNC.EQ.0) 220,250 
C SEPARATED - ,,NAMO::ICRO,%N/LUO,%NAMS:
220   CALL MERGQ(IB,IB,LPRR,NAMS(1,IN),LC)
C ,,NAMO::ICRO,%N/LUO,%NAMS:ISECUP
      ISTRC=IB+1
      CALL KSTRQ(ISECUP,IB,0,ISTRC) 
C ,,NAMO::ICRO,%N/LUO,%NAMS:ISECUP: 
      CALL MERGQ(IB,IB,LC)
C ,,NAMO::ICRO,%N/LUO,%NAMS:ISECUP:LUD
      ISTRC=IB+1
      CALL KSTRQ(LUD,IB,0,ISTRC)
C ,,NAMO::ICRO,%N/LUO,%NAMS:ISECUP:LUD:5:50 
      CALL MERGQ(IB,IB,LC5C50)
      GO TO 290 
C TO BE COMBINED - USE SCRATCH ,,NAMO::ICRO,%N/LUO,NAMP:: 
250   CALL MERGQ(IB,IB,NAMP,LCC)
C ,,NAMO::ICRO,%N/LUO,NAMP::ICRO
      ISTRC=IB+1
      CALL KSTRQ(ICRO,IB,0,ISTRC) 
C ,,NAMO::ICRO,%N/LUO,NAMP::ICRO:5:50 
      CALL MERGQ(IB,IB,LC5C50)
290   CALL FILLQ(IB,IB+1,72)
C SCHEDULE COMPILER 
      IDUM=IRP(LPROG(1,ICNTRL),0,IERR,-1) 
      IF (IERR.NE.0.AND.IERR.NE.23.AND.IERR.NE.-239) THEN 
          WRITE(LUI,9299) NAMC,IERR,(LPROG(J,ICNTRL),J=1,3) 
9299      FORMAT(3A2,": Error",I4," restoring program ",3A2,  
     .           "  --- aborting")
          GO TO 585     !Abort
      ENDIF 
C     write(1,6040) (ib(iz),iz=2,37)
C6040 format(36a2)
      CALL EXEC(23,LPROG(1,ICNTRL),1,0,0,0,0,IB(2),-72) 
C GET FLAGS 
      CALL RMPAR(IFLAG) 
C SAVE FLAG TOTAL IN NAMES ARRAY
      NAMS(1,IN)=-IFLAG 
C CONFIRM COMPILATION 
      WRITE(LUI,9300) NAMC,(NAMS(I,IN),I=2,9) 
9300  FORMAT(3A2,": ",8A2," compiled")
C CONFIRM RELOCATABLE IF INDIVIDUAL FILES 
      IF(LUD.NE.0.AND.KCNC.EQ.0) WRITE(LUI,9301) NAMC,
     1  (NAMS(I,IN),I=2,4),LUDX 
9301  FORMAT(3A2,":%",2A2,A1,"::",3A2,"    created")
C IF COMBINED RELOCATABLE, COPY TO FILE 
      IF(KCNC.EQ.1HN.OR.(KCNC.EQ.1HA.AND.NAMA.EQ.0)) 310,390
310   CALL COPRL(IBB,NAMP(2),ICRO,IB,185,IDCBP,0,0,IERR)
      IF(IERR.LT.0) GO TO 580 
390   CONTINUE
C IF COMBINED LISTING FILE, COPY LISTING TO FILE
      IF(LUO.EQ.1H') 410,490
410   CALL MOVEQ(NAMS(1,IN),1,LROUT,7,6)
      CALL COPRL(IBB,NAML(2),ICRO,IB,185,IDCBL,LROUT,7,IERR)
      IF(IERR.GE.0) GO TO 490 
      WRITE(LUII,9410) NAMC,IERR
9410  FORMAT(3A2,": Error",I4," writing combined listing - ", 
     1  "RUN ABORTED")
      GO TO 589 
490   CONTINUE
C IF RELOCATABLE TO BE REPLACED/ADDED IN USER FILE, 
      IF(KCNC.EQ.1HR.OR.(KCNC.EQ.1HA.AND.NAMA.NE.0)) 510,590
C OPEN CURRENT RELOCATABLE FILE 
510   CALL OPEN(IBB,IERR,NAMP(2),0,0,ICRO)
511   KCR=0 
      KADD=0
C READ CURRENT RELOCATABLE FILE FOR NAM RECORD
      DO 5111 I=1,32767 
      CALL READF(IBB,IERR,IDCBO,IDCBOS,LEN) 
      IF(LEN.EQ.-1.OR.IERR.EQ.-12) GO TO 540
      IF (NAMRC(IDCBO,NAMSR)) GO TO 5112 !Check for NAM or XNAM record
5111  CONTINUE
C OPEN USER RELOCATABLE FILE
5112  CALL OPEN(IDCBP,IERR,NAMM,0,ISECUP,LUD) 
C CREATE DUMMY FILE ON SAME LU
C-----NAMDD(3)=L2C
      CALL CREAT(IB,IERR,NAMDD,256,5,ISECUP,LUD)
C     WRITE(1,6035) (NAMDD(IZ),IZ=1,3),LUD,IERR 
C6035 FORMAT("5-NAMDD,LUD,IERR=",3A2,1X,O7,I6)
      IF(IERR.LT.0) GO TO 580 
C READ USER RELOCATABLE FILE
      DO 520 I=1,32767
      CALL READF(IDCBP,IERR,IDCBO,IDCBOS,LEN) 
      IF(LEN.EQ.-1) GO TO 530 
C CHECK IF NAM RECORD AND NOT ALREADY COPIED
      IF(KCR.EQ.0 .AND. NAMRC(IDCBO,NAMOQ)) 512,516 
C     CHECK FOR 'DELETE ROUTINE'
512   IF (KCNC .EQ. 1HD .AND. KMPRQ(NAMOQ,NAMA) .EQ. 1) GO TO 5132
C CHECK IF NEW RELOCATABLE SHOULD BE COPIED BEFORE THIS NAM 
      IF(KCNC.NE.1HA .OR. KMPRQ(NAMOQ,NAMA).EQ.0) GO TO 5121
      KADD=1
      CALL POSNT(IDCBP,IERR,-1) 
      GO TO 513 
C CHECK NAME OF ROUTINE FOR REPLACING 
5121  IF(KCNC .EQ. 1HD .OR. KMPRQ(NAMOQ,NAMSR) .EQ. 0) GO TO 516
C COPY CURRENT RELOCATABLE FILE UP TO NEXT NAM RECORD UNLESS ADDING 
      IF(KCNC.EQ.1HA) GO TO 5131
513   CALL COPRN(IBB,IDCBO,IDCBOS,IB,IERR)
      IF(IERR.LT.0) GO TO 580 
C SET FLAG THAT ROUTINE FOUND 
5132  KCR=1 
C IF ADDING BEFORE TARGET, SKIP TO COPY REST OF USER RELOCATABLE FILE 
      IF(KADD.EQ.1) GO TO 520 
C SKIP REST OF ROUTINE IN USER FILE 
5131  DO 514 J=1,32767
      CALL READF(IDCBP,IERR,IDCBO,IDCBOS,LEN) 
      IF(LEN.EQ.-1) GO TO 532 
      IF(NAMRC(IDCBO)) GO TO 516
514   CONTINUE
516   CALL WRITF(IB,IERR,IDCBO,LEN) 
C IF ERROR, SKIP TO MESSAGE AND CLEANUP 
      IF(IERR.LT.0) GO TO 580 
520   CONTINUE
C IF ROUTINE NOT FOUND, COPY AT END 
530   IF (KCNC .EQ. 1HD) GO TO 532
      IERR=0
      IF(KCR.EQ.0) CALL COPRN(IBB,IDCBO,IDCBOS,IB,IERR) 
      IF(IERR.LT.0) GO TO 580 
C RELEASE EXTRA SPACE 
532   CALL LOCF(IB,IERR,IREC,IRB,IOFF,JSEC) 
      ITRUN=JSEC/2-IRB-1
      CALL CLOSE(IB,IERR,ITRUN) 
C PURGE OLD FILE
      CALL PURGE(IDCBP,IERR,NAMM,ISECUP,LUD)
      IF(IERR.LT.0) GO TO 570 
C RENAME DUMMY
      CALL NAMF(IB,IERR,NAMDD,NAMM,ISECUP,LUD)
C CONFIRM REPLACEMENT 
      IF (KCNC .NE. 1HD) GO TO 534
          IF (KCR.NE.0)WRITE(LUI,9520) NAMC,(NAMA(I),I=2,9),
     .                 (NAMM(I),I=1,3),LUDX 
9520      FORMAT(3A2,": ",8A2," deleted from ",3A2,"::",3A2)
          IF (KCR.EQ.0)WRITE(LUI,9521) NAMC,(NAMA(I),I=2,9),
     .                 (NAMM(I),I=1,3),LUDX 
9521      FORMAT(3A2,": ",8A2," not found in ",3A2,"::",3A2)
          KGO=991 
          GO TO 590 
534   IF(KCNC.EQ.1HR) 
     .WRITE(LUI,9530) NAMC,(NAMS(I,IN),I=2,9),(NAMM(I),I=1,3),LUDX
9530  FORMAT(3A2,": ",8A2," replaced in ",3A2,"::",3A2) 
      IF(KCNC.EQ.1HA.AND.KCR.EQ.1) WRITE(LUI,9531) NAMC,
     .(NAMS(I,IN),I=2,9),(NAMA(I),I=2,9),(NAMM(I),I=1,3),LUDX 
9531  FORMAT(3A2,": ",8A2," added before ",8A2," in ",3A2,"::",3A2) 
C LOOP FOR NEXT ROUTINE IN CURRENT RELOCATABLE
      GO TO 511 
C CLOSE CURRENT RELOCATABLE FILE
540   CALL CLOSE(IBB) 
      GO TO 590 
C ERROR PURGING OLD RELOCATABLE FILE
570   WRITE(LUII,9570) NAMC,IERR
9570  FORMAT(3A2,": Error",I4," purging old combined relocatable - ", 
     1  "RUN ABORTED")
      GO TO 585 
C ERROR WRITING NEW FILE
580   WRITE(LUII,9580) NAMC,IERR
9580  FORMAT(3A2,": Error",I4," writing combined relocatable - ", 
     1  "RUN ABORTED")
585   CALL PURGE(IB,IERR,NAMDD,ISECUP,LUD)
      CALL PURGE(IBB,IERR,NAMP(2),0,ICRO) 
      NAMS(1,IN)=-99
589   KGO=810 
590   CONTINUE
      RETURN
      END 
      SUBROUTINE CLEAN
C# LAST COMPC'ED  870105:21:16 *
C SUBROUTINE TO CLEAN UP LISTS AND FILES
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER CINFO,SPACQ(2)
      DATA INF /0/, INFF /0/
      DATA SPACQ/1,2H  /
C CLEAR IBB FOR GLOBAL RETURN 
      DO 750 I=1,5
750   IBB(I)=0
C CHECK FOR PROPER ENTRY - NORMAL AND ERROR PROCESSING
      IF(KGO.EQ.760) GO TO 760
      IF(KGO.EQ.770) GO TO 770
      IF(KGO.EQ.780) GO TO 780
      IF(KGO.EQ.810) GO TO 810
      IF(KGO.EQ.970) GO TO 970
      IF(KGO.EQ.978) GO TO 978
      IF(KGO.EQ.980) GO TO 980
      IF(KGO.EQ.989) GO TO 989
      IF(KGO.EQ.991) GO TO 991
C 
C END OF FILE INDICATES NO END CARD FOR ROUTINE FOUND 
760   WRITE(LUII,761) NAMC,(NAMS(I,IN),I=2,9) 
761   FORMAT(3A2,": Routine ",8A2," has no END card") 
C GO TO PROPER SUMMARY
      IF (KALL .NE. 1HY) GO TO 940
      IN=IN-1 
      NN=IN 
      GO TO 780 
C     EOF FOUND 
770   IF (ICNTRL .NE. 0) GO TO 772
      WRITE(LUII,771) NAMC
771   FORMAT(3A2,": No compiler control card found!") 
      GO TO 990 
772   IF(KCP.EQ.0) GO TO 779
C SOURCE OUTPUT - COPY TO =FILE 
      CALL PUTQ(NAMI,-1,75B)
      CALL CLOSE(IDCBI) 
      CALL CREAT(IDCBI,IERR,NAMI,100,3,0,ICRI,IDCBIS) 
C     WRITE(1,6036) (NAMI(IZ),IZ=1,3),ICRI,IERR 
C6036 FORMAT("6-NAMI,ICRI,IERR=",3A2,1X,O7,I6)
      IF(IERR.GE.0) GO TO 773 
      WRITE(LUII,9773) NAMC,IERR,NAMI,ICRIX 
9773  FORMAT(3A2,": Error",I4," creating resolved file ",3A2,"::",
     1  3A2)
      IF(IERR.NE.-2) GO TO 779
      CALL OPEN(IDCBI,IERR,NAMI,0,0,ICRI,IDCBIS)
773   CALL RWNDF(IDCBO) 
      DO 774 II=1,32767 
      CALL READF(IDCBO,IERR,IB,40,LEN)
      IF(LEN.EQ.-1) GO TO 775 
      CALL WRITF(IDCBI,IERR,IB,LEN) 
774   CONTINUE
775   WRITE(LUII,9775) NAMC,NAMI,ICRIX
9775  FORMAT(3A2,": Source output file ",3A2,"::",3A2," finished")
C OTHERWISE, WRITE SUMMARIES FOR "ALL" OR "SPECIFIED FILES" MODES 
779   IF (KALL .EQ. 1HY) 780,940
C 
C ENTIRE FILE HAS BEEN SCANNED IN "ALL" MODE. 
C MAKE LINK COMMAND FILE IF REQUESTED.  
C     CLOSE AND PURGE SCRATCH FILE "CPCPxx", "LITLxx".
780   CALL CLOSE(IDCBO) 
      CALL PURGE(IDCBO,IERR,NAMO(2),1,ICRO) 
      CALL PURGE(IDCBO,IERR,NAMD(2),1,ICRO) 
C CHECK IF NO ROUTINES COMPILED 
      IF(NAMS(2,1).EQ.2HAL.AND.NAMS(3,1).EQ.2HL .AND.NAMS(4,1).EQ.2H  ) 
     1  790,810 
790   WRITE(LUII,800) NAMC
800   FORMAT(3A2,": ---No routines compiled---")
      GO TO 990 
810   IF (NAMT .EQ. 0) GO TO 870
820   ISIZE=2 
      CALL CREAT(IDCBO,IERR,NAMT,ISIZE,3,0,LUNAMT,IDCBOS) 
C     WRITE(1,6037) (NAMT(IZ),IZ=1,3),LUNAMT,IERR 
C6037 FORMAT("7-NAMT,LUNAMT,IERR=",3A2,1X,O7,I6)
      IF (IERR .NE. -2) GO TO 850 
      CALL PURGE(IDCBO,IERR,NAMT,0,LUNAMT)
      GO TO 820 
850   IF(IERR.LT.0) WRITE(LUII,860) NAMC,IERR 
860   FORMAT(3A2,": Error",I4," creating LINK file")  
      IF(IERR.LT.0) GO TO 930 
      IF (LUNAMT .EQ. 0) LUNAMT=-IAND(IDCBO,77B)
      IDUM=CINFO(IBB(6),256,LUNAMT,IDUM,IDUM,LUNAMT)
      CALL CNVT(LUNAMT,LUNAMX,0)
870   WRITE(LUII,880) NAMC
880   FORMAT(3A2,": Routines compiled--") 
C     WRITE LIBRARY CALL - GSFC SPECIFIC
C-----CALL WRITF(IDCBO,IERR,14HLI,$LIBHS     ,7)
      CALL WRITF(IDCBO,IERR,2HEC,1) 
      CALL WRITF(IDCBO,IERR,2HEB,1) 
      DO 910 IN=1,NN
      CALL CODE 
      WRITE(IB,890) (NAMS(I,IN),I=2,9),LUDX 
890   FORMAT(2X,"RE,%",8A2,"::",3A2)  
      IB=28 
      IDUM=IXQ(IB,SPACQ,0,0)       !Remove all embedded spaces
      CALL PUTQ(IB,IB+1,2H  ) 
      IF(NAMT(1).NE.0) CALL WRITF(IDCBO,IERR,IB(2),(IB+1)/2)
      WRITE(LUII,900) IN,(NAMS(I,IN),I=2,9) 
900   FORMAT(I2,". ",8A2) 
910   CONTINUE
C     WRITE "END" 
      IF(NAMT(1).NE.0) CALL WRITF(IDCBO,IERR,4HEND ,2)
      IF (LUD .NE. 0 .AND. NAMT .NE. 0) 
     .    WRITE(LUII,920) NAMC,NAMT,LUNAMX
920   FORMAT(3A2,": LINK command file ",3A2,"::",3A2," created")  
930   IF(NAMT.NE.0) CALL CLOSE(IDCBO) 
      GO TO 972 
C 
C     LIST ROUTINES NOT FOUND IN "SPECIFIED FILE" MODE
940   INN=0 
      DO 941 IN=1,NN
941   IF(NAMS(1,IN).GT.0) INN=1 
      IF(INN.EQ.0) GO TO 961
      WRITE(LUII,9940) NAMC 
9940  FORMAT(3A2,": Routines not found--")
      INN=0 
      DO 960 IN=1,NN
      IF(NAMS(1,IN).LE.0) GO TO 960 
      INN=INN+1 
      WRITE(LUII,900) INN,(NAMS(I,IN),I=2,9)
960   CONTINUE
961   CONTINUE
C     CLOSE AND PURGE SCRATCH FILE "CPCPxx", "LITLxx" 
970   CALL CLOSE(IDCBO) 
      CALL PURGE(IDCBO,IERR,NAMO(2),1,ICRO) 
      CALL PURGE(IDCBO,IERR,NAMD(2),1,ICRO) 
C LIST ROUTINES WITH FLAGS FROM FTN4/4X/ASMB
972   INN=0 
      DO 973 IN=1,NN
973   IF(NAMS(1,IN).LT.0) INN=1 
      IF(INN.EQ.0) GO TO 975
      WRITE(LUII,9973) NAMC 
9973  FORMAT(3A2,": Routines flagged--")
      DO 974 IN=1,NN
      IF(NAMS(1,IN).GE.0) GO TO 974 
C     KEEP TRACK OF #ROUTINES WITH ERRORS AND TOTAL# ERRORS 
      INF=INF+1 
      INFF=INFF-NAMS(1,IN)
      WRITE(LUII,9974) INF,(NAMS(I,IN),I=1,9) 
9974  FORMAT(I2,". (",I3,") ",8A2)
974   CONTINUE
975   CONTINUE
      GO TO 980 
C 
978   WRITE(LUI,979) NAMC 
979   FORMAT(3A2,": Break") 
C 
C     IF COMBINED RELOCATABLE, CLOSE RELOCATABLE FILE 
980   IF (KCNC.EQ.0) GO TO 984
      CALL CLOSE(IDCBP) 
C PURGE SCRATCH %FILE 
      CALL PURGE(IDCBP,IERR,NAMP(2),0,ICRO) 
      IF((KGO.LT.900.OR.KGO.EQ.970).AND.KGO.NE.810) 
     1  WRITE(LUII,9980) NAMC,NAMM,LUDX 
9980  FORMAT(3A2,": ",3A2,"::",3A2," finished") 
C IF LISTING FILE EXISTS, CLOSE IT
984   IF(LUO.EQ.1H') 985,989
985   CALL CLOSE(IDCBL) 
C PURGE SCRATCH LIST FILE 
      CALL PURGE(IDCBL,IERR,NAML(2),0,ICRO) 
C 
C     ABORT ENTRY 
C     CLOSE AND PURGE SCRATCH FILE "CPCPxx", "LITLxx" 
989   IF(KGO.EQ.978.OR.KGO.EQ.989) 988,990
988   CALL CLOSE(IDCBO) 
      CALL PURGE(IDCBO,IERR,NAMO(2),1,ICRO) 
      CALL PURGE(IDCBO,IERR,NAMD(2),1,ICRO) 
      IBB=100000B 
C 
C     CLOSE SOURCE FILE AND END 
990   CALL CLOSE(IDCBI) 
C OF FTN4X IF LAST CONTROL CARD 
C-----IF(ICNTRL.NE.1) GO TO 991 
C-----CALL IOF(6HFTN4X ,IERR,-1)
C-----CALL IOF(6HF4X.0 ,IERR,-1)
C-----CALL IOF(6HF4X.1 ,IERR,-1)
C-----CALL IOF(6HF4X.2 ,IERR,-1)
C-----CALL IOF(6HF4X.3 ,IERR,-1)
C-----CALL IOF(6HF4X.4 ,IERR,-1)
C-----CALL IOF(6HF4X.5 ,IERR,-1)
C-----CALL IOF(6HF4X.6 ,IERR,-1)
991   WRITE(LUI,992) NAMC 
992   FORMAT(3A2,": End") 
C RETURN GLOBALS
      IF (IBB .NE. 0) GO TO 993 
C     RETURN TOTAL# ERROS AND #ROUTINES WITH ERRORS 
      IBB=INFF
      IBB(2)=INF
993   RETURN
      END 
      SUBROUTINE READI(IDCBX,IERR,IBUFX,LBUF,LEN,LPR) 
C 
C     ROUTINE TO SUBSTITUTE FOR READF IN COMPC, WHICH ALLOWS $INCLUDE 
C     STATEMENTS TO CAUSE TRANSPARENT NESTING OF FILES TO AN ARBITRARY DEPTH
C 
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
C 
      INTEGER IBUFX(1),IDCBX(1),NINCX(3),LPR(1),LPOV(21)
C 
      INTEGER LDI(5),LIN(5) 
      DATA LDI    /   8,2H$I,2HNC,2HLU,2HDE/
      DATA LIN    /   7,2HIN,2HCL,2HUD,2HE /
      DATA LPOV   /  40,2H**,2H*L,2HIN,2HE ,2HOV,2HER,2HFL,2HOW,2H A, 
     /             2HFT,2HER,2H $,2HPA,2HRM,2H R,2HEP,2HLA,2HCE,2HME, 
     /             2HNT/
C 
C SAVE FLAG FOR IGNORING $INCLUDE UNTIL ROUTINE FOUND 
300   LENX=LEN
301   CALL READF(IDCBX,IERR,IBUFX(2),LBUF,LEN)
      IF(IERR.LT.0) GO TO 380 
C BLANK REST OF BUFFER
      IBUFX=2*LEN 
      JBUFX=IBUFX 
      CALL FILLQ(IBUFX,IBUFX+1,72)
      IF(LEN.NE.-1) GO TO 303 
C SKIP OUT IF END OF FILE AND NO INCLUDES NESTED
      IF(KINCL.EQ.0) GO TO 399
C NESTED $INCLUDE TO BE UNDONE
302   CALL CLOSE(IDCBI) 
      CALL STRED(IERR,NINC,KINCL) 
      KINCL=KINCL-1 
      GO TO 300 
C CHECK FOR $INCLUDE AND INCLUDE UNLESS ROUTINE NOT YET FOUND 
C OR COMMENT OR UNUSED DEBUG
303   CONTINUE
C-----IF(LENX.EQ.-32767) GO TO 399
      IF (LEN.LT.5) GO TO 399 
      ISTRC=IGETQ(IBUFX,1)
      IF(ISTRC.EQ.ICOMNT.OR.(ISTRC.EQ.104B.AND.IDEBUG.EQ.0)) GO TO 399
      IF(IPOSQ(IBUFX,LDI,1).EQ.1) GO TO 311 
      IF(IPOSQ(IBUFX,LIN,1).EQ.7) GO TO 312 
      GO TO 395 
311   ISTRC=9 
      GO TO 313 
312   ISTRC=15
C UPDATE RECORD POINTER AND WRITE CURRENT IDCBX 
313   KINCL=KINCL+1 
      CALL STWRT(IERR,NINC,KINCL) 
      CALL NAMR(IBB,IBUFX(2),LEN*2,ISTRC) 
      NINC(1)=IBB(1)
      NINC(2)=IBB(2)
      NINC(3)=IBB(3)
      NINC(4)=IBB(6)
C     SUBSTITUTE ALTERNATE CARTRIDGE IF 'XX' SPECIFIED FOR CARTRIDGE
      IF (NINC(4) .EQ. 2HXX .AND. KINCR .NE. 0) NINC(4)=KINCR 
      IF (KINCR1 .NE. 0) NINC(4)=KINCR1 
      CALL CNVT(NINC(4),NINCX,0)
      IF(IERR.GE.0) GO TO 352 
      WRITE(LUII,9351) NAMC,(NINC(I),I=1,3),NINCX 
9351  FORMAT(3A2,": No disk space to handle $INCLUDE ",3A2,"::",3A2)
      KINCL=KINCL-1 
      GO TO 300 
C OPEN NEW INPUT FILE 
352   KNX=0 
      DO 353 I=1,IDCBIS 
353   IDCBX(I)=0
354   CALL OPEN(IDCBX,IERR,NINC,3,IBB(5),NINC(4),IDCBIS)
C READ FIRST RECORD OF NEW FILE IF NO OPEN ERROR
      IF(IERR.GE.0) GO TO 301 
      IF(KNX.EQ.0.OR.NINCX.NE.2HXX) 
     .  WRITE(LUII,9355) NAMC,IERR,(NINC(I),I=1,3),NINCX
9355  FORMAT(3A2,": Error",I4," opening $INCLUDE ",3A2,"::",3A2)
C     PROMPT IF INTERACTIVE AND STILL XX AND FIRST TIME 
      IF(NINCX.NE.2HXX.OR.KNX.EQ.1.OR.IMPAR(2).EQ.-1) GO TO 356 
      KNX=1 
      WRITE(LUI,9356) NAMC
9356  FORMAT(3A2,":Set 'XX' in $INCLUDE::XX to ? _")
      READ(LUI,*) NINC(4) 
      IF(NINC(4).NE.2HXX) KINCR=NINC(4) 
      CALL CNVT(NINC(4),NINCX,0)
      GO TO 354 
C RESTORE PREVIOUS IDCBX AND POINTER
356   CALL STRED(IERR,NINC,KINCL) 
      KINCL=KINCL-1 
      GO TO 300 
C READ ERROR MESSAGE
380   IF(KINCL.NE.0) WRITE(LUII,9380) NAMC,IERR,NINCX 
9380  FORMAT(3A2,": Error",I4," reading $INCLUDE ",3A2,"::",3A2,
     .  " - Run aborted") 
      IF(KINCL.EQ.0) WRITE(LUII,9381) NAMC,IERR,NAMI,ICRIX
9381  FORMAT(3A2,": Error",I4," reading source file ",3A2,"::",3A2, 
     .  " - Run aborted") 
      KGO=760 
      CALL IBYP2
C CHECK FOR PARAMETER REPLACEMENT UNLESS COMMENT OR $PARM 
395   IF(KPAR.EQ.0.OR.IGETQ(IBUFX,1).EQ.ICOMNT) GO TO 397 
      IF(IBUFX(2).EQ.2H$P.AND.IBUFX(3).EQ.2HAR.AND. 
     .   IBUFX(4).EQ.2HM ) GO TO 397
      IF(IBUFX.GT.72) IBUFX=72
      IB1=1 
      KKPAR=0 
      DO 396 I=1,KPAR 
      IB2=IB1+(LPR(IB1)+1)/2+1
      IDUM=IXQ(IBUFX,LPR(IB1),LPR(IB2),0) 
      IF(IDUM.NE.0) KKPAR=1 
396   IB1=IB2+(LPR(IB2)+1)/2+1
      CALL TRIMQ(IBUFX) 
      CALL FILLQ(IBUFX,IBUFX+1,IBUFX+2) 
C ERROR IF LINE EXCEEDS 72 CHARACTERS 
      IF(IBUFX.LE.72) GO TO 397 
      CALL ERRS(IBUFX,LPOV) 
397   CONTINUE
      IF(KKPAR.EQ.0) IBUFX=JBUFX
399   RETURN
      END 
      SUBROUTINE WRIT(IBX)
C# LAST COMPC'ED  870105:21:16  : 
C SUBROUTINE TO WRITE OUTPUT LINE AND POSSIBLE ERROR MESSAGE
C USES BYPASS ROUTINE TO RETURN FOR EXIT CLEANUP AFTER ERROR
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER IBX(1)
      IBN=(IBX+1)/2 
      CALL WRITF(IDCBO,IERR,IBX(2),IBN) 
      IF (IERR .GE. 0) GO TO 900
      WRITE(LUII,516) NAMC,IERR,(NAMS(I,IN),I=2,9),(IBX(I),I=2,IBN+1) 
516   FORMAT(3A2,": Error",I4," in writing routine ",8A2,": ",
     1  /1X,36A2) 
      WRITE(LUII,9517) NAMC 
9517  FORMAT(3A2,": Run aborted") 
      KGO=810 
      CALL IBYP2
900   RETURN
      END 
      SUBROUTINE ERRS(IBX,LM) 
C# LAST COMPC'ED  870105:21:16    : 
C SUBROUTINE FOR PREPROCESSOR ERROR MESSAGES - PRINTED OR TO OUTPUT FILE
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
      INTEGER IBX(1),LM(1)
      KSERR=KSERR+1 
      IF(ILIST.EQ.0) 10,20
10    LUOX=LUO
      IF (LUO .EQ. 1H' .OR. LUO .EQ. 1H") LUOX=LUI
      CALL WRITQ(LUOX,LM) 
      IF(IBX.NE.0) CALL WRITQ(LUOX,IBX) 
20    CALL WRIT(LM) 
900   RETURN
      END 
      BLOCK DATA CNTRL
C COMMON FOR COMPC
      COMMON /CNTRL/ NINC(4),IDCBI(272),IDCBO(272),IDCBIS,IDCBOS, 
     1 NAMI(3),ISECUP,ISECUI,ICRI,NAMT(3),NAMM(3),ICRO,NAMC(3),NAMDD(3),
     1 NAMS(9,60),NAMA(9),NAMSX,NAMO(4),NAMP(4),NAML(4),NAMD(4),
     2 IB(185),IBB(271),LFTN4(10,8),LCDQ(10),LF4XY(2),LF4X(2),LF4Y(2),
     2 LF4IJ(2),LF4I(2),LF4J(2),LPROG(3,8), 
     3 IMPAR(5),LUI,LUII,LUO,LUD,LUNAMT,NN,IN,KALL,IREG(2), 
     4 ICRIX(3),LUDX(3),LUNAMX(3),
     5 ICNTRL,ILIST,IDEBUG,KDATE, 
     6 ICOMNT,ICFLAG,ICDATE,ICP,L2C,  
     7 KGO,KSTRUC,KSERR,KCP,ILABEL,KEMA,LLEMA(40),LLFILE(14),KCNC,
     8 IDCBP(144),IDCBL(144),KPAR,JPAR,KINCL,KINCR, 
     9 KINCR1 
C BUFFER AND NAME ARRAY LIMITS
      DATA IDCBIS /272/, IDCBOS /272/, NAMSX /60/ 
C SCRATCH FILES AND CR (ICRO selects cartridge for scratch files according
C     to the following algorithm: 
C        If ICRO=-32767, set ISCRT=ICRI unconditionally.
C        If ICRO=0, set ISCRT to cartridge currently at top of current 'CL' 
C           list, but not lu2 or lu3. 
C        If ICRO is a valid cartref within the current 'CL' list, set ISCRT=ICRO
C           (including lu2 or lu3, if specified, but will not normally work 
C           under a Session Monitor system) 
C        Otherwise, set ICRO=ICRI unconditionally.
C     Note: The following names are replaced with names created by
C           routine UNAME (ARW 870105)
      DATA NAMO /6,2H&C,2H1*,2HXX/, NAMP /6,2H%C,2H2*,2HXX/,
     .     NAML /6,2H'C,2H3*,2HXX/, NAMDD/  2H%C,2H4*,2HXX/,
     .     NAMD /6,2H&C,2H5*,2HXX/
      DATA ICRO /0/ 
C OTHER INITIALIZATION
      DATA NN /0/, KALL /1HN/, KGO /0/, KCP /0/, ICNTRL /0/, ICFLAG /0/ 
      DATA NAMM /3*2H  /, LUD /0/ 
      DATA LF4X /2,2H,X/, LF4Y /2,2H,Y/,LF4I/2,2H,I/,LF4J/2,2H,J/ 
      DATA JPAR /1/, KINCL /0/, NINC /4*0/
      DATA LFTN4/5,6HFTN4X ,6*0,
     .           4,6HASMB  ,6*0,
     .           4,6HFTN4  ,6*0,
     .           4,6HFTN5  ,6*0,
     .           4,6HRAT4  ,6*0,
     .           5,6HFTN66 ,6*0,
     .           5,6HFTN77 ,6*0,
     .           5,6HMACRO ,6*0/
      DATA LPROG/6HFTN4X ,6HASMB  ,6HFTN4  ,6HFTN4  ,6HRAT4  ,
     .           6HFTN7X ,6HFTN7X ,6HMACRO /
      END 
      FUNCTION LTRL(IB,IBB,IDCBI,IDCBN,NAMC,NAMD,ICRO,LPR)
C SUBROUTINE TO PRODUCE DATA STATMENTS FROM LITERALS
C# LAST COMPC'ED  870105:21:16
C LTRL = 1 - NOT A LITERAL STRING 
C      = 2 - LITERAL STRING, READ NEXT LINE ON RETURN 
      INTEGER IB(1),IBB(1),IDCBI(1),IDCBN(1),NAMC(3),NAMD(4),LPR(1) 
      INTEGER LNAM(5),LD(2) 
      INTEGER LDATA(3),LSLSH(2),L2H(2),LCOMA(2),ICHQ(32)
      INTEGER LL(4,4),LLP(2),LRP(2),LDIM(6),LCC(5)
      INTEGER LM1(22),LM2(23),LM3(16),LM4(23) 
      DATA NCMAX /7/
      DATA LDATA /4,2HDA,2HTA/, LSLSH /1,2H/ /, L2H /2,2H2H/
      DATA LCOMA /1,2H, / 
      DATA ICHQ /62,2HAB,2HCD,2HEF,2HGH,2HIJ,2HKL,2HMN,2HOP,2HQR,2HST,
     .              2HUV,2HWX,2HYZ,2H01,2H23,2H45,2H67,2H89,
     .              2Hab,2Hcd,2Hef,2Hgh,2Hif,2Hkl,2Hmn,2Hop,2Hqr,2Hst,
     .              2Huv,2Hwx,2Hyz/ 
      DATA LDIM   /   9,2HIN,2HTE,2HGE,2HR ,2H  / 
      DATA LCC    /   7,2H::,2HXX,2HXX,2HX /
      DATA LLP    /   1,2H( / 
      DATA LRP    /   1,2H) / 
      DATA LL     /   5,2HLD,2HAT,2HA ,   5,2HQD,2HAT,2HA ,   6,2HDL, 
     /             2HDA,2HTA,   6,2HDQ,2HDA,2HTA/ 
C ***LITERAL STRING HAS NO SECOND DELIMITER 
      DATA LM1    /  41,2H**,2H*L,2HIT,2HER,2HAL,2H S,2HTR,2HIN,2HG , 
     /             2HHA,2HS ,2HNO,2H S,2HEC,2HON,2HD ,2HDE,2HLI,2HMI, 
     /             2HTE,2HR / 
C ***LITERAL STRING HAS TOO MANY CONTINUATIONS
      DATA LM2    /  44,2H**,2H*L,2HIT,2HER,2HAL,2H S,2HTR,2HIN,2HG , 
     /             2HHA,2HS ,2HTO,2HO ,2HMA,2HNY,2H C,2HON,2HTI,2HNU, 
     /             2HAT,2HIO,2HNS/
C ***LITERAL STRING SYNTAX ERROR
      DATA LM3    /  30,2H**,2H*L,2HIT,2HER,2HAL,2H S,2HTR,2HIN,2HG , 
     /             2HSY,2HNT,2HAX,2H E,2HRR,2HOR/ 
C ***ERROR XXX CREATING LITERAL SCRATCH FILE
      DATA LM4    /  43,2H**,2H*E,2HRR,2HOR,2H X,2HXX,2H C,2HRE,2HAT, 
     /             2HIN,2HG ,2HLI,2HTE,2HRA,2HL ,2HSC,2HRA,2HTC,2HH , 
     /             2HFI,2HLE,2H  /
      DATA KLIT /0/ 
      LTRL=1
C CHECK FOR LITERAL KEYWORDS (LDATA, QDATA, DLDATA, DQDATA) 
      IF(KLIT.EQ.0.AND.ICPR(IBB,LL,4,4,0,ICC,0).EQ.0) GO TO 900 
C IF FIRST LITERAL (KLIT = 0), OPEN SCRATCH FILE
      IF(KLIT.EQ.0.AND.ICC.NE.0) 10,19
10    CALL OPEN(IDCBN,IERR,NAMD(2),0,0,ICRO)
      IF(IERR.GT.0) GO TO 19
      IF(IERR.NE.-6) GO TO 18 
      CALL CREAT(IDCBN,IERR,NAMD(2),15,3,0,ICRO)
C     WRITE(1,6038) (NAMD(IZ),IZ=2,4),ICRO,IERR 
C6038 FORMAT("8-NAMD,ICRO,IERR=",3A2,1X,O7,I6)
      IF(IERR.GE.0) GO TO 19
C SCRATCH FILE ERROR MESSAGE
18    ISTRC=3 
      IDUM=KSTRQ(ICRO,LCC,5,ISTRC)
      ISTRC=10
      IDUM=KSTRQ(IERR,LM4,3,ISTRC)
      CALL MERGQ(IDCBN,LM4,NAMD,LCC)
      CALL ERRS(0,IDCBN)
      GO TO 900 
19    CONTINUE
C IF NON-LITERAL AFTER LITERALS, WRITE DATA CARDS TO FINAL OUTPUT FILE AND
C RESET FLAG
      IF(KLIT.EQ.1.AND.ICC.EQ.0) 20,29
20    CALL RWNDF(IDCBN) 
      DO 21 I=1,32767 
      CALL READF(IDCBN,IERR,IBB(43),36,LEN) 
      IF(LEN.EQ.-1) GO TO 22
      IBB(42)=2*LEN 
      CALL WRIT(IBB(42))
21    CONTINUE
22    CALL CLOSE(IDCBN) 
      KLIT=0
      GO TO 900 
29    CONTINUE
C OTHERWISE, NORMAL LITERAL PROCESSING
      NCONT=0 
      KLIT=1
C MOVE LINE TO LARGE BUFFER 
      CALL FILLQ(IBB,1,534) 
      CALL MERGQ(IBB,IB)
      IBB=72
C EXTRACT NAME OF STRING AND DELIMITER CHARACTER
C     Find position of '--DATA' in line and space past it 
      ISTRC=7 
      IDUM=NFNBQ(IBB,LNAM,LL(1,ICC),ISTRC)
C     Get next 7 non-space characters in line beyond 'DATA'.
      IF (NFNBQ(IBB,LNAM,7,ISTRC) .EQ. 0) GO TO 890 
      IF (LNAM .LT. 2) GO TO 890
C     FIND DELIMITER IN LNAM (MUST BE SPECIAL CHARACTER)
      DO 30 I=2,LNAM
      CALL CHARQ(IGETQ(LNAM,I),LD)
      IF (IPOSQ(ICHQ,LD,1) .EQ. 0) GO TO 35 
30    CONTINUE
      GO TO 880 
35    LNAM=I-1
      ND1=IPOSQ(IBB,LD,1) 
C SEARCH FOR NEXT DELIMITER 
40    ND2=IPOSQ(IBB,LD,ND1+1) 
      IF(ND2.EQ.0) GO TO 870
C COUNT HOW MANY UNITS OF 2 CHARACTERS
      NC=ND2-ND1-1
      IF(NC.EQ.0) GO TO 860 
C LINE HAS PASSED ALL TESTS 
      LTRL=2
      NU=(NC+1)/2 
C CREATE DIMENSION CARD WITH NAME AND PROPER SIZE UNLESS DLDATA OR DQDATA 
      IF(ICC.GE.3) GO TO 139
      IB=28 
      CALL FILLQ(IB,1,72) 
      CALL MOVEQ(LDIM,1,IB,7,9) 
      CALL MOVEQ(LNAM,1,IB,17,LNAM) 
      CALL MOVEQ(LLP,1,IB,23,1) 
      NDU=NU
      IF(ICC.EQ.2.OR.ICC.EQ.4) NDU=NDU+1
      ISTRC=24
      IF(KSTRQ(NDU,IB,3,ISTRC).NE.0) GO TO 850
      CALL MOVEQ(LRP,1,IB,28,1) 
      CALL WRIT(IB) 
139   CONTINUE
C CREATE DATA CARD WITH NAME AND SLASH
      CALL FILLQ(IB,1,72) 
      CALL MOVEQ(LDATA,1,IB,7,4)
      CALL MOVEQ(LNAM,1,IB,12,LNAM) 
      CALL MOVEQ(LSLSH,1,IB,19,1) 
      NQ=0
C IF DATQ, INSERT NUMBER
      IF(ICC.EQ.2.OR.ICC.EQ.4) 150,200
150   ISTRC=20
      IF(KSTRQ(NC,IB,4,ISTRC).NE.0) GO TO 850 
      NQ=1
      CALL MOVEQ(LCOMA,1,IB,24,1) 
C LOOP OVER 2 CHARACTER UNITS 
200   CONTINUE
      DO 240 IU=1,NU
C IF ON NEW LINE, OUTPUT OLD, CLEAR BUFFER, WRITE CONTINUE MARK 
      IF(MOD(IU+NQ,10).EQ.1.AND.IU.NE.1) 210,220
210   CALL WRITF(IDCBN,IERR,IB(2),36) 
      CALL FILLQ(IB,1,72) 
      CALL MOVEQ(LSLSH,1,IB,6,1)
C MOVE 2H, 2 CHARACTER UNIT, COMMA
220   NP=5*MOD(IU-1+NQ,10)+20 
      CALL MOVEQ(L2H,1,IB,NP,2) 
      CALL MOVEQ(IBB,ND1+1+2*(IU-1),IB,NP+2,2)
      CALL MOVEQ(LCOMA,1,IB,NP+4,1) 
240   CONTINUE
C WRITE ENDING SLASH
      CALL MOVEQ(LSLSH,1,IB,NP+4,1) 
C IF ODD NUMBER OF CHARACTERS, BLANK LAST ONE 
      IF(MOD(NC,2).EQ.1) CALL FILLQ(IB,NP+3,NP+3) 
      CALL WRITF(IDCBN,IERR,IB(2),36) 
      GO TO 900 
850   CONTINUE
860   CONTINUE
      GO TO 890 
870   CONTINUE
C CHECK FOR CONTINUATION CARDS - UP TO NCMAX
      CALL READI(IDCBI,IERR,IB,36,LEN,LPR)
      IF (LEN .EQ. -1) GO TO 890
      IC6=IGETQ(IB,6) 
      IF (IC6.EQ.40B .OR. IC6.EQ.60B) GO TO 878 
      IC1=IGETQ(IB,1) 
      IF (IC1.EQ.103B .OR. IC1.EQ.44B .OR. IC1.EQ.52B) GO TO 878
      NCONT=NCONT+1 
      IF(NCONT.GT.NCMAX) GO TO 879
C DELETE FIRST 6 COLUMNS
      CALL DLETQ(IB,1,6)
C CHECK FOR DELIMITER 
      IF(IPOSQ(IB,LD,1).EQ.0) 871,872 
C NO DELIMITER - APPEND ENTIRE LINE TO BUFFER 
871   CALL FILLQ(IB,IB+1,66)
      IB=66 
      CALL MERGQ(IBB,IBB,IB)
      GO TO 870 
C DELIMITER FOUND - APPEND LINE AND PROCESS 
872   CALL MERGQ(IBB,IBB,IB)
      GO TO 40
878   CONTINUE
      CALL ERRS(IBB,LM1)
      CALL POSNT(IDCBI,IERR,-1,0) 
      GO TO 900 
879   CONTINUE
      CALL ERRS(IBB,LM2)
      GO TO 900 
880   CONTINUE
890   CONTINUE
C GENERAL SYNTAX ERROR
      CALL ERRS(IBB,LM3)
900   RETURN
      END 
      FUNCTION ISTRU(IB,IBB,IBBB,IDCBI,ILIST,IDEBUG,
     1  ILABEL,IST1,IST2,IST3,IST4,LPR) 
C# LAST COMPC'ED  870105:21:16      : 
C SUBROUTINE TO HANDLE STRUCTURED INSTRUCTIONS
C IB = INPUT LINE BUFFER
C IBB = FIRST WORD OF INPUT LINE
C IDCBI = INPUT FILE DCB
C ISTRU = CONTROL FLAG
C       = 1 - PROCESS LINE READ IN STRUC FROM BEGINNING 
C       = 2 - NOT STRUCTURED INSTRUCTION - PROCESS LINE NORMALLY
C       = 3 - STRUCTURED INSTRUCTIONS PROCESSED - READ NEXT LINE
C ILIST = LISTING CONTROL FLAG
C IST1-4 = STACKS FOR BLOCKS
      INTEGER IB(1),IBB(1),IBBB(1),IDCBI(1),LPR(1)
      INTEGER IST1(1),IST2(1),IST3(1),IST4(1) 
      INTEGER LST(4,12),LTHEN(3),LELSE(3),LBEGIN(4),LDOL(2) 
      INTEGER LWHILE(4),LIFB(2),LDO(2),LDO6(5),LCOM(2),LRP(2),LBL(2)
      INTEGER LIF(3),LENDT(3),LENDE(3),LENDW(3),LCASE(3)
      INTEGER LLP(2),LEQ(2),LEQD(3),LORD(3) 
      INTEGER LENDC(3),LFOR(3),LENDF(3),LDONE(3)
      INTEGER LRET(7),LM1(20),LM2(19),LM3(14),LM4(20) 
      INTEGER LM5(18),LM6(21),LM7(20),LM8(18),LM9(21),LM0(15) 
      INTEGER KNNN(4),LOTH(6),LBLK(5) 
C     INTEGER LELT(3),LEGT(3),LLT0(3),LGT0(3) 
      EQUIVALENCE (LIF,LST(1,1)),(LENDT,LST(1,2)),(LENDE,LST(1,3)), 
     1  (LWHILE,LST(1,4)),(LENDW,LST(1,5)),(LCASE,LST(1,6)),
     2  (LLP,LST(1,7)),(LENDC,LST(1,8)),(LFOR,LST(1,9)),
     3  (LENDF,LST(1,10)),(LDONE,LST(1,11)),(LELSE,LST(1,12)) 
      DATA MBLK /4/ 
      DATA LIF    /   3,2HIF,2H$ /
      DATA LTHEN  /   4,2HTH,2HEN/
      DATA LENDT  /   4,2HEN,2HDT/
      DATA LELSE  /   4,2HEL,2HSE/
      DATA LENDE  /   4,2HEN,2HDE/
      DATA LWHILE /   5,2HWH,2HIL,2HE / 
      DATA LENDW  /   4,2HEN,2HDW/
      DATA LCASE  /   4,2HCA,2HSE/
      DATA LLP    /   1,2H( / 
      DATA LEQ    /   1,2H= / 
      DATA LEQD   /   4,2H.E,2HQ./
      DATA LORD   /   4,2H.O,2HR./
      DATA LENDC  /   4,2HEN,2HDC/
      DATA LFOR   /   4,2HFO,2HR$/
      DATA LENDF  /   4,2HEN,2HDF/
      DATA LDONE  /   4,2HDO,2HNE/
      DATA LBEGIN /   5,2HBE,2HGI,2HN / 
      DATA LIFB   /   2,2HIF/ 
      DATA LDO    /   2,2HDO/ 
      DATA LDO6   /   8,2HDO,3*2H  /
      DATA LDOL   /   1,2H$ / 
      DATA LCOM   /   1,2H, / 
      DATA LBL    /   1,2H  / 
      DATA LRP    /   1,2H) / 
      DATA KNNN   /   5,2HKN,2HNN,2H= / 
      DATA LOTH   /   9,2HOT,2HHE,2HRW,2HIS,2HE / 
      DATA LRET   /  12,2HGO,2H T,2HO ,2H32,2H76,2H7 /
C     DATA LELT   /   4,2HEQ,2H.</
C     DATA LEGT   /   4,2HEQ,2H.>/
C     DATA LLT0   /   4,2HLT,2H.0/
C     DATA LGT0   /   4,2HGT,2H.0/
C ***IF$-THEN LACKS THEN PRIOR TO LINE: 
      DATA LM1    /  37,2H**,2H*I,2HF$,2H-T,2HHE,2HN ,2HLA,2HCK,2HS , 
     /             2HTH,2HEN,2H P,2HRI,2HOR,2H T,2HO ,2HLI,2HNE,2H: / 
C ***WHILE-DO LACKS DO PRIOR TO LINE: 
      DATA LM2    /  35,2H**,2H*W,2HHI,2HLE,2H-D,2HO ,2HLA,2HCK,2HS , 
     /             2HDO,2H P,2HRI,2HOR,2H T,2HO ,2HLI,2HNE,2H: /
C ***ELSE WITHOUT PRIOR THEN
      DATA LM3    /  26,2H**,2H*E,2HLS,2HE ,2HWI,2HTH,2HOU,2HT ,2HPR, 
     /             2HIO,2HR ,2HTH,2HEN/ 
C ***ENDT UNBALANCED BY THEN/IF$
      DATA LM4    /  37,2H**,2H*E,2HND,2HT ,2HUN,2HBA,2HLA,2HNC,2HED, 
     /             2H B,2HY ,2HTH,2HEN,2H/I,2HF$,2H B,2HEF,2HOR,2HE / 
C ***FOR$-DO LACKS DO PRIOR TO LINE:
      DATA LM5    /  34,2H**,2H*F,2HOR,2H$-,2HDO,2H L,2HAC,2HKS,2H D, 
     /             2HO ,2HPR,2HIO,2HR ,2HTO,2H L,2HIN,2HE:/ 
C ***CASE LACKS STATE LIST PRIOR TO LINE: 
      DATA LM6    /  39,2H**,2H*C,2HAS,2HE ,2HLA,2HCK,2HS ,2HST,2HAT, 
     /             2HE ,2HLI,2HST,2H P,2HRI,2HOR,2H T,2HO ,2HLI,2HNE, 
     /             2H: /
C ***CASE STATE LIST WITHOUT PRIOR CASE 
      DATA LM7    /  37,2H**,2H*C,2HAS,2HE ,2HST,2HAT,2HE ,2HLI,2HST, 
     /             2H W,2HIT,2HHO,2HUT,2H P,2HRI,2HOR,2H C,2HAS,2HE / 
C ***CASE NESTING TOO DEEP AT BLOCK:
      DATA LM8    /  34,2H**,2H*C,2HAS,2HE ,2HNE,2HST,2HIN,2HG ,2HTO, 
     /             2HO ,2HDE,2HEP,2H A,2HT ,2HBL,2HOC,2HK:/ 
C ***ENDC NOT BALANCED BY CASE STATE LIST 
      DATA LM9    /  39,2H**,2H*E,2HND,2HC ,2HNO,2HT ,2HBA,2HLA,2HNC, 
     /             2HED,2H B,2HY ,2HCA,2HSE,2H S,2HTA,2HTE,2H L,2HIS, 
     /             2HT /
C ***CASE STATE LIST TOO LONG 
      DATA LM0    /  27,2H**,2H*C,2HAS,2HE ,2HST,2HAT,2HE ,2HLI,2HST, 
     /             2H T,2HOO,2H L,2HON,2HG /
C CHECK FOR STRUCTURED KEY WORDS (IF$, ENDT, ENDE, WHILE, ENDW, CASE, (,
C ENDC, FOR$, ENDF, DONE, ELSE) 
      ISTRU=2 
      IF(ICPR(IBB,LST,4,12,0,IC,0).EQ.0) 9010,110 
110   GO TO (200,300,400,500,600,700,800,900,1000,1100,1200,1300),IC
C SECTION FOR IF$ 
200   CONTINUE
C GET POSITION OF IF$ FOR INDENTATION 
      IIF=IPOSQ(IB,LIF,7) 
      IET=IIF+4 
      IEE=IET 
C DELETE $, READ AND WRITE CONDITION CARD(S)
      IDUM=IXQ(IB,LDOL,0,1) 
      CALL FILLQ(IB,IB+1,IB+3)
      CALL WRIT(IB) 
C HANDLE POSSIBLE CONTINUATION AND COMMENT CARDS
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C CHECK FOR THEN
      ISTRU=1 
      GO TO (215,220),ICHK(IB,IBB,LTHEN,4)
C NO THEN CARD - PROCESS LINE FROM START AND ERROR MESSAGE
215   CALL ERRS(IB,LM1) 
      GO TO 9010
220   CONTINUE
C THEN CARD - GET 3 LABELS, WRITE IF END AND LABEL 1, STORE LABELS 2,3
      N1=ILABEL 
      N2=N1+1 
      N3=N2+1 
      ILABEL=ILABEL+3 
      CALL CCON(IBBB,IIF,N1,N2) 
      CALL PPUT(IST1,N2,IERR) 
      CALL PPUT(IST1,N3,IERR) 
C CHECK THEN CARD FOR BEGIN 
C SKIP TO ENDT IF NO BEGIN, OTHERWISE RETURN TO PROCESS LABELED CARD
      GO TO (312,9010), 
     1  KBEG(LTHEN,IST1,IB,IDCBI,MBLK,ILIST,IDEBUG,N1,KDONE,LPR)
C SECTION FOR ENDT(HEN) 
300   CONTINUE
C GET POSITION OF ENDT FOR INDENTATION
      IET=IPOSQ(IB,LENDT,7) 
C CHECK BLOCK NAME
      CALL CBLK(LENDT,IST1,MBLK,IB,IBB,ILIST) 
C CHECK FOR ELSE
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
312   ISTRU=1 
      KELSE=0 
      IF(ICHK(IB,IBB,LELSE,4).EQ.2) KELSE=1 
C RETRIEVE LABEL 3
      CALL PGET(IST1,N3,IERR) 
C IF ELSE, WRITE GO TO LABEL 3 UNLESS DONE BEFORE 
      IF(KELSE.EQ.1.AND.KDONE.EQ.0) 315,316 
315   IEL=IPOSQ(IB,LELSE,7) 
      IEE=IEL+2 
      CALL CGOT(IBBB,IEL,N3)
316   CONTINUE
C RETRIEVE LABEL 2 AND WRITE CONTINUE FOR END OF BLOCK UNLESS ELSE
      CALL PGET(IST1,N2,IERR) 
      IF(IERR.EQ.0) GO TO 317 
      CALL ERRS(IB,LM4) 
317   CONTINUE
      IF(KELSE.EQ.0) CALL CEND(IBBB,IET,N2) 
C IF NO ELSE, PROCESS CURRENT LINE
      IF(KELSE.EQ.0) GO TO 9010 
C RE-STORE LABEL 3 FOR END ELSE 
330   CALL PPUT(IST1,N3,IERR) 
C CHECK ELSE CARD FOR BEGIN 
C SKIP TO ENDE IF NO BEGIN, OTHERWISE RETURN TO PROCESS NEXT CARD 
      GO TO (412,9010), 
     1  KBEG(LELSE,IST1,IB,IDCBI,MBLK,ILIST,IDEBUG,N2,KDONE,LPR)
C SECTION FOR ENDE(LSE) 
400   CONTINUE
C GET POSITION OF ENDE FOR INDENTATION
      IEE=IPOSQ(IB,LENDE,7) 
C RETRIEVE AND CHECK BLOCK NAME 
      CALL CBLK(LENDE,IST1,MBLK,IB,IBB,ILIST) 
C RETRIEVE LABEL 3 AND WRITE CONTINUE FOR END OF BLOCK
412   CALL PGET(IST1,N3,IERR) 
      CALL CEND(IBBB,IEE,N3)
C IF NOT COMING FROM NO ELSE CONDITION, PROCESS LINE FROM START 
      IF(ISTRU.NE.2) 9010,9000
C SECTION FOR WHILE 
500   CONTINUE
C GET POSITION OF WHILE FOR INDENTATION 
      IWH=IPOSQ(IB,LWHILE,7)
      IEW=IWH+4 
C CHECK FOR LABEL 
      IBBB=6
      CALL MOVEQ(IB,1,IBBB,1,6) 
      ISTRC=1 
      N1=KVALQ(IBBB,IERR,ISTRC) 
C GET 3 LABELS
      IF(IERR.EQ.1) N1=ILABEL 
      N2=ILABEL+1 
      N3=ILABEL+2 
      ILABEL=ILABEL+3 
C REPLACE WHILE BY IF 
      IDUM=IXQ(IB,LWHILE,LIFB,1)
      CALL FILLQ(IB,IB+1,IB+4)
C INSERT FIRST LABEL ON IF LINE FOR LOOPING BACK
      ISTRC=1 
      CALL KSTRQ(N1,IB,0,ISTRC) 
      CALL WRIT(IB) 
C HANDLE POSSIBLE CONTINUATIONS 
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C CHECK FOR DO
      ISTRU=1 
      GO TO (515,520),ICHK(IB,IBB,LDO,2)
C NO DO CARD - PROCESS LINE FROM START AND ERROR MESSAGE
515   CALL ERRS(IB,LM2) 
      GO TO 9010
520   CONTINUE
C DO CARD - WRITE IF END AND CONTINUE CARDS 
      CALL CCON(IBBB,IWH,N2,N3) 
C SAVE LABELS 3 AND 1 
      CALL PPUT(IST2,N3,IERR) 
      CALL PPUT(IST2,N1,IERR) 
C PROCESS DO CARD FOR BEGIN - JUMP TO ENDW IF NO BEGIN, OTHERWISE RETURN TO 
C READ CARDS IN BLOCK 
      GO TO (612,9010), 
     1  KBEG(LDO,IST2,IB,IDCBI,MBLK,ILIST,IDEBUG,N2,KDONE,LPR)
C SECTION FOR ENDW(HILE)
600   CONTINUE
C GET POSITION OF ENDW FOR INDENTATION
      IEW=IPOSQ(IB,LENDW,7) 
C RETRIEVE AND CHECK BLOCK NAME 
      CALL CBLK(LENDW,IST2,MBLK,IB,IBB,ILIST) 
C RETRIEVE LABEL 1 AND WRITE GO TO LABEL 1
612   CALL PGET(IST2,N1,IERR) 
      CALL CGOT(IBBB,IEW,N1)
C RETRIEVE LABEL 3 AND WRITE LABEL 3 CONTINUE FOR END OF BLOCK
      CALL PGET(IST2,N3,IERR) 
      CALL CEND(IBBB,IEW,N3)
C IF COMING FORM DO LINE, PROCESS NEXT LINE FROM BEGINNING
C OTHERWISE READ NEXT LINE
      IF(ISTRU.NE.2) 9010,9000
C SECTION FOR CASE
700   CONTINUE
C GET END LABEL 
      NDC=ILABEL
      ILABEL=ILABEL+1 
C FORM INTEGER NAME 
      KN=NDC-32000
      ISTRC=2 
      CALL KSTRQ(KN,KNNN,-3,ISTRC)
C FORM ASSIGNMENT "KNNN=(EXPRESSION)" 
      IDUM=IXQ(IB,LCASE,KNNN,1) 
      CALL WRIT(IB) 
C SET NEXT LABEL ZERO 
      NXC=0 
C GET NEXT EXECUTABLE LINE
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C CHECK FOR ( - IF FOUND, PROCESS - OTHERWISE, ERROR
      GO TO (715,810),ICHK(IB,IBB,LLP,1)
715   CALL ERRS(IB,LM6) 
      ISTRU=1 
      GO TO 9010
C SECTION FOR ( 
800   CONTINUE
C ERROR IF ( FOUND ISOLATED 
      CALL ERRS(IB,LM7) 
      ISTRU=1 
      GO TO 9010
C NORMAL ( PROCESSING 
810   CONTINUE
C GET POSITION OF ( FOR INDENTATION 
      ILP=IPOSQ(IB,LLP,7) 
      IRP=IPOSQ(IB,LRP,7) 
      IEC=ILP+2 
      IBEG=IPOSQ(IB,LBEGIN,7) 
C CHECK FOR SIMPLE STATEMENT
      IF(IBEG.EQ.0) 820,829 
C SAVE EXECUTABLE PART OF STATEMENT 
820   CALL MERGQ(IBB,IB)
      CALL DLETQ(IBB,ILP,IRP-ILP+1) 
      CALL NSRTQ(IBB,0,LBL) 
      CALL FILLQ(IBB,IBB+1,IBB+2) 
      CALL FILLQ(IB,IRP+1,72) 
      IB=IRP
      GO TO 835 
C SAVE BLOCK NAME 
829   IB=IBEG+5+2*MBLK
      CALL SEGQ(IB,IBEG+6,IB,LBLK)
C WRITE BEGIN LINE AS COMMENT 
      IF(ILIST.EQ.0.OR.ILIST.EQ.2) GO TO 830
      CALL PUTQ(IB,1,103B)
      CALL WRIT(IB) 
830   CALL FILLQ(IB,1,1)
C DELETE BEGIN BLOCK
      CALL FILLQ(IB,IBEG,72)
      IB=IBEG-1 
C FORM "KNNN.EQ." 
835   CALL MERGQ(IBBB,KNNN,LEQD)
      IDUM=IXQ(IBBB,LEQ,0,1)
C INSERT AFTER INITIAL (
      CALL NSRTQ(IB,ILP,IBBB) 
C REPLACE <, > WITH .LT.0, .GT.0
C     IDUM=IXQ(IB,LELT,LLT0,0)
C     IDUM=IXQ(IB,LEGT,LGT0,0)
C REPLACE OTHERWISE WITH KNNN TO FORCE EXECUTION
      IDUM=IXQ(IB,LOTH,KNNN,1)
      IDUM=IXQ(IB,LEQ,0,1)
      CALL FILLQ(IB,IB+1,IB+3)
C FORM ".OR.KNNN.EQ." FOR SUBSEQUENT TESTS
      CALL MERGQ(IBBB,LORD,IBBB)
C REPLACE SEPARATORS
      IDUM=IXQ(IB,LCOM,IBBB,0)
C INSERT IF AT BEGINNING
      CALL NSRTQ(IB,ILP-1,LIFB) 
C MESSAGE IF LINE OVERFLOW
      IF(IB.GT.72) CALL ERRS(IB,LM0)
C INSERT LABEL TO COMPLETE LINE UNLESS ZERO 
      ISTRC=1 
      IF(NXC.NE.0) CALL KSTRQ(NXC,IB,0,ISTRC) 
      CALL WRIT(IB) 
C GET IMMEDIATE AND NEXT LABELS 
      NIC=ILABEL
      NXC=ILABEL+1
      ILABEL=ILABEL+2 
C WRITE IF CONTINUATION WITH IMMEDIATE, NEXT
      CALL CCON(IBBB,ILP,NIC,NXC) 
C IF SIMPLE STATEMENT, LABEL, WRITE, AND SKIP TO ENDC 
      IF(IBEG.EQ.0) 840,849 
840   ISTRC=1 
      CALL KSTRQ(NIC,IBB,0,ISTRC) 
C CHECK FOR DONE
      IF(IPOSQ(IBB,LDONE,7).NE.0) 841,842 
841   IDUM=IXQ(IBB,LDONE,LRET,1)
      KDONE=1 
842   CALL WRIT(IBB)
C HANDLE POSSIBLE CONTINUATIONS 
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C WRITE GO TO END LABEL IF NOT DONE 
      IF(KDONE.EQ.0) CALL CGOT(IBBB,IEC,NDC)
C CHECK NEW EXECUTABLE STATEMENT
      GO TO 925 
849   CONTINUE
C SAVE NEXT, KNNN, END, BLOCKNAME 
      CALL PPUT(IST3,NXC,IERR)
      CALL PPUT(IST3,KNNN(2),IERR)
      CALL PPUT(IST3,KNNN(3),IERR)
      CALL PPUT(IST3,NDC,IERR)
      DO 850 I=1,MBLK 
850   CALL PPUT(IST3,LBLK(I+1),IERR)
      IF(IERR.NE.0) CALL ERRS(LBLK,LM8) 
C GET FIRST EXECUTABLE LINE OF BLOCK
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C INSERT IMMEDIATE LABEL AND PROCESS LINE 
      ISTRC=1 
      CALL KSTRQ(NIC,IB,0,ISTRC)
      ISTRU=1 
      GO TO 9010
C SECTION FOR ENDC
900   CONTINUE
C GET POSITION OF ENDC FOR INDENTATION
      IEC=IPOSQ(IB,LENDC,7) 
C CHECK BLOCKNAME 
      CALL CBLK(LENDC,IST3,MBLK,IB,IBB,ILIST) 
C GET END LABEL, KNNN, NEXT LABEL 
      CALL PGET(IST3,NDC,IERR)
      CALL PGET(IST3,KNNN(3),IERR)
      CALL PGET(IST3,KNNN(2),IERR)
      CALL PGET(IST3,NXC,IERR)
      IF(IERR.NE.0) CALL ERRS(IB,LM9) 
C WRITE GO TO END LABEL UNLESS DONE 
920   IF(KDONE.EQ.0) CALL CGOT(IBBB,IEC,NDC)
C GET NEXT EXECUTABLE LINE
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C CHECK FOR ( - IF FOUND, PROCESS - OTHERWISE, CLOSE LAST BLOCK 
925   GO TO (930,810),ICHK(IB,IBB,LLP,1)
930   CONTINUE
C WRITE NEXT CONTINUE FOR LAST BLOCK
      CALL CEND(IBBB,IEC,NXC) 
C WRITE END CONTINUE FOR WHOLE CASE 
      CALL CEND(IBBB,MAX0(7,IEC-4),NDC) 
      ISTRU=1 
      GO TO 9010
C SECTION FOR FOR$
1000  CONTINUE
C GET POSITION OF FOR FOR INDENTATION 
      IFO=IPOSQ(IB,LFOR,7)
      IEF=IFO+4 
C GET ONE LABEL FOR END OF FORTRAN DO LOOP
      N1=ILABEL 
      ILABEL=ILABEL+1 
C REPLACE FOR BY DO 
      IDUM=IXQ(IB,LFOR,LDO6,1)
C INSERT LABEL FOLLOWING DO 
      ISTRC=IFO+2 
      CALL KSTRQ(N1,IB,6,ISTRC) 
      CALL FILLQ(IB,IB+1,IB+3)
      CALL WRIT(IB) 
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C CHECK FOR DO
      ISTRU=1 
      GO TO (1015,1020),ICHK(IB,IBB,LDO,2)
1015  CALL ERRS(IB,LM5) 
      GO TO 9010
1020  CONTINUE
C SAVE LABEL
      CALL PPUT(IST4,N1,IERR) 
C PROCESS DO FOR BEGIN BLOCK OR SIMPLE STATEMENT AND PROCEED
      GO TO (1112,9010),
     1  KBEG(LDO,IST4,IB,IDCBI,MBLK,ILIST,IDEBUG,0,KDONE,LPR) 
C SECTION FOR ENDF
1100  CONTINUE
C GET POSITION OF ENDF FOR INDENTATION
      IEF=IPOSQ(IB,LENDF,7) 
C RETRIEVE AND CHECK BLOCK NAME 
      CALL CBLK(LENDF,IST4,MBLK,IB,IBB,ILIST) 
C RETRIEVE LABEL AND WRITE CONTINUE FOR END OF BLOCK
1112  CALL PGET(IST4,N1,IERR) 
      CALL CEND(IBBB,IEF,N1)
C IF COMING FROM DO LINE, PROCESS NEXT LINE FROM BEGINNING
      IF(ISTRU.NE.2) 9010,9000
C SECTION FOR DONE
1200  CONTINUE
      IDUM=IXQ(IB,LDONE,LRET,1) 
      CALL WRIT(IB) 
      KDONE=1 
      ISTRU=3 
      GO TO 9020
C SECTION FOR ELSE
1300  CONTINUE
      CALL ERRS(IB,LM3) 
      GO TO 9000
C END - SET FLAG TO READ NEXT LINE
9000  ISTRU=3 
9010  KDONE=0 
9020  CONTINUE
      RETURN
      END 
      SUBROUTINE PPUT(IST,IEN,IERR) 
C# LAST COMPC'ED  870105:21:16
C PUT INTO PUSHDOWN STACK 
C IST(1) = STACK INDEX
C     2  = MAXIMUM NUMBER OF ENTRIES
C     3  = POSITION OF LAST ENTRY - INITIALIZED TO 3
      INTEGER IST(1)
      IF(IST(2)+3.EQ.IST(3)) 100,109
100   IERR=-1 
      GO TO 900 
109   IX=IST(3)+1 
      IST(3)=IX 
      IST(IX)=IEN 
      IERR=0
900   RETURN
      END 
      SUBROUTINE PGET(IST,IEN,IERR) 
C# LAST COMPC'ED  870105:21:16
C GET FROM PUSHDOWN STACK 
      INTEGER IST(1)
      IF(IST(3).EQ.3) 100,109 
100   IERR=-1 
      GO TO 900 
109   IX=IST(3) 
      IEN=IST(IX) 
      IST(3)=IX-1 
      IERR=0
900   RETURN
      END 
      FUNCTION ICPR(IB,LP,NC,NE,NCM,IC,IDELIM)
C# LAST COMPC'ED  870105:21:16
C FUNCTION TO COMPARE STRING WITH AN ARRAY OF STRINGS 
C RETURNS POSITION OF MATCH OR 0
C ARRAY MUST STORE STRINGS COLUMNWISE 
C IB = STRING TO BE MATCHED 
C LP = ARRAY OF STRINGS 
C NC = NUMBER OF WORDS IN EACH COLUMN OF ARRAY
C NE = NUMBER OF ENTRIES IN ARRAY TO BE SEARCHED
C NCM = NUMBER OF CHARACTERS TO BE MATCHED
C     = 0 - USE COUNT IN ARRAY
C     = NCM>0 - MATCH FIRST NCM CHARACTERS
C     = NCM<0 - MATCH FIRST -NCM CHARACTERS OR TO FIRST DELIMITING CHARACTER
C               IN IB (WHICHEVER OCCURS FIRST)
C IDELIM = USE LOWER 8-BITS OF IDELIM AS DELIMITING CHARACTER 
C          (APPLICABLE ONLY WHEN NCM<0) 
      INTEGER IB(1),LP(NC,NE),IQ1(10),IQ2(10) 
      IB2=IB(2) 
      IC=0
      DO 100 I=1,NE 
      IF(IB2.NE.LP(2,I)) GO TO 100
      IF (NCM) 30,50,40 
30    ISTRC1=1
      IDUM=KPRSQ(IB,IQ1,-NCM,ISTRC1,0,IDELIM) 
      CALL TRIMQ(IQ1) 
      ISTRC2=1
      IDUM=KPRSQ(LP(1,I),IQ2,-NCM,ISTRC2,0,IDELIM)
      CALL TRIMQ(IQ2) 
      IF (KMPRQ(IQ1,IQ2) .EQ. 1) IC=I 
      GO TO 90
40    LQ=LP(1,I)
      LP(1,I)=NCM 
50    IF(IPOSQ(IB,LP(1,I),1).EQ.1) IC=I 
      IF(NCM.NE.0) LP(1,I)=LQ 
90    IF(IC.NE.0) GO TO 900 
100   CONTINUE
900   ICPR=IC 
      RETURN
      END 
      SUBROUTINE CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C# LAST COMPC'ED  870105:21:16   :
C SUBROUTINE TO READ CONTINUATION AND COMMENT CARDS 
      INTEGER IB(1),IDCBI(1),LPR(1) 
      DO 100 I=1,32767
      CALL READI(IDCBI,IERR,IB,40,LEN,LPR)
      GO TO (101,50,100),IWCL(IB,103B,1,ILIST,IDEBUG) 
50    CALL WRIT(IB) 
100   CONTINUE
101   CONTINUE
      RETURN
      END 
      FUNCTION KBEG(L1,IST,IB,IDCBI,MBLK,ILIST,IDEBUG,NL,KDONE,LPR) 
C# LAST COMPC'ED  870105:21:16     :
C SUBROUTINE TO CHECK FOR BEGIN BLOCK 
C KBEG = 1 - NO BLOCK 
C      = 2 - BLOCK FOUND FROM BEGIN 
      INTEGER L1(1),IB(1),IDCBI(1),LPR(1) 
      INTEGER LBEGIN(4),LDONE(3),LRET(7),LBL(2),LCONT(5)
      INTEGER LM1(20) 
      DATA LBL    /   1,2H  / 
      DATA LBEGIN /   5,2HBE,2HGI,2HN / 
      DATA LDONE  /   4,2HDO,2HNE/
      DATA LCONT  /   8,2HCO,2HNT,2HIN,2HUE/
      DATA LRET   /  11,2HGO,2H T,2HO ,2H32,2H76,2H7 /
      DATA LM1    /  37,2H**,2H*N,2HES,2HTI,2HNG,2H T,2HOO,2H D,2HEE, 
     /             2HP ,2HAT,2H B,2HLO,2HCK,2H L,2HAB,2HEL,2HED,2H: / 
      IF(IPOSQ(IB,LBEGIN,7).EQ.0) 225,230 
C NO BEGIN - DELETE KEY, WRITE LINE(S) AND SKIP TO END
225   CONTINUE
      IDUM=IXQ(IB,L1,0,1) 
      CALL NSRTQ(IB,0,LBL)
      CALL FILLQ(IB,IB+1,IB+2)
C INSERT LABEL UNLESS ZERO
      ISTRC=1 
      IF(NL.NE.0) CALL KSTRQ(NL,IB,0,ISTRC) 
C CHECK FOR DONE
      IF(IPOSQ(IB,LDONE,7).NE.0) 226,227
226   IDUM=IXQ(IB,LDONE,LRET,1) 
      KDONE=1 
227   CONTINUE
C INSERT CONTINUE IF LINE BLANK 
      IBS=IB
      CALL TRIMQ(IB)
      IF(IB.LT.7) 228,229 
228   CALL MOVEQ(LCONT,1,IB,IBS+2,8)
      CALL FILLQ(IB,7,IBS+1)
      IB=IBS+10 
229   CALL WRIT(IB) 
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
      KBEG=1
      GO TO 900 
C BEGIN BLOCK - PRINT LINE AS COMMENT 
230   CONTINUE
      IF(ILIST.EQ.0.OR.ILIST.EQ.2) 232,231
231   CALL PUTQ(IB,1,103B)
      CALL WRIT(IB) 
232   CONTINUE
C STORE MBLK WORDS OF BLOCK NAME
      CALL DLETQ(IB,1,IPOSQ(IB,LBEGIN,7)+5) 
      CALL FILLQ(IB,IB+1,IB+2*MBLK) 
      DO 233 I=1,MBLK 
233   CALL PPUT(IST,IB(I+1),IERR) 
C CHECK FOR NESTING TOO DEEP
      IF(IERR.NE.0) CALL ERRS(IB,LM1) 
C GET NEXT EXECUTABLE STATMENT FOR LABEL
      CALL CONT(IB,IDCBI,ILIST,IDEBUG,LPR)
C INSERT LABEL
      ISTRC=1 
      IF(NL.NE.0) CALL KSTRQ(NL,IB,0,ISTRC) 
      KBEG=2
900   RETURN
      END 
      SUBROUTINE CBLK(LL,IST,MBLK,IB,IBB,ILIST) 
C# LAST COMPC'ED  870105:21:16          : 
C SUBROUTINE TO CHECK BLOCK NAMES 
      INTEGER IST(1),IB(1),IBB(1),LL(1),IDCBO(1)
      INTEGER LM1(13),LEMP(5) 
      DATA LEMP   /   8,2H*E,2HMP,2HTY,2H**/
      DATA LM1    /  23,2H**,2H*B,2HLO,2HCK,2H N,2HAM,2HE ,2HMI,2HSM, 
     /             2HAT,2HCH,2H  /
      MBLK2=2*MBLK
C WRITE END BLOCK AS COMMENT UNLESS COMMENTS SUPPRESSED 
      IF(ILIST.EQ.0.OR.ILIST.EQ.2) GO TO 300
      CALL PUTQ(IB,1,103B)
      CALL WRIT(IB) 
300   CONTINUE
      DO 310 I=1,MBLK 
310   CALL PGET(IST,IBB(MBLK+2-I),IERR) 
      IBB=MBLK2 
      IF(IERR.NE.0) CALL MERGQ(IBB,LEMP)
      CALL DLETQ(IB,1,IPOSQ(IB,LL,7)+4) 
      CALL FILLQ(IB,IB+1,2*MBLK)
      IB=MBLK2
C IF BLOCK NAME DOES NOT MATCH, ERROR MESSAGE 
      IF(IPOSQ(IBB,IB,1).EQ.1) GO TO 900
      CALL MOVEQ(IBB,1,IBB,24,MBLK2)
      CALL PUTQ(IBB,24+MBLK2,40B) 
      CALL MOVEQ(IB,1,IBB,25+MBLK2,MBLK2) 
      CALL MOVEQ(LM1,1,IBB,1,23)
      IBB=24+2*MBLK2
      CALL ERRS(0,IBB)
900   RETURN
      END 
      SUBROUTINE CEND(IBBB,II,NN) 
C# LAST COMPC'ED  870105:21:16 :
C SUBROUTINE TO WRITE CONTINUE AT END OF BLOCK
      INTEGER IBBB(1) 
      INTEGER LCON(5) 
      DATA LCON   /   8,2HCO,2HNT,2HIN,2HUE/
      IBBB=II+7 
      CALL FILLQ(IBBB,1,IBBB+1) 
      ISTRC=1 
      CALL KSTRQ(NN,IBBB,0,ISTRC) 
      CALL MOVEQ(LCON,1,IBBB,II,8)
      CALL WRIT(IBBB) 
      RETURN
      END 
      FUNCTION ICHK(IB,IBB,LL,N)
C# LAST COMPC'ED  870105:21:16         :
C FUNCTION TO COMPARE FIRST WORD IN LINE
C ICHK = 1 - NO MATCH 
C      = 2 - MATCH
      INTEGER IB(1),IBB(1),LL(1)
      ICHK=1
      ISTRC=7 
      IDUM=KPRSQ(IB,IBB,N,ISTRC,0,2H  ) 
      IF(KMPRQ(IBB,LL).EQ.1) ICHK=2 
      RETURN
      END 
      SUBROUTINE CCON(IBBB,IIF,N1,N2) 
C# LAST COMPC'ED  870105:21:16         :
C SUBROUTINE TO WRITE CONTINUATION LINE AFTER IF
      INTEGER IBBB(1) 
      CALL FILLQ(IBBB,1,72) 
      CALL PUTQ(IBBB,6,56B) 
      IBBB=6
      CALL KSTRQ(N1,IBBB,0,IIF) 
      CALL PUTQ(IBBB,IIF,54B) 
      IIF=IIF+1 
      CALL KSTRQ(N2,IBBB,0,IIF) 
      CALL WRIT(IBBB) 
      RETURN
      END 
      SUBROUTINE CGOT(IBBB,IEW,N1)
C# LAST COMPC'ED  870105:21:16      : 
C SUBROUTINE TO WRITE GO TO 
      INTEGER IBBB(1) 
      INTEGER LGO(4)
      DATA LGO    /   6,2HGO,2H T,2HO / 
      IBBB=IEW+10 
      CALL FILLQ(IBBB,1,IBBB+1) 
      CALL MOVEQ(LGO,1,IBBB,IEW,6)
      IEW6=IEW+6
      CALL KSTRQ(N1,IBBB,0,IEW6)
      CALL WRIT(IBBB) 
      RETURN
      END 
      SUBROUTINE CDATE(IB,IDCBI,ICNTRL,KDATE,ICFLAG,ICDATE,LCDQ)
C# LAST COMPC'ED  870105:21:16       :
C SUBROUTINE TO ENTER DATE IN INPUT FILE
C     IF ICFLAG=1, CHECK FOR C# AND ADD DATE AS NECESSARY.
C     IF ICFLAG=2, CHECK FOR CONTINUATION AND C# AND ADD DATE AS NECESSARY. 
      INTEGER IB(1),IDCBI(1),LCDQ(1)
      INTEGER LCMP(9),LCNUM(2),LDAT(3),LD2H(17) 
      DATA LCMP   /  16,2H L,2HAS,2HT ,2HCO,2HMP,2HC',2HED,2H  /
      DATA LCNUM  /   2,2HC#/ 
      DATA LDAT   /   4,2HDA,2HTA/
      DATA LD2H   /  32,2H /,2H2H,2H  ,2H,2,2HH ,2H ,,2H2H,2H  ,2H,2, 
     /             2HH ,2H ,,2H2H,2H  ,2H,2,2HH ,2H //
C     IF SECURITY CODE DISAGREEMENT, RETURN 
      IF (IAND(IDCBI(8),100000B) .EQ. 0) GO TO 499
      IF (ICFLAG .EQ. 0) GO TO 490
      IF (ICFLAG .EQ. 1) GO TO 489
      IF (IGETQ(IB,1) .EQ. 40B .AND. IGETQ(IB,6) .NE. 40B) GO TO 489
      ICFLAG=0
      GO TO 490 
C     CHECK FOR C# CARD AND ADD DATE/TIME IF FOUND
489   J=IPOSQ(IB,LCNUM,1) 
      IF (J .EQ. 0 .OR. KDATE .GE. 1) GO TO 491 
      CALL MOVEQ(LCDQ,3,IB,J+2,12)
      CALL POSNT(IDCBI,IERR,-1,0) 
      CALL WRITF(IDCBI,IERR,IB(2),(IB+1)/2) 
491   ICFLAG=2
      IF (ICNTRL .EQ. 2 .OR. ICNTRL .EQ. 8) ICFLAG=0
C CHECK FOR C# OR *# LAST COMPC'ED CARD UNLESS RE-DATING SUSPENDED
490   IF(IB(2).NE.ICDATE) GO TO 499 
C CHECK FOR DATE DATA STATEMENT 
      IF(IPOSQ(IB,LDAT,7).NE.7) GO TO 495 
C IF RE-DATING SUSPENDED, ONLY CLEAR C# 
      IF(KDATE.GE.1) GO TO 494
      DO 493 I=1,6
493   CALL MOVEQ(LCDQ,2*I+1,LD2H,5*I,2) 
      CALL MOVEQ(LD2H,1,IB,19,32) 
      CALL POSNT(IDCBI,IERR,-1,0) 
      CALL WRITF(IDCBI,IERR,IB(2),(IB+1)/2) 
494   CALL FILLQ(IB,1,6)
      GO TO 499 
495   IF(KDATE.GE.1) GO TO 499
C     CONSTRUCT DATE IN OUTPUT FORMAT 
      CALL MOVEQ(LCMP,1,IB,3,16)
      CALL MOVEQ(LCDQ,3,IB,19,12) 
C POSITION INPUT FILE FOR REWRITING 
      CALL POSNT(IDCBI,IERR,-1,0) 
C WRITE NEW C# OR *# CARD(MUST BE SAME LENGTH AS READ)
      CALL WRITF(IDCBI,IERR,IB(2),(IB+1)/2) 
499   CONTINUE
      RETURN
      END 
      FUNCTION IENDC(IB,IBB,ISTRC,ICNTRL,ICP,KCP,KSTRUC,
     1               IST1,IST2,IST3,IST4) 
C# LAST COMPC'ED  870105:21:16       :
C FUNCTION TO HANDLE END CARDS
C IENDC = 1 - NOT END CARD
C       = 2 - END CARD
      INTEGER IB(1),IBB(1)
      INTEGER IST1(1),IST2(1),IST3(1),IST4(1) 
      INTEGER LTHEL(7),LWHIL(7),LCASE(5),LFORD(6) 
      INTEGER LEND(3),LSPAC(2),LRET(7),LCONT(8) 
C-----INTEGER LENDD(6)
      DATA LTHEL  /  12,2H**,2H*T,2HHE,2HN-,2HEL,2HSE/
      DATA LWHIL  /  11,2H**,2H*W,2HHI,2HLE,2H-D,2HO /
      DATA LCASE  /   7,2H**,2H*C,2HAS,2HE /
      DATA LFORD  /   9,2H**,2H*F,2HOR,2H-D,2HO / 
      DATA LEND   /   3,2HEN,2HD /
      DATA LSPAC  /   1,2H  / 
      DATA LRET   /  12,2H32,2H76,2H7 ,2HRE,2HTU,2HRN/
      DATA LCONT  /  14,2H32,2H76,2H7 ,2HCO,2HNT,2HIN,2HUE/ 
C-----DATA LENDD  /  10,2H  ,2H  ,2H  ,2HEN,2HD$/ 
      IENDC=1 
C CHECK FOR "END" CARD
      IF (ICNTRL .EQ. 2 .OR. ICNTRL .EQ. 8) GO TO 526 
C     FTN4/RAT4 
      ISER=KPRSQ(IB,IBB(6),1,ISTRC,0,2H  )
      IF(ISER.NE.0.AND.ISER.LT.73) GO TO 900
      IF (IBB.EQ.3.AND.KMPRQ(IBB,LEND).EQ.1) 524,900
524   CONTINUE
C CHECK STRUCTURE FLAG FOR POSSIBLE LABELED RETURN
      IF(KSTRUC.EQ.1) 525,560 
525   IF(ICP.NE.1.AND.ICP.NE.9) CALL WRIT(LRET) 
      IF(ICP.EQ.1) CALL WRIT(LCONT) 
C CHECK STACKS FOR UNCLOSED BLOCKS
      CALL PCHEC(LTHEL,IST1,IBB)
      CALL PCHEC(LWHIL,IST2,IBB)
      CALL PCHEC(LCASE,IST3,IBB)
      CALL PCHEC(LFORD,IST4,IBB)
      GO TO 560 
C     ASMB
C     GET FIRST 3 CHARACTERS FOLLOWING FIRST SPACE IN LINE
526   ISTRC=IPOSQ(IB,LSPAC,1) 
      IF (ISTRC .LE. 0) GO TO 900 
      IDUM=KPRSQ(IB,IBB,4,ISTRC,0,2H  ) 
      IF (IBB .EQ. 3 .AND. KMPRQ(IBB,LEND) .EQ. 1) 560,900
560   IENDC=2 
C END CARD FOUND - WRITE END AND END$ 
      CALL WRIT(IB) 
C-----IF(KCP.EQ.0) CALL WRIT(LENDD) 
900   RETURN
      END 
      SUBROUTINE PCHEC(LN,IST,IBB)
C# LAST COMPC'ED  870105:21:16      : 
C SUBROUTINE TO CHECK STACKS FOR UNENDED BLOCKS 
      INTEGER LN(1),IST(1),IBB(1),IDCBO(1)
      INTEGER LBLK(9) 
      DATA LBLK   /  16,2HBL,2HOC,2HK ,2HNO,2HT ,2HEN,2HDE,2HD:/
      IF(IST(3).EQ.3) GO TO 900 
      CALL FILLQ(IBB,1,80)
      CALL MOVEQ(LN,1,IBB,1,LN) 
      CALL MOVEQ(LBLK,1,IBB,LN+2,16)
      IS=IST(3)-3 
      DO 50 I=1,IS
50    CALL PGET(IST,IBB(38-I),IERR) 
      IBB=72
      CALL ERRS(0,IBB)
900   RETURN
      END 
      FUNCTION IWCL(IB,ICOMNT,ICNTRL,ILIST,IDEBUG)
C# LAST COMPC'ED  870105:21:16 :
C FUNCTION TO HANDLE COMMENT OR DEBUG LINES 
C IWCL = 1 - LINE TO BE PROCESSED 
C      = 2 - COMMENT OR CONTINUATION TO BE WRITTEN
C      = 3 - LINE TO BE SKIPPED 
      INTEGER IB(1) 
      INTEGER LDEBUG(4) 
      DATA LDEBUG /   5,2HDE,2HBU,2HG / 
      IWCL=1
      IC1=IGETQ(IB,1) 
C CHECK FOR DEBUG UNLESS ASMB - COL 1 = D 
      IF(IC1.EQ.104B.AND.(ICNTRL.NE.2.AND.ICNTRL.NE.8)) 10,19 
10    IF(IDEBUG.EQ.0) 11,15 
C LINE TO BE COMMENT
11    CALL PUTQ(IB,1,103B)
      IC1=103B
      GO TO 16
C LINE TO BE COMPILED 
15    CALL PUTQ(IB,1,40B) 
      IC1=40B 
C INSERT DEBUG AT COL 73
16    CALL FILLQ(IB,IB+1,73)
      IB=73 
      CALL MERGQ(IB,IB,LDEBUG)
19    CONTINUE
C CHECK FOR COMMENT 
      IF(IC1.EQ.ICOMNT) 20,29 
C20---IF(ILIST.EQ.0.OR.ILIST.EQ.2) 21,25
20    IF (ILIST .EQ. 2) 21,25 
C NO LISTING OR COMMENTS TO BE SUPPRESSED 
21    IWCL=3
      GO TO 900 
C COMMENTS TO BE LISTED 
25    IWCL=2
      GO TO 900 
29    CONTINUE
C CHECK FOR ASSEMBLER - LINE TO BE PROCESSED
      IF(ICNTRL.EQ.2.OR.ICNTRL.EQ.8) GO TO 900
C CHECK FOR CONTINUATION LINE - LINE TO BE WRITTEN WITHOUT PROCESSING 
      IF(IGETQ(IB,6).NE.40B) IWCL=2 
900   RETURN
      END 
      SUBROUTINE COPRL(IBB,NAM,ICRO,IB,LENX,IDCB,LL,NLL,IERR) 
C# LAST COMPC'ED  870105:21:16
C SUBROUTINE TO COPY ONE FILE INTO ANOTHER - USED BY CCMPL
      INTEGER IBB(1),NAM(1),IB(1),IDCB(1),LL(1) 
      CALL OPEN(IBB,IERR,NAM,0,0,ICRO)
      IF(LL.NE.0) CALL WRITF(IDCB,IERR,LL,NLL)
      DO 320 II=1,32767 
      CALL READF(IBB,IERR,IB,LENX,LEN)
      IF(LEN.EQ.-1) GO TO 330 
      CALL WRITF(IDCB,IERR,IB,LEN)
      IF(IERR.NE.0) GO TO 900 
320   CONTINUE
330   CALL CLOSE(IBB) 
900   RETURN
      END 
      SUBROUTINE COPRN(IBB,IB,LENX,IDCB,IERR) 
C# LAST COMPC'ED  870105:21:16
C SUBROUTINE TO COPY ONE ROUTINE FROM A RELOCATABLE FILE - USED BY CCMPL
      INTEGER IBB(1),NAM(1),IB(1),IDCB(1) 
      LOGICAL NAMRC 
C BACK UP TO NAM RECORD 
      CALL POSNT(IBB,IERR,-1) 
      DO 320 II=1,32767 
      CALL READF(IBB,IERR,IB,LENX,LEN)
      IF(LEN.EQ.-1) GO TO 900 
C SKIP OUT IF NEXT NAM RECORD 
      IF(II.NE.1.AND.NAMRC(IB)) GO TO 400 
      CALL WRITF(IDCB,IERR,IB,LEN)
      IF(IERR.NE.0) GO TO 900 
320   CONTINUE
400   CALL POSNT(IBB,IERR,-1) 
900   RETURN
      END 
      LOGICAL FUNCTION NAMRC(IBUF,NAMQ) 
C     LOGICAL NAMRC(IBUF,[NAMQ])
C 
C     Returns .TRUE. if record in IBUF is a NAM or XNAM record. 
C     NAMQ (optional) returns module name in Q format.
C 
C     ARW 821213
C 
      INTEGER IBUF(1),NAMQ(1) 
C 
      NARG=PCOUNT() 
      NAMRC=.TRUE.
      ITYPE=IAND(IBUF(2),160000B) 
      IF (ITYPE .EQ. 20000B) THEN 
C         NAM record
          IF (NARG .GT. 1) THEN 
              CALL WMOVE(IBUF(4),NAMQ(2),3) 
              NAMQ=5
              CALL TRIMQ(NAMQ)
          ENDIF 
      ELSE IF (ITYPE.EQ.160000B .AND. IAND(IBUF(2),17700B).EQ.100B) THEN
C         XNAM record 
          IF (NARG .GT. 1) THEN 
              NW=IAND(IBUF(25),377B)
              CALL WMOVE(IBUF(26),NAMQ(2),NW) 
              NAMQ=2*NW 
              CALL TRIMQ(NAMQ)
          ENDIF 
      ELSE
          NAMRC=.FALSE. 
      ENDIF 
      RETURN
      END 
      FUNCTION NMLST(IB,IBB,IDCBI,KNML,LUI,LPR) 
C# LAST COMPC'ED  870105:21:16
C FUNCTION TO PROCESS OUTPUT NAMELISTS
C RESTRICTIONS: NAMELIST MUST BE FOLLOWED BY AT LEAST ONE BLANK.
C               NO NAME IN THE LIST CAN BE ON TWO LINES AND EACH NAME 
C               MUST BE FOLLOWED BY A COMMA.
C 
C KNML = -1 - STARTING NEW ROUTINE SO INITIALIZE FLAG, POINTER, ARRAYS
C      = 0 - INITIALIZED BUT NO NAMELISTS YET FOUND 
C      > 0 - KNML NAMELISTS SAVED 
C 
C NMLST = 1 - PROCESS NON-NAMELIST LINE READ BY NMLST 
C       = 2 - NOT NAMELIST LINE 
C       = 3 - READ NEXT LINE
C 
      INTEGER IB(1),IBB(1),IDCBI(1),LPR(1)
      INTEGER LNML(4,50),LUNT(4)
      INTEGER LNM(5),LSL(2),LWR(4),LLP(2),LRP(2),LCM(2),LNN(2),LBL(2) 
      INTEGER LCN(5),LIN(4),LER1(19),LFI(18),LFR(21),L77(4),L88(4)
      INTEGER L6H(2)
C SIZE OF NAMELIST ARRAY
      DATA MNML /50/
      DATA LNM    /   7,2HNA,2HME,2HLI,2HS /
      DATA LSL    /   1,2H/ / 
      DATA LWR    /   5,2HWR,2HIT,2HE / 
      DATA LLP    /   1,2H( / 
      DATA LRP    /   1,2H) / 
      DATA LCM    /   1,2H, / 
      DATA LNN    /   2,2H@@/ 
      DATA LBL    /   1,2H  / 
      DATA LCN    /   8,2HCO,2HNT,2HIN,2HUE/
      DATA LIN    /   6,2HIJ,2HKL,2HMN/ 
      DATA LER1   /  36,2H**,2H*N,2HAM,2HEL,2HIS,2HT ,2HAR,2HRA,2HY , 
     /             2HOV,2HER,2HFL,2HOW,2H A,2HT ,2H  ,2H  ,2H  /
      DATA LFI    /  34,2H77,2H77,2H7 ,2HFO,2HRM,2HAT,2H(1,2HX,,2HA6, 
     /             2H,1,2H5I,2H8/,2H(7,2HX,,2H15,2HI8,2H))/ 
      DATA LFR    /  40,2H88,2H88,2H8 ,2HFO,2HRM,2HAT,2H(1,2HX,,2HA6, 
     /             2H,5,2HD2,2H5.,2H16,2H/(,2H7X,2H,5,2HD2,2H5.,2H16, 
     /             2H))/
      DATA L77    /   5,2H77,2H77,2H7 / 
      DATA L88    /   5,2H88,2H88,2H8 / 
      DATA L6H    /   2,2H6H/ 
C INITIALIZE FLAG, COUNTER, ARRAYS FOR NEW ROUTINE
      IF(KNML.EQ.-1) 100,199
100   KNML=0
      INML=0
      KFI=0 
      KFR=0 
      DO 110 I=1,MNML 
110   LNML(1,I)=0 
      LER1=30 
199   CONTINUE
C CHECK LINE FOR NAMELIST DEFINITION
200   IF(KMPRQ(IBB,LNM).NE.1) GO TO 299 
C EXTRACT NAMELIST FROM BETWEEN SLASHES 
      I1=IPOSQ(IB,LSL,15) 
      I2=IPOSQ(IB,LSL,I1+1) 
      CALL SEGQ(IB,I1+1,I2-1,IBB) 
C REMOVE BLANKS 
      IDUM=IXQ(IBB,LBL,0,0) 
C CHECK FOR ARRAY OVERFLOW
      IF(INML.GE.MNML-2) GO TO 890
C SAVE NAME AFTER MARKER
      INML=INML+1 
      CALL MERGQ(LNML(1,INML),LNN)
      INML=INML+1 
      CALL MERGQ(LNML(1,INML),IBB)
C SAVE NAME POSITION
      INAM=INML 
C INCREMENT FLAG
      KNML=KNML+1 
C TRUNCATE AT 72 AND DELETE THROUGH 2ND SLASH 
      IF(IB.GT.72) IB=72
      CALL DLETQ(IB,1,I2) 
C TRANSFER LIST TO ARRAY
      CALL NMT(IB,IBB,INML,MNML,LNML,LUI) 
C CHECK FOR ARRAY OVERFLOW
      IF(INML.GT.MNML) GO TO 891
C LOOP OVER CONTINUATION CARDS, IF ANY
      DO 220 I=1,32767
      CALL READI(IDCBI,IERR,IB,40,LEN,LPR)
C IF NOT CONTINUATION, PROCESS NORMALLY 
      IF(IB.LT.7.OR.IGETQ(IB,1).EQ.103B.OR.IGETQ(IB,1).EQ.104B.OR.
     1  IGETQ(IB,6).EQ.40B) GO TO 901 
C TRUNCATE TO 72 AND DELETE THROUGH 6 
      IF(IB.GT.72) IB=72
      CALL DLETQ(IB,1,6)
C TRANSFER LIST TO ARRAY
      CALL NMT(IB,IBB,INML,MNML,LNML,LUI) 
C CHECK FOR ARRAY OVERFLOW
      IF(INML.GT.MNML) GO TO 891
220   CONTINUE
299   CONTINUE
C IF NAMELISTS SAVED, CHECK FOR WRITE(UNIT,NAMELIST)
      IF(KNML.GT.0) 300,399 
300   IF(IPOSQ(IBB,LWR,1).NE.1) GO TO 399 
C EXTRACT UNIT AND POSSIBLE NAMELIST
      ILP=IPOSQ(IB,LLP,7) 
      ICM=IPOSQ(IB,LCM,ILP) 
      IRP=IPOSQ(IB,LRP,ICM) 
      CALL SEGQ(IB,ILP+1,ICM-1,IBB) 
      IDUM=IXQ(IBB,LBL,0,0) 
      CALL MERGQ(LUNT,IBB)
      CALL SEGQ(IB,ICM+1,IRP-1,IBB) 
      IDUM=IXQ(IBB,LBL,0,0) 
C CHECK AGAINST SAVED NAMELISTS BY LOOKING FOR MARKER 
      DO 310 I=1,INML 
      IF(KMPRQ(LNML(1,I),LNN).NE.1) GO TO 310 
      INAM=I+1
      IF(KMPRQ(LNML(1,INAM),IBB).EQ.1) GO TO 320
310   CONTINUE
C NOT SAVED AS NAMELIST 
      GO TO 902 
C NAMELIST FOUND - WRITE CONTINUE IF LABELED
320   IB=6
      CALL TRIMQ(IB)
      IF(IB.EQ.0) GO TO 330 
      IB=6
      CALL MERGQ(IB,IB,LCN) 
      CALL WRIT(IB) 
C LOOP OVER LIST
330   DO 340 I=INAM+1,INML
      CALL MERGQ(IBB,LNML(1,I)) 
C CHECK FOR MARKER AT END OF LIST 
      IF(KMPRQ(IBB,LNN).EQ.1) GO TO 341 
C SEPARATE INITIAL CHARACTER
      CALL SEGQ(IBB,1,1,IBB(5)) 
      KI=IPOSQ(LIN,IBB(5),1)
C FORM WRITE(UNIT,77777/88888)6HITEMMM,ITEM 
      CALL FILLQ(IB,1,72) 
      IB=6
      CALL MERGQ(IB,IB,LWR,LLP,LUNT,LCM)
      IF(KI.NE.0) CALL MERGQ(IB,IB,L77) 
      IF(KI.EQ.0) CALL MERGQ(IB,IB,L88) 
      CALL MERGQ(IB,IB,LRP,L6H,IBB,LCM,IBB) 
      CALL WRIT(IB) 
C WRITE 77777 OR 88888 FORMATS ONCE 
      IF(KI.NE.0.AND.KFI.EQ.0) CALL WRIT(LFI) 
      IF(KI.EQ.0.AND.KFR.EQ.0) CALL WRIT(LFR) 
      IF(KI.NE.0) KFI=KFI+1 
      IF(KI.EQ.0) KFR=KFR+1 
340   CONTINUE
341   CONTINUE
      GO TO 903 
399   CONTINUE
      GO TO 902 
C ARRAY OVERFLOW MESSAGE
890   CALL MERGQ(LER1,LER1,IBB) 
      GO TO 892 
891   CALL MERGQ(LER1,LER1,LNML(1,INAM))
892   CALL ERRS(0,LER1) 
      GO TO 903 
C PROCESS NON-NAMELIST LINE READ BY NMLST 
901   NMLST=1 
      GO TO 910 
C NOT NAMELIST LINE - PROCEED 
902   NMLST=2 
      GO TO 910 
C READ NEXT LINE
903   NMLST=3 
910   RETURN
      END 
      SUBROUTINE NMT(IB,IBB,INML,MNML,LNML,LUI) 
C# LAST COMPC'ED  870105:21:16
C SUBROUTINE TO TRANSFER NAMELIST ITEMS TO ARRAY
      INTEGER IB(1),IBB(1),LNML(4,1)
      INTEGER LBL(2)
      DATA LBL    /   1,2H  / 
      ISTRC=1 
      CALL TRIMQ(IB)
C LOOP OVER ITEMS SEPARATED BY COMMAS 
      DO 100 I=1,32767
      IF(KPRSQ(IB,IBB,72,ISTRC,0,2H ,).EQ.0) GO TO 900
C INCREMENT COUNTER 
      INML=INML+1 
C EXIT IF OVERFLOW
      IF(INML.GT.MNML) GO TO 900
      IDUM=IXQ(IBB,LBL,0,0) 
      CALL FILLQ(IBB,IBB+1,6) 
      IBB=6 
      CALL MERGQ(LNML(1,INML),IBB)
100   CONTINUE
900   RETURN
      END 
      FUNCTION ISCRT(ICRI,ICRO,IBUF)
C 
C     Determine cartridge ref for COMPC scratch files 
C 
C     On entry: 
C        ICRI,   cart ref of source file (assumed to be a valid cartref)
C        ICRO,   value of ICRO as specified in BLOCK DATA CNTRL 
C        IBUF,   scratch buffer of at least 128 words 
C     On return:
C        ISCRT,  specifies cartref for scratch files
C 
C     Algorithm:
C        If ICRO=-32767, set ISCRT=ICRI unconditionally.
C        If ICRO=0, set ISCRT to cartridge currently at top of current 'CL' 
C           list, but not lu2 or lu3. 
C        If ICRO is a valid cartref within the current 'CL' list, set ISCRT=ICRO
C           (including lu2 or lu3, if specified, but will not normally work 
C           under a Session Monitor system) 
C        Otherwise, set ICRO=ICRI unconditionally.
C 
C     ARW 810718
C 
      INTEGER IBUF(1) 
C 
      ISCRT=ICRI
      IF (ICRO .EQ. -32767) RETURN
      CALL FSTAT(IBUF)
      DO 100 I=1,124,4
      ISCRT=ICRI
      IF (IBUF(I) .EQ. 0) RETURN
      ISCRT=ICRO
      LU=IBUF(I)
      IF (LU.EQ.-ISCRT .OR. IBUF(I+2).EQ.ISCRT) RETURN
      ISCRT=-LU 
      IF (ICRO.EQ.0 .AND. LU.NE.2 .AND. LU.NE.3) RETURN 
100   CONTINUE
      END 
