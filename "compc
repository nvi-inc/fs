1 PROGRAM COMPC - A compiler management program 
Note: The current version of COMPC directs all Fortran code to the FTN7X
      compiler and all ASMB/MACRO code to MACRO.
  
  A compiler management program.  Allows a source file to be any mixture
  of ASMB/MACRO, FTN(4/4X/7X), and RAT4.  Allows entire file to be
  compiled, or any subset of specified routines within the source file. 
  Creates either composite or individual relocatable files at the user's option.
  
 -----------------------------------------------------------------------------
  
  Interactive Mode: 
  
    RU,COMPC,LUI/NAMR,LUO,KDATE:ICR1:ICR2 
  
      where LUI   = operator LU 
         or NAMR  = source file NAMR
            LUO   = LU for compiler printout
                  = 0 (default) - send compiler printout to LUI 
                  = 64 - suppress all compiler printout 
                  = " (double quote) - create list file(s) named 'PROGM,
                      one for each compiled module, where PROGM is the name 
                      of the module.
                  = ' (single quote) - create a single list file 'NAMR, where 
                      NAMR is taken from characters 2-6 of the source file name.
                      List files are created on the same LU as relocatable
                      files or on the source LU if relocatable files are
                      not created.
                  = <0 - summary output (see below) and major error messages
                         are sent to -LUO while individual compilation
                         messages are sent to LUI.
            KDATE = 0 (default) for automatic update of "date cards (see Note 4)
                  = 1 - suppress "date card" update 
            ICR1    (optional) cartref to replace $INCLUDE cartrefs specified 
                    as 'XX' (see below) 
            ICR2    (optional) cartref to UNCONDITIONALLY replace $INCLUDE
                    cartrefs with ICR2
  
  COMPC will prompt for all other information as required (see details of 
  questions and possible answers in the section on NON-INTERACTIVE running
  of COMPC).
  
  The following output will appear after the input file is finished:
  1.  A list of routines processed, provided ALL routines within the source 
      file were processed.
  2.  Routines not found - if routines specified. 
  3.  Routines with errors   (-N) where N is the sum of warnings, errors, 
                             disasters, and preprocessing errors for
                             the routine. 
  
 -----------------------------------------------------------------------------
  
  Non-interactive Mode (compile ALL routines):
  
    RU,COMPC,LUI,LUO,&NAMR,CR1,CR2,KDATE:ICR1:ICR2,PARMS,0,TNAME
  
      where LUI   = operator LU (defaults to 1) 
            LUO   = LU for printout (defaults to LUI) 
                  = 64 - suppress all printout
                  = " - create list file(s), one for each module compiled.
                        These files will be named 'NAME, where NAME is the
                        name of the compiled module.
                  = ' - create a single list file named 'NAME, where NAME is
                        is taken from characters 2-6 of the input file name.
                  = <0 - summary output (see above) and major error messages
                         are sent to -LUO while individual compilation
                         messages are sent to LUI.
            &NAMR = "Source File NAMR?" 
                    NAMR of the input source code file to be compiled.
            CR1   "CARTREF for %FILES (<>=NONE, <N>EW, <A>DD, <R>EPLACE)?"
                  Specifies if and how relocatables are to be saved 
                  = 0 (default) OR <SPACE> - no relocatables saved
                  = cartref:security code  - save each routine to an individual 
                        relocatable file on cartridge 'cartref' (may not be 'N',
                        'A', or 'R') with security code as specified. 
                        Note: An existing security code of zero will NOT be 
                              changed.  If an existing file already has a security
                              code, it MUST be specified. 
                  = :security code:cartref - same as above but must be used if
                    cartref is not numeric. 
                  = N - create a NEW file for composite relocatables
                  = A - ADD relocatables to an existing relocatable file
                        You may optionally specify that the new relocatables
                        be added BEFORE a particular module within the
                        existing file by specifying A:<module name>. If no
                        module name is specified or if it does not exist, 
                        new relocatables will be added to the end of the
                        existing file.
                  = R - REPLACE relocatable modules within an existing file.
                        If a relocatable module does not already exist within 
                        the file, it will be added. 
                  = D - DELETE a particular module within a combined
                        relocatable by specifying D:<module name>. A dummy
                        source file (&NAMR) must be supplied. 
                    Note: No LOADR command file is created if N,A,R, or D is used.  
            CR2   "CARTREF or NAMR for composite output?" 
                  (applicable only if CR1 = N, A, or R) 
                  = cartref:security code - composite relocatables will be saved
                    to 'cartref'. %NAME is constructed from characters 2-6 of the 
                    input file name.  A security code for the composite relocatable 
                    file may be specified in the format 'cartref:sc'. 
                    Note: An existing security code of zero will NOT be changed.
                          If an existing file already has a security code, it 
                          MUST be specified.
                  = :security code:cartref - same as above but must be used if
                    cartref is not numeric. 
                  = NAMR - Use NAMR as target file for relocatables.  NAMR is 
                           created or opened as necessary.
            KDATE:ICR1:ICR2 = same as INTERACTIVE MODE above
            PARMS   "Control Parameters (<>=NONE)?" 
                    Default is no compiler parameters.
                    In non-interactive mode, parameters are separated by
                       periods (e.g. L.C).
                    In interactive mode, parameters are separated by commas 
                       (e.g. L,C).
                    These parameters replace any existing parameters in FTN4
                    or ASMB/MACRO control statements, except for X/Y or I/J in
                    FTN(4/4X/7X) control statements (see Note 5 below). 
            TNAME  "LOADR Command File NAMR (<>=NONE)?" 
                    NAMR of LOADR command file to be created. 
                  = 0 (default) - do not create LOADR command file
  
  Non-interactive mode (compile only SPECIFIED routines)
  
    RU,COMPC,LUI,LUO,&NAMR,CR1,CR2,KDATE,PARMS,NAME1,NAME2,....,NAMEn 
  
      where NAME1,NAME2,etc are the names of the routines to be compiled
            and all other parameters are as described above.
            In the interactive mode, routine names to be compiled are entered 
            in response to the question "Routine Names (<>=ALL, <::>=END)?".
            Enter <space> to compile all routines; or a list of specific
            routine names, separated by commas and terminated by "::" 
            (may be entered on several lines, but must be terminated with "::").
  
  CAUTION:In NON-INTERACTIVE MODE, any files with the same name as COMPC
          wants to create will be automatically purged!!!!!!! 
  
 -----------------------------------------------------------------------------
  
 NOTES: 
  
 1. FTN(4/4X/7X) ASMB/MACRO, and RAT4 routines may be mixed in the input file.  However, an 
    appropriate compiler control card must precede each block of code 
    intended for a particular compiler.  Any END$ cards are ignored.
  
 2. Each routine (PROGRAM, SUBROUTINE, OR FUNCTION) is compiled separately
    and saved according to paramters CR1 and CR2.  Names of all created files 
    are listed as they are created.  Any existing files with the same NAMR will 
    be purged.
  
 3. To compile an entire file in the interactive mode, reply <BLANK>
    to "Routine Names (<>=ALL,<::> to end)?".  If all routines are compiled 
    to individual relocatable files, an option to create a LOADR command file 
    of a specified NAMR is available.  Any existing file with the specified 
    NAMR is purged on operator OK only. 
  
 4. A line beginning "C#" (FTN4/4X/7X), "*#" (ASMB/MACRO) or "#!" (RAT4) and containing a 
    non-blank character beyond column 29 will be updated to show the last date
    and time the routine was COMPC'ed.  The "date card" must appear after the 
    "SUBROUTINE/PROGRAM/FUNCTION/NAM" line and before "END".  "C#" may also 
    appear in the field on PROGRAM/SUBROUTINE/FUNCTION cards which
    FTN4/4X/7X puts into the relocatable file as a title.  A character must 
    appear in the 12th column beyond the 'C#', '*#', or '#!' in order to reserve
    sufficient space.  If the file is protected by a non-zero security code,
    the security code must specified in the file NAMR if the "date card" is 
    to be updated.
  
 5. If X/Y or I/J exist as parameters in a FTN4/4X/7X control line in the 
    source file, e.g. FTN4X,X,I, these will be passed through to the compiler 
    automatically.  If X/Y or I/J are specified as COMPC input parameters,
    they will override any corresponding existing parameters in the source file.
  
 6. COMPC creates several scratch files for its own use.  The names 
    of the files are &C1*xx, %C2*xx, 'C3*xx, %C4*xx, &C5*xx where xx is 
    taken from the last two characters of the copy of COMPC currently executing.
    These files are automatically purged when COMPC ends.  Normally, these
    scratch files will be created on the same cartridge as the source file, 
    but they may be directed either to a specified cartridge or to the
    cartridge at the top of your 'CL' cartridge list, depending on the value
    of a parameter in a DATA statement in BLOCK DATA CNTRL of file &COMPC.
    
 7. COMPC returns 5 integer parameters (via PRTN) to the father program:
         1 - total# compilation errors
         2 - #modules with compilation errors 
         3-5 unused 
  
 -----------------------------------------------------------------------------
  
  NOTE:A bug has been noted in COMPC that will seldom affect
       a compilation and is messy to fix, so we'll forget about it
       for now -- if the first statement of an ASMB/MACRO routine is "IFN" or 
       "IFZ", (instead of "NAM ---" as is normally the case), COMPC will
       not pass that statement to the compiler and an error may result. 
       ARW 770804 
  
 -----------------------------------------------------------------------------
  
1 ENHANCED CAPABILITIES OF COMPC SUPPORTING FTN4/4X/7X AND RAT4 
  
  1. "K" listing option - lists only non-comment lines
  
  2. Literal and string arrays -
  
        LDATA  - dimension array and fill with specified literal data 
        QDATA  - dimension array and fill with specified literal data 
                 in 'string' format (i.e. first word of array contains
                 character count) that may be operated upon by routines 
                 in the QSUBS string-handling subroutine package. 
        DLDATA - same as LDATA except assumes array has already been dimensioned. 
        DQDATA - same as QDATA except assumes array has already been dimensioned. 
  
     A line of the form "LDATA NAME /STRING/" will be replaced by a 
     DIMENSION statement for the array called "NAME" and a DATA statement 
     for all the charapters appearing in "STRING".  A "QDATA NAME/STRING/"
     includes the character count in the first word of array NAME so that 
     the QSUBS package may be used.  DLDATA and DQDATA are identical except 
     they assume that the array NAME has already been dimensioned by the user.
  
     The rules for the usage of these statements is as follows: 
        a. LDATA lines must appear directly before any normal DATA lines and
           after all other specification statements.
        b. Up to 7 continuation cards may be used.
        c. The delimiter surrounding the string ("/" in the example) may be 
           any character that is not a legal character in a Fortran variable
           name.  Furthermore, the opening delimiter must appear on the same
           line as the LDATA,etc statement. 
        d. Only one string may be defined by each LDATA,etc statement.
  
  3. $EMA,$FILES,$PAGE,$TITLE,$MSEG,$ALIAS,$CODE,$LIST,$CDS,$TRACE directives 
  
     '$' directives are handled by COMPC in much the same was as FTN4/4X/7X.
     The following rules apply: 
       1. All '$' directives that appear between the compiler control 
          statement and the PROGRAM/SUBROUTINE/FUNCTION declaration 
          will remain in effect for every routine until another compiler
          control statement is encountered, at which time they will be
          re-initialized. 
       2. Comment lines may be interspersed between '$' directives. 
       3. '$' directives that appear after the PROGRAM/SUBROUTINE/FUNCTION
          declaration will be passed directly through to the compiler 
          (i.e. treated as a normal line of code).
       4. Any '$' directives between routines not preceded by a compiler
          control statement will be ignored.
  
  4. DATE variable -
  
     If a line of the following form exists in the source file, a date variable 
     is set.  It will have the same value as the date on C# lines.
  
 ''''/''''1''''/''''2''''/''''3''''/''''4''''/''''5''''/''''6''''/''''7''''/''' 
       DIMENSION name(6)
 C#    DATA name                                  : 
  
     The DATA statement is completed with 12 characters of date time and is 
     written back into the source file.  The 'C#' is stripped before the line 
     is sent to the compiler.  The user must supply the appropriate dimension 
     statement for the variable.  The data is not changed if re-dating is
     suspended (KDATE=1) but the original data statement is sent to the 
     compiler.
  
  5. Output NAMELIST -
  
     NAMELIST for output only can be used.  The format of the NAMELIST
     statement is:
          NAMELIST /NAMEXX/ ITEM1,XTEM2,... 
     and the format of the write statement is WRITE(LUO,NAMEXX).
     The NAMELIST statement may have continuation lines.  Each item in
     the NAMELIST is written in either I or D format depending on the 
     initial character.  Typing by implicit or explicit statements is 
     ignored.  Each variable or array appears on a separate line on the 
     output device. 
  
 6.  $INCLUDE directive 
  
     $INCLUDE allows entire files to be added to the source file at compilation 
     time.  The format of the $INCLUDE directive is 
          $INCLUDE NAMR 
     beginning in column 1. 
  
     $INCLUDE may appear at any point within a source file and may be nested
     to an arbitrary depth (i.e. included files may also contain $INCLUDE). 
     COMPC handles the included files exactly as if they were in-line within
     the main source file.  If the cartref specification in NAMR is 'XX', the 
     second subparameter in the KDATE field (see above) may be used to replace
     'XX' with the specified cartref.  This feature is very useful in making
     source files transportable.
  
  7. $PARM directive
  
     The $PARM directive allows replacement of specified ASCII strings within a 
     FTN source file.  $PARM statements must appear as the first non-comment
     statement(s) following FTN4/4X/7X/RAT4 control statement and may be mixed with 
     other directives.  They remain in effect until another compiler
     control card appears.  $PARM must begin in column 1. 
  
     The form of the $PARM line is: 
           $PARM dXXXdYYYd cccccc 
     where d = arbitrary delimiter
           XXX = string to be replaced wherever it appears in the source
           YYY = replacement string 
           cccccc = comments
     The target and replacement strings are limited to 20 characters each 
     but need not be the same length.  If the replacement string is longer
     than the target string, line overflow may occur.  Imbedded blanks
     are permitted in both the target and replacement strings, although 
     all leading and trailing spaces are deleted.  More than
     one $PARM line is required if several replacements are to be made. 
     Errors resulting from $PARM directives will cause COMPC to end immediately 
     with an error message.  If replacement causes a line to exceed 72 characters,
     an error message is sent to the output unit and the routine is flagged.
     Lines with $PARM targets should also not exceed 72 characters before 
     replacement. 
        The array used to hold the $PARM directives is dynamically allocated
     according to the partition size in which COMPC is running.  Assigning
     a larger partition size will increase the space available for $PARM
     information. 
  
 -----------------------------------------------------------------------------
1 STRUCTURED CODE CAPABILITIES OF COMPC 
  
  COMPC contains a powerful preprocessing facility for converting structured
  code into compilable Fortran.  The structured code may be mixed in any
  fashion with non-structured code so long as logical consistency is maintained.
  Syntax for structured code: 
  
  1.  $STRUC directive
  
      Structured processing is invoked with the $STRUC directive in much the
      same way as $EMA or $FILES directives.  The $STRUC directive turns on 
      the preprocessing capability in COMPC.  The form of the directive is
      $STRUC or $STRUC(nn); it must begin in column 1 and appear with $EMA
      and $FILES directives (in any order) as the first non-comment statement(s)
      following the FTN4 or FTN4X compiler control statement.  nn is the first
      label to used by the processor; if nn is absent, processor-generated
      labels start at 32000.  The $STRUC directive remains in effect for
      every module until another compiler control statement is encountered. 
  
  2.  IF$-THEN-ELSE 
  
      IF$ (logical expression)
        THEN BEGIN blockname
          statements
          ENDT blockname
        ELSE BEGIN blockname
          statements
          ENDE blockname
  
      or
  
      IF$ (logical expression)
        THEN statement
        ELSE statement
  
      The two styles may be mixed in a single IF$-THEN-ELSE, i. e., THEN/ELSE 
      may lead to either a block of code or a simple FORTRAN statement.  ELSE 
      is optional.  If the logical expression is true, the THEN block or
      statement is executed.  If the expression is false, the ELSE block or 
      statement, if it is present, is executed.  In nested IF$-THEN-ELSE
      constructions, an ELSE is assumed to be associated with the immediately 
      preceding IF$-THEN.  A line containing only ELSE may be used to maintain
      proper nesting. 
  
  3.  WHILE-DO
  
      WHILE (logical expression)
        DO BEGIN blockname
          statements
          ENDW blockname
  
      or
  
      WHILE (logical expression)
        DO statement
  
      The block of code or single statement is executed in a loop as long as
      the logical expression is true.  If the expression is initially false,
      no code is executed.
  
  4.  FOR$-DO 
  
      FOR$ i=n1,n2,n3 
        DO BEGIN blockname
          statements
          ENDF blockname
  
      or
  
      FOR$ i=n1,n2,n3 
        DO statement
  
      The block of code or single statement is executed with index i starting 
      at n1 incremented by n3 until n2 is reached.  This construction is
      translated as a DO loop.
  
  5.  CASE
  
      CASE (integer expression or variable) 
        (value1,value2) BEGIN blockname 
          statements
          ENDC blockname
        (value5,value6) BEGIN blockname 
          statements
          ENDC blockname
        (OTHERWISE) BEGIN blockname 
          statements
          ENDC blockname
  
      or
  
      CASE (integer expression or variable) 
        (value1,value2) statement 
        (value5,value6) statement 
        (OTHERWISE) statement 
  
      If the integer expression or variable is equal to value1 or value2, the 
      first block of code or statement is executed.  Similarly, if value5 or
      value6 matches, the second block or statement is executed.  Blocks and
      statements may be mixed in a single CASE construction.  If no state list
      value matches the CASE expression or variable, the OTHERWISE block or 
      statement is executed.  OTHERWISE is optional - if it does not appear 
      and no state list value matches the CASE expression, no code is executed. 
      A state list may have up to 4 values (at present).  There is no limit to
      the number of state lists and blocks or statements.  Only the first 
      block or statement whose state list matches is executed.
  
  6.  DONE
  
      The simple statement DONE transfers to the end of the program or
      subprogram. 
  
  Notes:
  
  a.  If an error in preprocessing is detected, the resolved file is not sent 
      to the compiler.
  
  b.  Up to 8 characters are saved in blocknames including blanks.  If the
      beginning and end of a block do not have the same name, an error is 
      detected.  The blockname is optional. 
  
  c.  Each construction may be nested at least 6 levels deep.  Different
      constructions are independently nested. 
  
  d.  The single statement allowed in all constructions may not be a
      structured instruction except DONE. 
  
  e.  Structured instructions may not have FORTRAN labels.
  
  f.  A block of code delimited by BEGIN and ENDx must have at least one
      executable statement. 
  
  g.  Structured subprograms should not use RETURN.  A labeled RETURN at the
      end of the subprogram is generated by the preprocessor. 
  
  h.  The O option produces a resolved FORTRAN source file =FFFFF::LU for the 
      input source file &FFFFF::LU.  The entire file must be processed. 
  
  
 -----------------------------------------------------------------------------
