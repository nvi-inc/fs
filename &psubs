FTN4,X
      SUBROUTINE CNVRT(IMODE,AIN1,AIN2,OUT1,OUT2, 
     + IYR, IDOY, IHR, IMN, ISC,IHSC,ALAT,WLONG), 
     +                 Convert coordinates C#840530:01:09#
C 
C  INPUT: 
C 
C     IMODE - specifies input and output coordinate systems 
C              IMODE     Input      Output
C              -----     -----      ------
C                1       RA/DEC      AZ/EL
C                2       AZ/EL       RA/DEC 
C                3       RA/DEC      X/Y NS 
C                4       X/Y NS      AZ/EL
C                5       AZ/EL       X/Y NS 
C                6       X/Y NS      HA/DEC 
C                7       X/Y NS      RA/DEC 
C                8       HA/DEC      X/Y NS 
C                9       HA/DEC      AZ/EL
C               10       AZ/EL       HA/DEC 
C 
C     AIN1 - first input coordinate 
C     AIN2 - second input coordinate
C 
C  OUTPUT:
C 
C     OUT1 - first output coordinate
C     OUT2 - second output coordinate 
C 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      DOUBLE PRECISION SIDT,SIDER,HAD,TLST
      DIMENSION IT(7) 
C 
      DATA PI/3.141592653589D0/ 
D     DATA LU/15/ 
C 
      DASIN(X) = DATN2(X,DSQRT(DABS(1.-X*X))) 
      DACOS(X)=DATN2(DSQRT(DABS(1.-X*X)),X) 
C 
      SLAT = DSIN(ALAT) 
      CLAT = DCOS(ALAT) 
      SIN1 = DSIN(AIN1) 
      SIN2 = DSIN(AIN2) 
      CIN1 = DCOS(AIN1) 
      CIN2 = DCOS(AIN2) 
      SIDT=SIDER(IYR,IDOY,IHR,IMN,ISC,IHSC) 
      TLST=SIDT-WLONG 
D     WRITE(LU,1) TLST,SIDT,WLON
D1    FORMAT("TLST,SIDT,WLON = "2(F10.6", "),F10.6) 
      HAD = TLST-AIN1 
      IF(HAD.GT.0.D0) HAD=DMOD(HAD,2.D0*PI) 
      IF(HAD.LT.0.D0) HAD=DMOD(HAD,-2.D0*PI)
      IF(HAD.LT.-PI) HAD=HAD+2.*PI
      IF(HAD.GT.PI) HAD=HAD-2.*PI 
      HA=HAD
D     WRITE(LU,3) HA
D3    FORMAT("HA= "F10.6) 
      SHA=DSIN(HA)  
      CHA=DCOS(HA)  
C 
      GO TO (110,130,150,170,190,210,230,250,270,290) IMODE 
C 
C  1. RA/DEC --> AZ/EL
C 
110   OUT2=DASIN(SLAT*SIN2+CLAT*CIN2*CHA) 
      OUT1=DATN2(-CIN2*SHA,CLAT*SIN2-SLAT*CIN2*CHA) 
      IF(OUT1.LT.0.) OUT1=OUT1+2.*PI
      GO TO 900 
C 
C  2. AZ/EL --> RA/DEC
C 
130   HA=-DATN2(CIN2*SIN1,SIN2*CLAT-CIN2*CIN1*SLAT) 
D     WRITE(LU,2)HA 
D2    FORMAT("HA = "F10.6)
      OUT1=TLST-HA
      IF(OUT1.LT.0.) OUT1=OUT1+2.*PI
      IF(OUT1.GT.2.*PI) OUT1=OUT1-2.*PI 
      OUT2=DASIN(CIN2*CIN1*CLAT+SIN2*SLAT)  
      GO TO 900 
C 
C  3. RA/DEC --> X/Y NS 
C 
150   OUT1=DATN2(-CIN2*SHA,SLAT*SIN2+CLAT*CIN2*CHA) 
      OUT2=DASIN(CLAT*SIN2-SLAT*CIN2*CHA) 
      GO TO 900 
C 
C  4. X/Y NS --> AZ/EL
C 
170   OUT1=DATN2(SIN1*CIN2,SIN2)
      IF(OUT1.LT.0) OUT1=OUT1+2.*PI 
      OUT2=DASIN(CIN2*CIN1) 
      GO TO 900 
C 
C  5. AZ/EL  --> XY NS
C 
190   CONTINUE
      OUT1=DATN2(CIN2*SIN1,SIN2)
      OUT2=DASIN(CIN2*CIN1) 
      GO TO 900 
C 
C  6. X/Y  NS --> HA/DEC
C 
210   CONTINUE
      OUT1=-DATN2(CIN2*SIN1,CIN2*CIN1*CLAT-SIN2*SLAT) 
      OUT2=DASIN(SIN2*CLAT+CIN2*CIN1*SLAT)  
      GO TO 900 
C 
C   7. X/Y NS --> RA/DEC  
C 
230   CONTINUE
      HA=-DATN2(CIN2*SIN1,CIN2*CIN1*CLAT-SIN2*SLAT) 
      OUT1=TLST-HA  
      IF(OUT1.LT.0.0) OUT1=OUT1+2.0*PI
      IF(OUT1.GT.2.0*PI) OUT1=OUT1-2.0*PI 
      OUT2=DASIN(SIN2*CLAT+CIN2*CIN1*SLAT)  
      GO TO 900 
C 
C  8. HA/DEC --> X/Y NS 
C 
250   OUT1=DATN2(-CIN2*SIN1,SLAT*SIN2+CLAT*CIN2*CIN1) 
      OUT2=DASIN(CLAT*SIN2-SLAT*CIN2*CIN1)  
      GO TO 900 
C 
C  9. HA/DEC --> AZ/EL
C 
270   OUT2=DASIN(SLAT*SIN2+CLAT*CIN2*CIN1)  
      OUT1=DATN2(-CIN2*SIN1,CLAT*SIN2-SLAT*CIN2*CIN1) 
      IF(OUT1.LT.0.) OUT1=OUT1+2.*PI
      GO TO 900 
C 
C 10. AZ/EL --> HA/DEC
C 
290   OUT1=-DATN2(CIN2*SIN1,SIN2*CLAT-CIN2*CIN1*SLAT) 
D     WRITE(LU,2)HA 
      IF(OUT1.LT.-PI) OUT1=OUT1+2.*PI 
      IF(OUT1.GT.PI) OUT1=OUT1-2.*PI
      OUT2=DASIN(CIN2*CIN1*CLAT+SIN2*SLAT)  
      GO TO 900 
C 
900   CONTINUE
      RETURN
      END 
      SE RE ON
      SUBROUTINE GMODL(LUT,IDCB,INAME,ISC,ICR,PCOF,MPAR,JBUF,IL,IERR, 
     +                 IDCBS) 
      DOUBLE PRECISION DAS2B
      DIMENSION IDCB(IDCBS),PCOF(MPAR),JBUF(IL) 
C 
      QDATA LOPER $ERROR      OPENING FILE       :      :   $ 
      QDATA LRERR $ERROR      READING RECORD   $
      QDATA LPEOF $PREMATURE END OF FILE BEFORE READING RECORD   $
      QDATA LFERR $FIELD    IN RECORD     NOT FOUND$
      QDATA LDERR $FIELD    IN RECORD     UNDECODABLE$
C 
C   OPEN THE DATA FILE
C 
      CALL OPEN(IDCB,IERR,INAME,0,ISC,ICR,IDCBS)
      IF(IERR.LT.0) GO TO 8000
C 
      IREC=0
50    CONTINUE
      CALL READF(IDCB,IERR,JBUF,IL,LEN) 
      IF(IERR.NE.0) GO TO 8005
      IF(LEN.EQ.-1) GO TO 8010
C 
      IF(ICHCM(JBUF,1,2H**,1,1).EQ.0) GO TO 50
      IREC=IREC+1 
      ILC=LEN*2 
      IFC=1 
D     CALL EXEC(2,LUT,JBUF,LEN) 
C 
C GET PCOFs 
C 
100   CONTINUE
      DO 150 I=(IREC-1)*5+1,IREC*5
      CALL GTFLD(JBUF,IFC,ILC,IC1,IC2)
      IF(IC1.LE.0) GO TO 8015 
C 
      PCOF(I) = SNGL(DAS2B(JBUF,IC1,IC2-IC1+1,IERR))
      IF(IERR.NE.0) GO TO 8020
150   CONTINUE
      IF(I.GE.MPAR) GO TO 9000
      GO TO 50
C 
C  OPEN ERROR 
C 
8000  CONTINUE
      INC=IB2AS(IERR,LOPER(2),7,4)
      INC=ICHMV(LOPER(2),25,INAME,1,6)
      INC=IB2AS(ISC,LOPER(2),32,6)
      INC=IB2AS(ICR,LOPER(2),39,3)
      CALL EXEC(2,LUT,LOPER(2),-LOPER(1)) 
      GO TO 9000
C 
C  READ ERROR 
C 
8005  CONTINUE
      INC=IB2AS(IERR,LRERR(2),7,4)
      INC=IB2AS(IREC+1,LRERR(2),27,2) 
      CALL EXEC(2,LUT,LRERR(2),-LRERR(1)) 
      GO TO 9000
C 
C PREMATURE END OF FILE 
C 
8010  CONTINUE
      INC=IB2AS(IREC+1,LPEOF(2),45,2) 
      CALL EXEC(2,LUT,LPEOF(2),-LPEOF(1)) 
      GO TO 9000
C 
C FIELD LOCATION ERROR
C 
8015  CONTINUE
      INC=IB2AS(I,LFERR(2),7,2) 
      INC=IB2AS(IREC,LFERR(2),20,2) 
      CALL EXEC(2,LUT,LFERR(2),-LFERR(1)) 
      IERR=-998 
      GO TO 9000
C 
C DECODE ERROR
C 
8020  CONTINUE
      INC=IB2AS(I,LDERR(2),7,2) 
      INC=IB2AS(IREC,LDERR(2),20,2) 
      CALL EXEC(2,LUT,LDERR(2),-LDERR(1)) 
      GO TO 9000
C 
9000  CONTINUE
      CALL CLOSE(IDCB)
      RETURN
      END 
      FUNCTION FLT(IWHICH,X,Y,P)
C 
C     COMPUTES THE FUNCTION AND DERIVATIVES FOR Y COORDINATE. 
C     4 PARAMETER MODLT FOR IWHICH = 0
C     DERIVATIVE WITH RESPECT TO THE (IWHICH)th PARAMETER OTHERWISE 
C               WEH 830501
C 
      DIMENSION P(15) 
      DATA C/.01745329/ 
C 
      COSX=COS(X*C) 
      COSY=COS(Y*C) 
      SINX=SIN(X*C) 
      SINY=SIN(Y*C) 
C 
      GO TO (10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160)
     +       IWHICH+1 
C 
10    F= P(7)-P(8)*COSX*SINY+P(5)*COSX+P(6)*SINX
      GO TO 200 
20    F= 0. 
      GO TO 200 
30    F= 0. 
      GO TO 200 
40    F= 0. 
      GO TO 200 
50    F= 0. 
      GO TO 200 
60    F=  COSX
      GO TO 200 
70    F=  SINX
      GO TO 200 
80    F= 1.0
      GO TO 200 
90    F= -COSX*SINY 
      GO TO 200 
100   F= 0. 
      GO TO 200 
110   F= 0. 
      GO TO 200 
120   F= 0. 
      GO TO 200 
130   F= 0. 
      GO TO 200 
140   F= 0. 
      GO TO 200 
150   F= 0. 
      GO TO 200 
160   F= 0. 
      GO TO 200 
C 
200   FLT=F 
      END 
      FUNCTION FLN(IWHICH,X,Y,P)
C 
C     FITTING FUNCTION FOR X COORDINATE INCLUDING DERIVATIVES 
C     6-PARAMETER FUCNTION FOR IWHICH = 0 
C     DERIVATIVE WITH RESPECT TO THE (IWHICH)th PARAMETER OTHERWISE 
C     COULD HANDLE UP TO 15 PARAMETERS
C                  WEH 830501 
C 
      DIMENSION P(15) 
      DATA C/.01745329/ 
C 
      COSX=COS(X*C) 
      COSY=COS(Y*C) 
      SINX=SIN(X*C) 
      SINY=SIN(Y*C) 
C 
      GO TO (10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160)
     +       IWHICH+1 
C 
10    F=P(1)-(P(2)*SINX-P(3)*SINY+P(4)-P(5)*SINX*SINY+P(6)*SINY*COSX) 
     A        /COSY 
      GO TO 200 
20    F=1.
      GO TO 200 
30    F=-SINX/COSY
      GO TO 200 
40    F= SINY/COSY
      GO TO 200 
50    F=-1.0/COSY 
      GO TO 200 
60    F= (SINX*SINY)/COSY 
      GO TO 200 
70    F=-(COSX*SINY)/COSY 
      GO TO 200 
80    F= 0. 
      GO TO 200 
90    F= 0. 
      GO TO 200 
100   F=0.
      GO TO 200 
110   F=0.
      GO TO 200 
120   F= 0. 
      GO TO 200 
130   F= 0. 
      GO TO 200 
140   F= 0. 
      GO TO 200 
150   F= 0. 
      GO TO 200 
160   F= 0. 
      GO TO 200 
C 
200   FLN=F 
      END 
C@IR2AS 
      FUNCTION IR2AS(VALUE,IAS,IFC,NCHTOT,
     .     NCFRAC),CONVERT REAL BINARY TO ASCII C#840523:20:35# 
C 
C     This function converts a real number to ASCII format
C 
C 
C  INPUT: 
C 
C     VALUE - real value to be converted
      DIMENSION IAS(1)
C      - string array for ASCII value 
C     IFC - first character to use in IAS 
C     NCHTOT - maximum number of characters in field
C              >0 for left-justify, <0 for right-justify
C     NCFRAC - number of characters in fraction, i.e. following 
C              decimal point.  >0 for leading spaces, <0 leading zeros
C     **NOTE: NCHTOT and NCFRAC are similar in function to the two
C     digits n and m used in the FORTRAN format Fn.m, respectively. 
C 
C  OUTPUT:
C 
C     IR2AS - number of characters used in formatting value 
C 
C 
C  SUBROUTINES: 
C 
C     Character manipulation ICHMV, IB2AS 
C 
C 
C  LOCAL: 
C 
      DOUBLE PRECISION VAL
C     VAL - absolute value of VALUE 
      DOUBLE PRECISION VALINT 
C     VALINT - integer part, as number is being built up
C     IDIGIT - current digit being added to number
C     NDIG - set to 1 once leading zeros are passed over
C     IC - current character in output string 
C     IDEC - number of characters following decimal point 
C     NCI - number of characters requested for integer part 
C     IX - number of spaces pre-empted by "-" or "."
C 
C 
C     1. First initialize the counters and indices. 
C 
      NCH = IABS(NCHTOT)
C                   The total number of characters we can use 
      NCFR = IABS(NCFRAC) 
C                   The number of characters in the fractional part 
      LLEAD = 2H
      IF (NCFRAC.LT.0) LLEAD = 2H00 
C                   Establish the character for leading blanks or zeros 
      VAL = ABS(VALUE)+0.5*0.1**NCFR
C                   The value to be converted 
      VALINT = 0.0D0
C                   The integer part of the number so far 
      IX = 1
C                   We expect to exclude one space for a decimal point
      IF (VALUE.LT.0.0) IX = 2
C                   We might have a sign to include,
C                   so need to pre-empt another space 
C     IF (NCFR.EQ.0) IX=IX-1
C                   Maybe no decimal point is wanted at all 
C     We can't handle the no-decimal point case easily, so skip it
      NCI = NCH-NCFR-IX 
C                   So, the number of characters in the INTEGER 
C                   part of the number is the total less the number 
C                   in the fraction and the number for . and/or - 
      IF (NCI.EQ.0) GOTO 300
C                   If we won't have any room for the integer 
C                   part of the number, go fill with $$ 
      IC = IFC
C                   Start character counter where requested 
      IF (VALUE.LT.0.0.AND.NCFRAC.LT.0) 
     +  IC = ICHMV(IAS,IC,2H- ,1,1) 
C                   Put in minus sign first if necessary
      NDIG = 0
C                   We have no digits processed yet 
      IDEC = 0
C                   There are no characters after the . yet 
C 
C 
C     2. Main loop over max number of characters desired. 
C     Do not fill in leading zeros. 
C 
      I=1 
C                   The digit counter for exponentiation
200   IDIGIT = VAL/10.0D0**(NCI-I) - VALINT   
C200   IDIGIT = VAL*10.0**(I-NCI) - VALINT  
      IF(IDIGIT.LT.0) IDIGIT=VAL/10.0D0**(NCI-1)-VALINT+.5
C     IF(IDIGIT.LT.0.OR.IDIGIT.GT.9) IDIGIT=VAL*10.**(I-NCI)-VALINT 
      IF (IDIGIT.LT.0.OR.IDIGIT.GT.9) GOTO 300
C                   Get the Ith digit in the number 
      IF (IDIGIT.NE.0.OR.NDIG.GT.0.OR.NCI.EQ.I) GOTO 202
C                   Go to put in this digit if
C                   1) the digit is non-zero
C                   2) this is an embedded zero 
C                   3) this is the zero before the decimal point
      IF (NCHTOT.LT.0) IC = ICHMV(IAS,IC,LLEAD,1,1) 
C                   Move in leading spaces or zeros for RIGHT-justify 
      GOTO 210
202   CONTINUE
      IF(NDIG.EQ.0.AND.VALUE.LT.0.0.AND.NCFRAC.GE.0)
     +  IC =  ICHMV(IAS,IC,2H- ,1,1)  
      IC = IC + IB2AS(IDIGIT,IAS,IC,1)
C                   Convert this digit.  We should get back a $ if
C                   the digit is too large. 
      NDIG = 1
C                   Set the flag, we've started adding digits 
      IF (IDEC.GT.0) IDEC=IDEC+1
C                   Increment count of digits past decimal point
      IF (NCI.NE.I) GOTO 201
      IC = ICHMV(IAS,IC,2H. ,1,1) 
      IDEC = 1
C                   If we're at the 10**0 point, add "."
201   VALINT = (VALINT+IDIGIT)*10.0D0 
210   I = I + 1 
      IF (IC.LT.IFC+NCH.AND.IDEC-1.LT.NCFR) GOTO 200
C 
      IR2AS = IC-IFC
      RETURN
C 
C 
C     3. Clearly, the number will not fit into the field we 
C     were given.  Fill it up with $$$$$ and finish.
C 
300   CALL IFILL(IAS,IFC,NCH,2H$$)
      IR2AS = NCH 
      RETURN
C 
      END 
      DOUBLE PRECISION FUNCTION REFR(EL)
      DOUBLE PRECISION EL 
C 
      DIMENSION P(5)
C 
      DATA A/40./,B/2.7/,C/4./,D/42.5/,E/0.4/,F/2.64/,G/.57295787E-4/ 
      DATA P/.458675E1,.322009E0,.103452E-1,.274777E-3,.157115E-5/
      DATA TEMPC/15./,HUMI/50./,PRES/1000./,CVT/1.33289/
C 
C  Compute SN (surface refractivity)
C 
      RHUMI = (100.-HUMI)*.9
      DEWPT = TEMPC-RHUMI*(.136667+RHUMI*1.33333E-3+TEMPC*1.5E-3) 
      X = DEWPT 
      PP = P(1) 
      DO 20 I=2,5 
        PP=PP+X*P(I)
        X=X*DEWPT 
20    CONTINUE
      TEMPK=TEMPC+273.
      SN=77.6*(PRES+(4810.*CVT*PP)/TEMPK)/TEMPK 
C 
      APHI = A/(EL+B)**C
      ANG = .0174532905*(90.-EL)
      DELE = -D/(EL+E)**F 
      BPHI = G*(SIN(ANG)/COS(ANG)+DELE) 
      IF(EL.EQ.0) BPHI = G*(1.+DELE)
      REFR = BPHI*SN-APHI 
C 
      RETURN
      END 
      DOUBLE PRECISION FUNCTION TDPS(IYR,INDOY,IHR,IMN,ISC,IHSC)
C 
C CALCULATE GREENWICH SIDERAL TIME AS TSRT IN THE TDPS DOES 
C 
C SEEE WEH II OR TOM HORNBY DBA SYSTEMS 
C 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
      REAL WLON 
      DATA PI/3.141592653589793D0/
C 
      A1=100.4989167D0
      A2=36000.7695D0 
      A3=38708.0D-8 
      A4=.2506844773D0
C 
      TIM=DBLE(FLOAT(IHSC))*.01D0 + DBLE(FLOAT(ISC))
     +   +DBLE(FLOAT(IMN))*60.D0 + DBLE(FLOAT(IHR))*3600.D0 
     +   +DBLE(FLOAT(INDOY-1))*86400.0D0
C 
      IDOY=IDINT(TIM/86400.0D0) 
      VM=DMOD(TIM,86400.0D0)
      VMIN=VM/60.0D0
      IX=IYR-73 
      X=(IX*365+(IX/4)+IDOY)/36525.0D0
      TDPS=A3*X*X+A2*X+A1+VMIN*A4 
      TDPS=TDPS*PI/180.0D0
      TDPS=DMOD(TDPS,2.0D0*PI)
      IF(TDPS.LT.0) TDPS=TDPS+2.0D0*PI
      RETURN
      END 
      DOUBLE PRECISION FUNCTION SIDER(IYR,IDOY,IHR,IMN,ISC,IHSC)
C 
C CALCULATE APPARENT GREENWICH SIDERAL TIME 
C 
C ACCURATE TO APPROXIMATELY .5 SECONDS OF TIME  
C 
C WEH 
C 
      DOUBLE PRECISION EQOFEQ,SIDTI,FRACT,UT,PI 
      DATA PI/3.141592653589793D0/
C 
      UT =DBLE(FLOAT(IHSC))*.01D0 + DBLE(FLOAT(ISC))
     +   +DBLE(FLOAT(IMN))*60.D0 + DBLE(FLOAT(IHR))*3600.D0 
      MJD=JULDA(1,IDOY,IYR) 
      CALL SIDTM(MJD,SIDER,FRACT) 
      CALL EQUN(IYR,IDOY,EQOFEQ)
      SIDER=SIDER+FRACT*UT+EQOFEQ 
      SIDER=DMOD(SIDER,2.0D0*PI)
      IF(SIDER.LT.0.0D0) SIDER=SIDER+2.0D0*PI 
      END 
      SUBROUTINE EQUN(NYRF,NDAY,EQOFEQ) 
C 
C   EQUATION OF EQUINOXES TO 10% FROM 
C     J.BALL'S MOVE 
C 
C     NYRF = YEAR SINCE 1900
C     NDAY = DAY OF YEAR
C     EQOFEQ IS RETURNED EQUATION OF EQUINOXES
C 
      DOUBLE PRECISION T,AL,A,T2,T3,
     .AOMEGA,ARG,DLONG,DOBLQ,EQOFEQ 
C 
      AL=NDAY 
      A=NYRF
      T=(A+AL/365.2421988D0)/100.D0 
C 
C     NUTATION
C 
      AOMEGA=259.183275D0-1934.142D0*T
      ARG=AOMEGA*0.0174532925D0 
      DLONG=-8.3597D-5*DSIN(ARG)
      DOBLQ=4.4678D-5*DCOS(ARG) 
C     EQOFEQ=DLONG*DCOS(DOBLQ)
      EQOFEQ=DLONG*0.917450512D0
      RETURN
      END 
