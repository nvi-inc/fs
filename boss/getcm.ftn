FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      SUBROUTINE GETCM(ISTKSK,ISTKOP,LSTKSK,LSTKOP,IDCBP1,IDCBP2,IDCBSK,
     .            KBLKSK,KBLKOP,KHALT,KBREAK,ICLOPR,ICLOP2,
     .            IBLEN,IBUF,NCHAR,LSOR,LPROCS,LPROCO,LPPARM,NCPARM,
     .            LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,NPROC2,ITMLOG,
     .            MAXPR1,MAXPR2,IERR,ICURLN,ILSTLN)    !  <910324.0643>
C
C     GETCM - gets the next command for BOSS to process
C
C     DATE   WHO CHANGES
C     810907 NRV Added procedure arrays
C     840320 MWH Added support for specified # of schedule lines to execute
C     880511 LAR Fixed it so immediate execution really works
C
C  INPUT VARIABLES:
      DIMENSION ISTKSK(1),ISTKOP(1),LSTKSK(1),LSTKOP(1)
C     Stacks for procedure names and parameters
      DIMENSION IDCBP1(1),IDCBP2(1),IDCBSK(1)
C     DCB'S for procedure files, schedule
      DIMENSION LNAMES(10,1),LPROC1(10,1),LPROC2(10,1)
C     Arrays with command names
      LOGICAL KBLKSK,KBLKOP
C     True when schedule/operator stream is blocked
      LOGICAL KHALT
C     True when HALT was issued to block schedule
      LOGICAL KBREAK
C     True when operator asks for a procedure to be ended early
C
C  OUTPUT VARIABLES:
C
      DIMENSION IBUF(1)
C     Buffer with new command
C     IBLEN  - max length of IBUF in words
C     NCHAR  - number of characters in command in IBUF
C     LSOR   - source of command - schedule, operator, procedure
      DIMENSION LPPARM(1)
C     Parameters string
C     NCPARM - number of chars in LPPARM
C     IERR  - error return, non-zero FMP error
C
C  LOCAL VARIABLES:
C
      INTEGER*4 IREC,IOFF,ICURLN,ILSTLN
      INTEGER*2 FBLNK
      DIMENSION IREG(2)
      EQUIVALENCE (IREG(1),REG)
C
C     1. Initialize error return and number of characters.
C
      NCHAR = 0
      IERR = 0
C
C     2. First sift through all of the operator class stack to see if
C     there are any "immediate execution" commands to be processed
C     or any time-scheduling commands.
C     If so, then that's our highest priority.
C
200   REG = EXEC(21,ICLOPR+120000B,IBUF,-IBLEN*2)
      NCHAR = IFLCH(IBUF,MIN0(IREG(2),IBLEN*2))
      NCHAR = FBLNK(IBUF,1,NCHAR)
      call upper(ibuf,1,nchar)
      IF (IREG.LT.0) NCHAR = 0
      IF (NCHAR.EQ.0) GOTO 300
C                   When there's nothing there, that's the
C                   end of the class records
      IF (JCHAR(IBUF,1).GT.42B .OR. JCHAR(IBUF,1).LT.41B) THEN
C                   Don't bother with comments (") or wait commands (!)
        ICH = ISCNC(IBUF,1,NCHAR,75B)     !  Scan for "=" preceding name.
        IF (ICH.EQ.0) THEN
          ICH = ISCNC(IBUF,1,NCHAR,100B)
          ICH = NCHAR+1
        ENDIF
        CALL GTNAM(IBUF,1,ICH-1,LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,
     &    NPROC2,IERR,ITYPE,INDEX)
        LSOR = 2H;;
C                    Immediate-execute functions and time-scheduled
C                                      functions have priority.
        IF (ITYPE.EQ.106B .AND. IERR.EQ.0 .AND.
     &    (JCHAR(LNAMES(7,INDEX),1).EQ.52B .OR.
     &    ISCNC(IBUF,1,NCHAR,100B).NE.0)) RETURN
      ENDIF
      IERR = 0      !  Reset error flag from GTNAM, we'll discover it later
      CALL EXEC(20,0,IBUF,NCHAR,2HFS,0,ICLOP2)
C                   In this case, it's an ordinary command.  Put it into
C                   the secondary operator class for later pick-up.
      GOTO 200
C
C
C     3. First try to read something into the schedule stream.
C     If the schedule is blocked or a HALT was issued, try the
C     operator stream.
C
300   IF (.NOT.KHALT .AND. .NOT.KBLKSK) THEN
        IF (ISTKSK(2).NE.2) THEN
C                   If we have nothing in the procedure stack
C                   try to get next line in schedule file
          CALL READP(IDCBP1,IDCBP2,ISTKSK,LSTKSK,LPROC1,LPROC2,KBREAK,
     &      IBUF,IBLEN,NCHAR,LPROCS,LPPARM,NCPARM,IERR)
          IF (ISTKSK(2).NE.2 .AND. IERR.NE.-1) THEN
C                   If there's nothing left, go back to schedule file
            LSOR = 2H$:
            RETURN
          ENDIF
        ENDIF
C
        CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     &    NPROC2,IBUF,IBLEN,ISTKOP,ISTKSK)
        IF (ICURLN.LT.ILSTLN) THEN
          CALL READS(IDCBSK,IBUF,IBLEN,NCHAR,IERR)
          CALL FmpPosition(IDCBSK,IERR,IREC,IOFF)
          ICURLN = IREC
          IF(NCHAR.EQ.0) IERR = 0
          ICURLN = ICURLN-1
          LSOR = 2H::
          IF (NCHAR.EQ.0) KBLKSK = .TRUE.
          NCPARM = 0
          RETURN
        ELSE
          KHALT=.TRUE.
          ILSTLN=100000
        ENDIF
      ENDIF
C
C     4. As second choice, try to get something into the operator stream.
C     First, read from the operator-invoked procedure file.
C     Then, check the operator mail-box for a command.
C
      IF (KBLKOP) RETURN
      IF (ISTKOP(2).NE.2) THEN
C                   If there is nothing in the procedure stack, try to
C                   get something from mailbox
        CALL READP(IDCBP1,IDCBP2,ISTKOP,LSTKOP,LPROC1,LPROC2,KBREAK,
     &    IBUF,IBLEN,NCHAR,LPROCO,LPPARM,NCPARM,IERR)
C      WRITE(1,'(''BUF,ERR FROM READP= ''10A2,I5)')(IBUF(I),I=1,10),IERR
        IF (ISTKOP(2).NE.2 .AND. IERR.NE.-1) THEN
          LSOR = 2H$;
          RETURN
        ENDIF
      ENDIF
C
      CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     .NPROC1,IBUF,IBLEN,ISTKOP,ISTKSK)
      NCPARM = 0
      REG = EXEC(21,ICLOP2+120000B,IBUF,-IBLEN*2)
      NCHAR = IFLCH(IBUF,MIN0(IREG(2),IBLEN*2))
      IF (IREG.LT.0) NCHAR = 0
      LSOR = 2H;;
      RETURN
      END
