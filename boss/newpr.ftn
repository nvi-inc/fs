FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
C
      SUBROUTINE NEWPR(IDCBP1,IDCBP2,ISTACK,INDEX,
     .LPARM,NPARM,LSTACK,LPROC1,LPROC2,
     .ITMLOG,IBUF,IBLEN,IERR),NEW PROCEDURE !<870115:04:19>
C
C     NEWPR - initializes a new procedure by manipulating the stacks
C
C     DATE   WHO CHANGES
C     810907 NRV Modified for new procedure management
C     840217 MWH Modified stack structure
D     INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C  INPUT:
C
C     IDCBP1,IDCBP2 - DCBs for the two procedure files
C     ISTACK - stack of procedure information
C              (1) = total number of words available
C              (2) = last word used, if 2 then empty
C              Items are pushed onto the stack in the order:
C              - index into LPROC1,2 array (>0=1,<0=2)
C              - next line number when pushed down
C     INDEX - index into LPROC1,LPROC2 arrays
C             >0 is LPROC1, <0 is LPROC2
C     LPARM - parameter string specified with this proc
C     NPARM - number of characters in LPARM
C     LSTACK - stack of parameters
C              (1) = total number of words
C              (2) = last word used, =2 means empty
C              The parameter string is pushed first, then
C              the number of characters in it.
C     LPROC1,2 - procedure directories
C     ITMLOG - time this log file was started
C     IBUF - buffer for reading
C     IBLEN - length of IBUF
      DIMENSION ISTACK(1),LSTACK(1),LPARM(1)
      DIMENSION IDCBP1(1),IDCBP2(1),ITMLOG(1),IBUF(1)
      DIMENSION LPROC1(10,1),LPROC2(10,1)
C
C  OUTPUT:
C
C     IERR - error return.  -1 for stack error, <0 for FMP error.
C
C
C  LOCAL:
C
C     LPROCN - procedure name, for logging
C     NREC - next record number in current file, from FmpPosition
C     ITIME - holds the current system time, for comparing with ITMLOG
C     IREC,IOFF - position information for current procedure
      INTEGER*4 IREC,IOFF
      DIMENSION ITIME(6),LPROCN(6)
      INTEGER*2 FMPREADSTRING
      character*80 ibc
      dimension ib(40)
      equivalence (ib,ibc)
C
C
C  INITIALIZED:
C
C     1. Determine position information for the new procedure
C
C     WRITE(1,'(''ENTERING NEWPR'')')
      IF(INDEX.GT.0)GOTO 100
        IREC = LPROC2(8,IABS(INDEX))
        GO TO 200
100   CONTINUE
      IREC = LPROC1(8,INDEX)
C
C     2. Position to the new location in the procedure file.
C     If there are errors, or DEFINE is not on this line, then quit.
C
200   CONTINUE
C     WRITE(1,'(''INDEX,IREC= '',2I7)') INDEX,IREC
      IF (INDEX.GT.0) id = FmpSetPosition(IDCBP1,IERR,IREC,-irec)
      IF (INDEX.LT.0) id = FmpSetPosition(IDCBP2,IERR,IREC,-irec)
      IF (IERR.LT.0) GOTO 800
      IF (INDEX.GT.0) len= FmpReadString(IDCBP1,IERR,IBC)
      IF (INDEX.LT.0) len= FmpReadString(IDCBP2,IERR,IBC)
      IF (IERR.LT.0.OR.ILEN.LE.0) GOTO 800
C     WRITE(1,'(''IBC= '',A80)')IBC
      if (ibc(1:6).ne.'DEFINE') goto 800
C
C     3. Get the time field from the first line and check it against
C     the time the log was opened.
C     If the time the procedure was last logged is later than
C     the time the log file was started, then we are finished here.
C     Otherwise, drop through to the logging of this procedure.
C
300   CONTINUE
      IF (IAS2B(IB,23,2).GT.ITMLOG(6)-1900) GOTO 600
      IF (IAS2B(IB,23,2).LT.ITMLOG(6)-1900) GOTO 400
C                   First check the year
      IF (IAS2B(IB,25,3).GT.ITMLOG(5)) GOTO 600
      IF (IAS2B(IB,25,3).LT.ITMLOG(5)) GOTO 400
C                   Then check the day number
      TIMLOG = ITMLOG(4)*3600.0+ITMLOG(3)*60.0+ITMLOG(2)
      TIMPRC = IAS2B(IB,28,2)*3600.0+IAS2B(IB,30,2)*60.0+
     .         IAS2B(IB,32,2)
      IF (TIMPRC.GT.TIMLOG) GOTO 600
C                   Finally check the time of day, if the dates are equal
C
C
C     4. This procedure needs logging.  Read/log each record.
C     First pull off the procedure name.
C
400   IDUMMY = ICHMV(LPROCN,1,IB,9,12)
410   IF (INDEX.GT.0) len= FmpReadString(IDCBP1,IERR,IBC)
      IF (INDEX.LT.0) len= FmpReadString(IDCBP2,IERR,IBC)
      if (len.eq.0.or.ibc(1:6).eq.'DEFINE'.or.ibc(1:6).eq.'ENDDEF')
     .   goto 500
C     WRITE(1,'(''IERR,IBC= '',I5,1X,A80)')IERR,IBC
      IF (IERR.LT.0.OR.ILEN.LE.0) GOTO 800
      ILEN = IFLCH(IB,80)
      CALL LOGIT(IB,ILEN,2H&&,LPROCN)
      GOTO 410
C
C
C     5. Finally, update the first line of the procedure with
C     the current time, to indicate the last time we logged it.
C
500   IF (INDEX.GT.0) id = FmpSetPosition(IDCBP1,IERR,IREC,-irec)
      IF (INDEX.LT.0) id = FmpSetPosition(IDCBP2,IERR,IREC,-irec)
      IF (IERR.LT.0) GOTO 800
      IF (INDEX.GT.0) len = FmpReadString(IDCBP1,IERR,IBC)
      IF (INDEX.LT.0) len = FmpReadString(IDCBP2,IERR,IBC)
      CALL EXEC(11,ITIME,ITIME(6))
      IDUMMY = IB2AS(ITIME(6)-1900,IB,23,2)
      IDUMMY = IB2AS(ITIME(5),IB,25,40000B+400B*3+3)
      IDUMMY = IB2AS(ITIME(4),IB,28,40000B+400B*3+2)
      IDUMMY = IB2AS(ITIME(3),IB,30,40000B+400B*3+2)
      IDUMMY = IB2AS(ITIME(2),IB,32,40000B+400B*3+2)
      ibc(34:34) = 'X'
C                   Pad with character to fill in last byte
      IF (INDEX.GT.0) id = FmpSetPosition(IDCBP1,IERR,irec,-irec)
      IF (INDEX.LT.0) id = FmpSetPosition(IDCBP2,IERR,irec,-irec)
C     WRITE(1,'(''REWRITING 1ST LINE'')')
      IF (INDEX.GT.0) id = FmpWriteString(IDCBP1,IERR,IBC(:LEN))
      IF (INDEX.LT.0) id = FmpWriteString(IDCBP2,IERR,IBC(:LEN))
      IF (INDEX.GT.0) id = FmpPost(IDCBP1,IERR)
      IF (INDEX.LT.0) id = FmpPost(IDCBP2,IERR)
C
C
C     6. Push location information on the stack first.  Then push the
C     new name onto the stack for retrieval by READP.
C     Push parameter string and number of character, if any onto stack.
C
600   CONTINUE
      IF(INDEX.GT.0)id = FmpPosition(IDCBP1,IERR,IREC,IOFF)
      IF(INDEX.LT.0)id = FmpPosition(IDCBP2,IERR,IREC,IOFF)
      IF(IERR.LT.0)GOTO 800
C     WRITE(1,'(''IERR,IREC FROM POSITION= '',2I7)')IERR,IREC
      IRECS = IREC
C     WRITE(1,'(''CALLING PRPUT'')')
      CALL PRPUT(ISTACK,IRECS,1,IERR)
C     WRITE(1,'(''IERR FROM PRPUT = '',I5)') IERR
      IF(IERR.NE.0)GOTO 800
      CALL PRPUT(ISTACK,INDEX,1,IERR)
C     WRITE(1,'(''IERR FROM PRPUT = '',I5)') IERR
      IF (NPARM.NE.0) CALL PRPUT(LSTACK,LPARM,(NPARM+1)/2,IERR)
C     WRITE(1,'(''IERR FROM PRPUT = '',I5)') IERR
      IF (IERR.NE.0) GOTO 800
      CALL PRPUT(LSTACK,NPARM,1,IERR)
C     WRITE(1,'(''IERR FROM PRPUT = '',I5)') IERR
      IF (IERR.NE.0) GOTO 800
C     WRITE(1,'(''JUMPING TO 900'')')
      GOTO 900
C
C
C     8. This is the abnormal error section.  There should be no
C     errors in this routine because all of the file has been checked
C     before.  So this is serious.
C
800   IF (IERR.EQ.-1) CALL LOGIT(0,0,0,1,-128,2HBO,IERR)
      IF (IERR.NE.-1) CALL LOGIT(0,0,0,1,-129,2HBO,IERR)
      ISTACK(2) = 2
      LSTACK(2) = 2
C
C
900   CONTINUE
C     WRITE(1,'(''RETURNING FROM NEWPR'')')
      RETURN
      END
