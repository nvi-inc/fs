FTN4
C@MATCN 
C 
      PROGRAM MATCN(3),MAT CONTROLLER C#890502:19:18# 
C 
C   MATCN controls the I/O to the Microprocessor ASCII Transceiver
C 
C  MODIFICATIONS: 
C 
C  DATE   WHO CHANGES 
C  811012 NRV REMOVED SOME WVR-SPECIFIC CODE, ALL REFERENCES TO LUWVR 
C 
C     INPUT VARIABLES: (RMPAR)
C 
C        IP1    - class number of input buffer
C        IP2    - number of records in class
C 
C     Buffer from class I/O contains following: 
C     IBUF(1) = mode, must be between MINMOD and MAXMOD 
C                   -8 - get ; strobe data
C                   -7 - get . strobe data
C                   -6 - get - strobe data
C                   -5 - get + strobe data
C                   -4 - get ) strobe data
C                   -3 - get ( strobe data
C                   -2 - get % strobe data
C                   -1 - get ! strobe data
C                    0 - send data and update 
C                    1 - send data, verify, and update
C                    2 - send pending data
C                    3 - send pending data and verify 
C                    4 - update pending data
C                    5 - send contents of buffer with no modifications
C                    6 - issue "test/reset" (escape char.)
C                    7 - test alarm, reset alarm
C                    8 - send direct, like mode 5, but use address
C     IBUF(2) = device mnemonic 
C     IBUF(3 to end) = data, if mode is 0,1,2,3,4,5 
C 
C     OUTPUT VARIABLES:   (RMPAR) 
C 
C        IP1    - class number of response
C        IP2    - number of records in the class
C        IP3    - error return
C                 +2 - non-acknowledge (i.e. alarm is ON) 
C                 +1 - acknowledge
C                  0 - no response
C                 -1 - trouble with class buffer
C                 -2 - illegal mode 
C                 -3 - unrecognized device
C                 -4 - device time-out on response
C                 -5 - improper response (wrong number of chars)
C                 -6 - verify error 
C        IP4    - who we are "MA" 
C        IP5    - not used
C 
C     Buffer returned to caller contains response, if any, to 
C     I/O request.
C 
C   COMMON BLOCKS USED
C 
      INCLUDE #FSCOM::FS
C 
C   SUBROUTINE INTERFACE: 
C 
C     CALLED SUBROUTINES: IAT, DATAT
C 
C   LOCAL VARIABLES 
C 
      DIMENSION IP(5) 
C               - RMPAR 
C        IMODE  - mode for transmission/reception 
C        MAXMOD,MINMOD,MAXDEV 
C               - maximum, minimum mode numbers allowed 
C               - max devices 
C        NCHAR  - # chars in class buffer we read 
C        NCH2   - # chars in buffer 2 
C        ICLASS - class # we read 
C        ICLASR - class # we respond with 
C        NCLREC - # class records 
C        ICLREC - counter for outer loop over class records 
      DIMENSION IREG(2) 
C               - registers from EXEC 
      DIMENSION IBUF(20),IBUF2(80)
C               - buffers for input, output 
C        ILEN,ILEN2   - length of above buffers 
      DIMENSION LSTROB(8) 
C              - strobe characters for modes < 0, requesting data 
      LOGICAL KINI
C               - TRUE once we have initialized 
C        NDEV   - # devices in module table 
      DIMENSION MODTBL(2,25)
C               - module table, word 1 = mnemonic, word 2 = hex address 
      DIMENSION LALARM(10)
C               - alarm message **NOTE** this should remain at a
C                 max of 20 characters for longest message from MATCN 
      DIMENSION LWVR(2) 
C               - the address of the WVR
C     IWVR - the index of the WVR in MODTBL 
      LOGICAL KWVR
C               - true if this message is addressed to the WVR
      LOGICAL KTP 
C               - true if this message is addressed to the TAPE drive 
      EQUIVALENCE (REG,IREG(1)) 
      DIMENSION IBAUD(7),IBINDX(7)
C      - list of legal baud rates and corresponding indices 
C        for DVF00 control
C 
C   INITIALIZED VARIABLES 
C 
      DATA KINI/.FALSE./
      DATA MINMOD/-8/, MAXMOD/8/,  MAXDEV/25/ 
      DATA ILEN/40/,ILEN2/160/  
      DATA LSTROB/2H!>,2H%>,2H(>,2H)>,2H+>,2H->,2H.>,2H;>/
      DATA LALARM/2H  ,2H*A,2HLA,2HRM,2H* ,2H (,2H# ,2H ),3407B/
      DATA NALARM/18/ 
      DATA LWVR/2H# ,2H  /
      DATA IBAUD/110,300,600,1200,2400,4800,9600/ 
      DATA IBINDX/3,6,7,9,11,13,15/ 
C 
C 
C 
C     1. First get parameters and initialize if necessary.
C 
      CALL RMPAR(IP)
1     ICLASS = IP(1)
      NCLREC = IP(2)
      ICLASR = 0
      NCLRER = 0
      IERR = 0
      IF (ICLASS.NE.0) GOTO 100 
      IERR = -1 
      GOTO 1090 
C 
100   IF (KINI) GOTO 200
C 
C     1.1 Initialize the MAT LU.
C 
      IF (LUMAT.LT.0) GOTO 119
C                   If we were passed a negative LU, then skip the CNs. 
      CALL EXEC(3,3000B+LUMAT)
C                   Reset the interface line
      CALL EXEC(3,2100B+LUMAT)
C                   Disable this LU as a terminal 
      CALL EXEC(3,3200B+LUMAT,16B)
C                   Set up even parity
      DO 110 I=1,7
        IF (IBMAT.EQ.IBAUD(I)) IBX=I
110     CONTINUE
      CALL EXEC(3,3300B+LUMAT,IBINDX(IBX))
C                   Set up baud rate to MAT - assume this has been
C                   checked previously by BOSS
      IF (IBMAT.EQ.110.OR.IBMAT.EQ.9600)
     .    CALL EXEC(3,3200B+LUMAT,56B)
C                   Set up for 2 stop bits if 110 or 9600 
      CALL ITO(LUMAT,150) 
C                   Set the time-out to 1.5 second
C                   This may be dynamically adjusted by IAT 
119   LUMAT = IABS(LUMAT) 
C 
C     1.2  Read in device address table.
C     Read table from class buffer
C     Recognize the "WV" module and remember its index. 
C 
      IWVR = 0
      DO 120 I=1,NCLREC 
        CALL EXEC(21,ICLASS,IBUF,-ILEN) 
        IF (I.GT.MAXDEV) GOTO 120 
        MODTBL(1,I) = IBUF(1) 
        IF (IBUF.EQ.2HWV) IWVR = I
        CALL ICHMV(MODTBL(2,I),1,IBUF,4,2)
120     CONTINUE
C 
      IF (IWVR.EQ.0) GOTO 190 
      CALL ICHMV(LWVR,2,MODTBL(2,IWVR),1,2) 
C                   Remember the WVR's address
C     IF (LUWVR.NE.0) CALL WVINI(LUWVR) 
C                   Initializa the WVR's LU if we have one
C 
190   NDEV = MIN0(MAXDEV,NCLREC)
C 
      IDEV=1
      KINI = .TRUE. 
      GOTO 1090 
C 
C 
C     2. Begin the loop over class buffer records.
C     Read in the buffer, get the mode and module code. 
C     Search the module table for a match.
C     Set up the output buffer with the hex address.
C 
200   DO 900 ICLREC = 1,NCLREC
        REG = EXEC(21,ICLASS,IBUF,-ILEN)
        IF (IERR.LT.0) GOTO 900 
C                   If we got an error earlier, skip to end of loop 
        IF (IREG(1).GT.0) GOTO 210
        IERR = -1 
        GOTO 900
C 
210     NCHAR = IREG(2) 
        IMODE = IBUF(1) 
        IF (IMODE.GE.MINMOD.AND.IMODE.LE.MAXMOD) GOTO 220 
        IERR = -2 
        GOTO 900
C 
220   IDEV = 1
      IF (IMODE.EQ.5) GOTO 500
C 
        DO 230 I=2,NDEV 
          IF (MODTBL(1,I).EQ.IBUF(2)) GOTO 221
230       CONTINUE
        IERR = -3 
        GOTO 900
221     IDEV = I
C       KWVR = MODTBL(1,IDEV).EQ.2HWV.AND.LUWVR.NE.0
        KWVR = MODTBL(1,IDEV).EQ.2HWV 
        KTP  = MODTBL(1,IDEV).EQ.2HTP 
C 
        CALL ICHMV(IBUF,1,2H# ,1,1) 
        CALL ICHMV(IBUF,2,MODTBL(2,IDEV),1,2) 
C                   The input buffer now has: #xx <data>
      IBUF2(1) = MODTBL(1,IDEV) 
C                   The output buffer now has module mnemonic 
C 
      IF (IMODE.LT.0) GOTO 400
      IF (IMODE.EQ.6) GOTO 600
      IF (IMODE.EQ.7) GOTO 700
      IF (IMODE.EQ.8) GOTO 800
C 
C 
C     3. Here we are sending data to the MAT. 
C     Put an "=" sign before the data 
C 
        CALL ICHMV(IBUF,4,2H= ,1,1) 
D     WRITE(LU,9903) IMODE,NCHAR,IBUF 
D9903 FORMAT("BEFORE DATAT IMODE,NCHAR,IBUF="2I4,20A2)
        CALL DATAT(IMODE,IBUF,NCHAR,LUMAT,KECHO,LU,KWVR,
     .             IBUF2(2),NCH2,IERR)
D     WRITE(LU,9904) IMODE,NCHAR,IBUF,IERR,NCH2,IBUF2 
D9904 FORMAT("AFTER DATAT IMODE,NCHAR,IBUF,IER,NC2,BUF2="/
D    .2I4,20A2/2I4,20A2)
        GOTO 899
C 
C 
C     4.  Here we are requesting a type of data from the device.
C     For tape drive communications, the buffer is set up like: 
C                   #nns> 
C     For other units, the buffer is: 
C                   #nns
C     where s=strobe character
C 
400   NCHAR = ICHMV(IBUF,4,LSTROB(-IMODE),1,2)-1
C                   Put proper strobe character followed by > into buffer 
      IF (KTP) CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,KWVR,IBUF2(2),
     .NCH2,IERR)
C                   Send #nns> to the tape drive and let it get 
C                   ready for the following data request. 
      IF (KTP) NCHAR = 4
C                   For the tape drive, we send #nn? only 
C                   For the other modules, we already have #nns> in the 
C                   buffer and NCHAR is set at the > character
      NCHAR = ICHMV(IBUF,NCHAR,2H? ,1,1)-1
C                   Put the ? into the buffer, so that
C                   for the tape drive, we have #nn?
C                   and for the others, we have #nns? 
      CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
      GOTO 899
C 
C 
C     5. For mode 5, send buffer straight to MAT, get response, 
C     if any, and return to caller. 
C 
500   KWVR = ICHCM(IBUF(2),1,LWVR,1,3).EQ.0 
      CALL IAT(IBUF(2),NCHAR-2,LUMAT,KECHO,LU,KWVR,IBUF2(2),
     .NCH2,IERR)
      GOTO 899
C 
C 
C     6. TEST/RESET mode messages.  Buffer already contains #xx.
C 
600   CALL ICHMV(IBUF,4,33B,2,1)
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
C                   Send <escape> to the device 
      IF (IERR.LT.0.OR.NCH2.EQ.0) GOTO 900
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
      CALL ICHMV(IBUF,1,5HUUUUU,1,5)
C                   Send some UU's to synch up again
      NCH = 5 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERRX)
      GOTO 900
C 
C 
C     7. Query and reset alarm.  Buffer contains address. 
C 
700   CALL ICHMV(IBUF,4,2H' ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
C                   Send ' to query alarm 
      IF (IERR.LT.0.OR.NCH2.EQ.0) GOTO 900
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
      CALL ICHMV(IBUF,4,2H" ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
C                   Send " to reset alarm 
      CALL ICHMV(IBUF,4,2H' ,1,1) 
      NCH = 4 
      CALL IAT(IBUF,NCH,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
      GOTO 899
C 
C 
C     8. Send buffer directly.  Address has already been substituted
C     into first three characters.  Fill in fourth with a blank.
C 
800   CALL ICHMV(IBUF,4,2H  ,1,1) 
      CALL IAT(IBUF,NCHAR,LUMAT,KECHO,LU,KWVR,IBUF2(2),NCH2,IERR) 
      GOTO 899
C 
C 
C     9.  End of outer loop on class records. 
C 
899   IF ((IERR.LT.0.AND.IERR.NE.-5).OR.NCH2.EQ.0) GOTO 900 
C                   If there was a real error, skip any responses 
C                   EXCEPTION: for wrong-length responses, report 
C                   the actual response - it might be intereseting. 
      CALL EXEC(20,0,IBUF2,-NCH2-2,2HFS,0,ICLASR) 
      NCLRER = NCLRER + 1 
C                   Put response into class 
      IF (IERR.NE.+2) GOTO 900
      LALARM(1) = MODTBL(1,IDEV)
      CALL ICHMV(LALARM,10,MODTBL(1,IDEV),1,2)
      CALL ICHMV(LALARM,14,MODTBL(2,IDEV),1,2)
      CALL EXEC(20,0,LALARM,-NALARM,2HFS,0,ICLASR)
C                   If alarm was on, send message 
      NCLRER = NCLRER + 1 
C 
900     CONTINUE
C 
C 
C     10. Now we have read all of the class records.  There may have
C     been an error in one record, and there may also be outstanding
C     response class numbers.  If so, do not send back partial classes. 
C     EXCEPTION: for wrong-length responses (IERR=-5) send it back. 
C 
      IF (IERR.GE.0.OR.IERR.EQ.-5) GOTO 1090
C                   If there was no error, send any response classes on 
C                   back to BOSS. 
      IF (ICLASR.EQ.0) GOTO 1090
      DO 1005 I=1,NCLRER
        CALL EXEC(21,ICLASR,IBUF,-ILEN) 
1005    CONTINUE
C                   Clear out all response classes
      ICLASR = 0
      NCLRER = 0
C 
1090  IP(1) = ICLASR
      IP(2) = NCLRER
      IP(3) = IERR
      IP(4) = 2HMA
      IP(5) = MODTBL(1,IDEV)
      CALL PRTN(IP) 
      CALL EXEC(6,0,1)
C                   SUSPEND HERE *********************************
      CALL RMPAR(IP)
      GOTO 1
      END 
