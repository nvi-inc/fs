FTN77,I,Y
$CDS ON
C@SBIT
      SUBROUTINE SBIT(IARRAY,IBIT,IVAL) 
     .,C#870115:06:04 SOLV2 SET BIT UTIL# 
C 
C   SBIT ... sets a bit in IARRAY indexed by IBIT to IVAL (0 or 1). 
C        Logical function KBIT can then test the bit (true if bit is 1).
C 
C   RESTRICTIONS - IF IVAL IS NOT 0 OR 1, THIS ROUTINE DOES NOTHING.
C 
C     INPUT VARIABLES:
CI
      DIMENSION IARRAY(1) 
C     -Array containing the bits to be set or reset.
C     - may or may not really be dimensioned in calling program.
CI
C     IBIT = index of bit to be set or reset. 
C            Bit 1 is the lowest order bit of IARRAY(1), bit 16 is the sign 
C            bit of IARRAY(1), bit 17 is the lowest order bit of IARRAY(2), 
C            etc. This is the same indexing scheme employed in func. KBIT.
CI
C     IVAL = 0 or 1 = value to which bit is to be set;
C            = 1 if IVAL is ommitted from calling sequence. 
C 
C     OUTPUT VARIABLES: 
C 
C  LOCAL: 
C 
      DIMENSION MASK(16)
C 
C  INITIALIZED: 
C 
      DATA MASK /1,2,4,10B,20B,40B,100B,200B,400B,1000B,2000B,4000B,
     M 10000B,20000B,40000B,100000B/
C      - words which contain 1 bit set. Note remarks above about SOLVE
C        numbering bits 1-16 instead of 0-15 to facilitate use of an
C        array index. 
C 
C   PROGRAMMER: J.C.PIGG
C     LAST MODIFIED:  NRV 810706
C 
C 
C     1. Decompose IBIT into an array index IA and a bit index IB.
C 
      IA = (IBIT+15)/16 
      IB = IBIT - (IA-1)*16 
C 
C 
C     2. IF IVAL is 1, force the appropriate bit to 1.
C 
      IF (IVAL.EQ.1) IARRAY(IA) = IOR(IARRAY(IA),MASK(IB))
C 
C 
C     3. IF IVAL is 0, force the appropriate bit to 0.
C 
      IF (IVAL.EQ.0) IARRAY(IA) = IAND(IARRAY(IA),NOT(MASK(IB)))
C 
C 
      END 
