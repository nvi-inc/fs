FTN77,I,Y
$ALIAS /FSCOM/ , NOALLOCATE
$CDS ON
      SUBROUTINE POSHD(IHD,IPASS,PNOWX,IP)    !  DETERMINE HEAD POSITION
C 
C  INPUT VARIABLES: 
C     IHD - head to be checked (1 or 2) 
C     IPASS - tape pass number (odd for forward passes, even for reverse)
      DIMENSION IP(1)       !   the standard RMPAR parameters
C         IP(1)= CLASS #, IP(2)= # OF RECORDS, IP(3)= ERROR PARAMETER
C
C  OUTPUT VARIABLE:
C     PNOWX - Current direction-calibrated LVDT position (microns)
C 
C  COMMON BLOCKS USED:
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C       CONTAINS:  FOROFF,REVOFF - direction-dependent offsets to PNOWX
C                  PSLOPE,RSLOPE - sign-dependent multiplicative factors
C 
C  LOCAL VARIABLES: 
      DIMENSION IBUF(20),IREG(2)
      EQUIVALENCE (REG,IREG(1)) 
      DATA ILEN /40/,TCOEFF /0.0/,TCOREF /0.0/  
C 
C   LAST MODIFIED:  LAR ADDED DIRECTION CALIBRATION   <880821.0120>
C 
C  1. First set up class buffers for MATCN
C 
D     WRITE(LU,9956) IHD,IPASS,(IP(I),I=1,5)
D9956 FORMAT(" POSHD: IHD,IPASS,IPS ",7I7)
      NREC = 0
      ICLASS = 0
      DO I=1,2
        IBUF(1) = 0 
        IBUF(2) = 2HHD
        CALL ICHMV(IBUF,5,8H00000000,1,8) 
        N = IHD - 1 
        IF (I.EQ.2) N = N+2 
        CALL IB2AS(N,IBUF,12,1) 
        CALL EXEC(20,0,IBUF,-12,2HFS,0,ICLASS)
        IBUF(1) = -2
        CALL EXEC(20,0,IBUF,-4,2HFS,0,ICLASS) 
        NREC = NREC+2 
      ENDDO
C 
C  2. Now schedule MATCN
C 
D     WRITE(1,*) 'ABOUT TO CALL MATCN'
      CALL EXEC(23,6HMATCN ,ICLASS,NREC)
      CALL RMPAR(IP)
D     WRITE (1,*) 'IP PARAMETERS RETURNED:',(IP(I),I=1,5)
C
C  3. Get and decode position and temperature responses from MATCN
C
      ICLASS = 0
      IF (IP(3).LT.0) RETURN
      ICLASS = IP(1)
      NREC = IP(2)
      IF (NREC.NE.4) THEN
        IP(3) = -403
        GOTO 990
      ENDIF
      REG = EXEC(21,ICLASS,IBUF,-ILEN)
      REG = EXEC(21,ICLASS,IBUF,-ILEN)
      NCHAR = MIN0(IREG(2),ILEN)
C     IF (NCHAR.NE.8) THEN
C       IP(3) = -303
C       GOTO 990
C     ENDIF
      CALL HEXI(IBUF(4),IVLT,4,IERR)
D     WRITE(LU,9001) IVLT
D9001 FORMAT("VLTGE NUMBER FROM HD = "I5)
      IF (IERR.NE.0) THEN
        IP(3) = -303
        GOTO 990
      ENDIF
      REG = EXEC(21,ICLASS,IBUF,-ILEN)
      REG = EXEC(21,ICLASS,IBUF,-ILEN)
      NCHAR = MIN0(IREG(2),ILEN)
C     IF (NCHAR.NE.8) THEN
C       IP(3) = -303
C       GOTO 990
C     ENDIF
      CALL HEXI(IBUF(4),ITVLT,4,IERR)
D     WRITE (LU,9001) ITVLT
      IF (IERR.NE.0) THEN
        IP(3) = -303
        GOTO 995
      ENDIF
C 
C  4. Convert responses to voltages and compute position in um. 
C 
      PVLT = IVLT*.0048828D0
      TVLT = ITVLT*.0048828D0 
      TVLT = TVLT*10. 
      IF (PVLT.GE.0.) THEN
        SLOPE = PSLOPE(IHD)
      ELSE
        SLOPE = RSLOPE(IHD)
      ENDIF
      PNOWX = SLOPE*PVLT*(1.+TCOEFF*(TVLT-TCOREF)) - FOROFF(IHD)
C  Subtract ADDITIONAL (not alternate) offset if it's a reverse (even) pass
      IF (IPASS.EQ.2*(IPASS/2)) PNOWX = PNOWX - REVOFF(IHD)
C
D     WRITE(LU,9002) PVLT,SLOPE,PNOWX 
D9002 FORMAT("VLTG,SLOPE,POSITION IN POSHD = "3F10.4) 
      GOTO 995
C 
990   CONTINUE
D     WRITE(LU,9963) ICLASS 
D9963 FORMAT(" POSHD: ICLASS ",I7)
      IF(ICLASS.NE.0) CALL CLRCL(ICLASS)
D     WRITE(LU,9967) ICLASS 
D9967 FORMAT(" POSHD: AFTER CLRCL, ICLASS ",I7) 
995   IP(1) = 0
      IP(2) = 0
      IP(4) = 2HQ>
      RETURN
      END 
