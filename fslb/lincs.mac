ASMB
        HED  UTILITY FOR CALLING SUBROUTINES IN SEGMENTS
        NAM  LINC,7 General segment-controller package  CMA 800101
* 
* LINC IS A GENERAL SEGMENT CONTROLLER WHICH ALLOWS THE USER TO CALL
* SPECIFIC SUBROUTINES IN A SEGMENT AND TO PASS AN ARGUMENT LIST BY 
* ADDRESS TO THE SUBROUTINE IN THE SEGMENT.  A SEGMENT IS RETAINED IN CORE
* UNTIL IT IS NECESSARY TO GET A DIFFERENT SEGMENT.  SUBROUTINES IN ONE 
* SEGMENT MAY BE CALLED FROM ANOTHER SEGMENT.  ON RETURNING TO A SEGMENT
* OR THE ROOT, EXECUTION PROCEEDS AT THE STATEMENT FOLLOWING THE INITIAL
* CALL. 
* 
* THE USER CALL TO LINC IS AS FOLLOWS:
* 
*      CALL LINCA(6Hsgmnm ,6Hsbrnm ,arg1,arg2,...)
* 
* WHERE sgmnm = SEGMENT NAME (NAME MUST BE FILLED TO 6 CHAR. BY BLANKS) 
*       sbrnm = SUBROUTINE NAME (NAME MUST BE FILLED TO 6 CHAR. BY BLANKS)
*       arg1,arg2,... = ARGUMENTS FOR SUBROUTINE sbrnm (<=30) 
* 
* THE MAIN PROGRAM IN A SEGMENT HAS THE FOLLOWING FORM: 
* 
*      PROGRAM sgmnm,5
*      EXTERNAL subr1,subr2,... 
*      QDATA LS /subr1 subr2 .../ 
*      CALL LINCB(LS,subr1,subr2,...) 
*      END
* 
* WHERE sgmnm = NAME OF SEGMENT 
*       subr1, subr2, ... = SUBROUTINES IN SEGMENT WHICH CAN BE CALLED (<=20) 
*                           THE ORDER IN ARRAY LS AND IN THE CALL TO LINCB
*                           MUST BE IDENTICAL.  IN ARRAY LS EACH NAME MUST
*                           OCCUPY 6 CHARACTERS LEFT-ADJUSTED WITH TRAILING 
*                           BLANKS. 
* 
* ENTRY LINCA SAVES THE ARGUMENT VECTOR AND OTHER INFORMATION INTERNALLY
* BEFORE GETTING THE SEGMENT (IF IT IS NOT IN CORE) OR TRANSFERRING DIRECTLY
* TO THE SEGMENT (IF IT IS ALREADY IN CORE).  AN ERROR MESSAGE (FORMAT BELOW) 
* IS PRINTED ON THE SYSTEM CONSOLE IF MORE THAN 30 ARGUMENTS ARE PASSED.
* 
* ENTRY LINCB SEARCHES FOR THE CORRECT SUBROUTINE USING THE LIST GIVEN IN 
* ARRAY LS.  WHEN THE PROPER ENTRY IS FOUND, CONTROL IS TRANSFERRED.  IF THE
* PROPER ENTRY IS NOT FOUND, THE PROGRAM IS ABORTED.  AN ERROR MESSAGE IS 
* PRINTED ON THE SYSTEM CONSOLE WITH THE SEGMENT AND SUBROUTINE CALLED.  THE
* RETURN ADDRESS FOR THE LINCA CALL IS IN THE A REGISTER AND THE NUMBER OF
* ARGUMENTS TO THE SUBROUTINE IS IN THE B REGISTER. 
* 
* AT LEAST 3 LEVELS OF SEGMENTS MAY BE CALLED, I.E., THE ROOT CALLS SUBR1 IN
* SGMN1 WHICH CALLS SUBR2 IN SGMN2 WHICH CALLS SUBR3 IN SGMN3.  MORE LEVELS 
* CAN BE CALLED IF FEWER THAN 30 ARGUMENTS ARE PASSED.  AN ERROR MESSAGE IS 
* PRINTED ON THE SYSTEM CONSOLE IF THE STACK OVERFLOWS. 
* 
* IF NESTING IS USED, ALL THE ROUTINES IN THE CHAIN MUST BE CALLED USING
* LINCA.  ONCE IN A SEGMENT, LINCA CAN BE USED TO CALL ANOTHER SUBROUTINE 
* WITHIN THE CURRENT SEGMENT IF THAT SUBROUTINE IS EXPECTED TO CALL A 
* SUBROUTINE IN ANOTHER SEGMENT.  LOCAL VARIABLES ARE PRESERVED AS LONG AS
* THE SAME SEGMENT IS CONTINUOUSLY IN CORE. 
* 
* SINCE SEGMENTS ARE RE-INITIALIZED EACH TIME THEY ARE RECALLED FROM DISK, IT 
* IS THE RESPONSIBILITY OF THE USER TO ASSURE THAT THE NECESSARY LOCAL
* VARIABLES ARE RESTORED AND THAT ARGUMENTS ARE PRESENT IN CORE WHEN NEEDED.
* ARGUMENTS PASSED MUST BE IN THE ROOT OR IN SAVED/RESTORED LABELED COMMON. 
* IN THE LATTER CASE, THE ORDER OF LABELED COMMON MUST BE IDENTICAL IN THE
* CALLING AND CALLED SEGMENTS SO THAT THE ARGUMENTS WILL HAVE THE SAME
* ADDRESSES.  ARGUMENTS MAY BE PASSED FROM THE ROOT TO ANY LEVEL OF 
* SUBROUTINE. 
* 
        ENT  LINCA,LINCB
        EXT  .ENTR,EXEC,SEGLD 
* 
DFARG   DEF  AARGS     ADDR OF TRUE ARGUMENT VECTOR IN LINCA CALL 
NARGS   BSS  1         NUMBER OF ARGUMENTS TO CALLED SUBROUTINE 
DFNAR   DEF  NARGS     ADDR OF NUMBER OF ARGUMENTS - USED FOR RETRIEVAL 
ERMSS   ASC  3,LINC    ERROR MESSAGE BUFFER 
SEGNM   BSS  3         NAME OF SEGMENT IN CORE
SUBNM   BSS  3         NAME OF SUBROUTINE CALLED
SEGRT   BSS  3         NAME OF SEGMENT FOR RETURN 
DFSGR   DEF  SEGRT     ADDR OF RETURN SEGMENT NAME
DFSG2   DEF  SEGRT+2   ADDR OF END OF NAME OF RETURN SEGMENT - FOR RETRIEVAL
DFSBN   DEF  SUBNM     ADDR OF NAME OF SUBROUTINE CALLED
NSUB    BSS  1         SUBROUTINE POINTER - USED TO GET PROPER ENTRY
DFSB1   DEF  SUBR+1    ADDR OF *+N+1 IN CALLING INTERNAL SEQUENCE 
DFSB2   DEF  SUBR+2    ADDR OF ARGUMENT VECTOR IN INTERNAL CALLING SEQUENCE 
ARTRN   BSS  1         RETURN ADDR
DFRTN   DEF  RETRN     ADDR OF RETURN ADDR - FOR ENTRY OF RELOADED SEGMENT
AENTR   BSS  1         INTERNAL BP LINK TO ENTRY
DFENT   DEF  AENTR     ADDR OF INTERNAL LINK - USED FOR RETRIEVAL 
DFEXT   DEF  AEXTS     ADDR OF ENTRY POINT VECTOR OF LINCB
RFLG    BSS  1         FLAG FOR LINCA OR SEGMENT RETURN 
* 
ASEGN   BSS  1         ADDR OF SEGMENT NAME 
ASUBN   BSS  1         ADDR OF SUBROUTINE NAME
AARGS   BSS  30        ADDR OF SUBROUTINE ARGUMENTS 
XARG    DEC  0         ZERO TO CHECK EXCESS ARGUMENTS 
LINCA   NOP            ENTRY POINT TO ACCESS SUBROUTINE IN SEGMENT
        JSB  .ENTR     GET ARGUMENTS
        DEF  ASEGN
        LDA  LINCA     LOAD RETURN ADDRESS
        ISZ  STACK     INCREMENT STACK POINTER
        STA  STACK,I   SAVE RETURN ADDR (1 WD) IN STACK 
        LDB  ASEGN     LOAD ADDR OF SEGMENT NAME
        LDX  =D3       LOAD STACK COUNT 
        JLY  PSTK      SAVE SEGMENT NAME (3 WD) IN STACK
        LDA  LINCA     LOAD RETURN ADDR 
        LDB  LINCA     LOAD IN B REG FOR ADDRESSING 
LPARG   ADB  =D-1      BACK UP ADDR ONE LOCATION
        CPA  1,I       COMPARE LOCATION WITH RETURN ADDR
        JMP  FNARG     EQUAL MEANS HEAD OF ARGUMENT VECTOR - DEF *+N+1
        JMP  LPARG     NOT EQUAL - LOOP TO NEXT LOCATION
FNARG   CMB            2'S COMPLEMENT OF *+1 IN B REG 
        ADA  1         A REG = *+1+N-(*+1) = NUMBER OF ARGUMENTS
        ADA  =D-2      SUBTRACT 2 FOR SEGMENT AND SUBROUTINE NAMES
        STA  NARGS     SAVE NUMBER OF ARGUMENTS FOR CALLED SUBROUTINE 
        SZA,RSS        CHECK IF NO ARGUMENTS
        JMP  NOARG     NO ARGUMENTS FOR SUBROUTINE
        CAX            COPY TO X REG FOR STACK COUNT
        LDB  DFARG     LOAD ADDR OF ARGUMENT VECTOR 
        JLY  PSTK      SAVE ARGUMENT VECTOR (NARGS WD) IN STACK 
        LDA  NARGS     LOAD NUMBER OF ARGUMENTS 
NOARG   ISZ  STACK     INCREMENT STACK POINTER
        STA  STACK,I   SAVE NUMBER OF ARGUMENTS (1 WD) IN STACK 
        ADA  DFSB2     ADD DEF *+1 FOR CALLING SEQUENCE 
        STA  SUBR+1    SET DEF *+N+1 IN CALLING SEQUENCE
        CLA            ZERO A REG 
        LDX  =D30      SET COUNT FOR CLEARING SUBROUTINE ARGUMENT VECTOR
        LDB  DFSB2     LOAD ADDR OF FIRST LOCATION IN ARGUMENT VECTOR 
LPZER   STA  1,I       CLEAR WORD TO NOP
        INB            INCREMENT ADDR IN ARGUMENT VECTOR
        DSX            DECREMENT COUNT
        JMP  LPZER     LOOP TO CLEAR NEXT WORD IF COUNT NOT ZERO
        LDA  DFARG     LOAD ADDR OF TRUE ARGUMENT VECTOR IN LINCA ENTRY 
        LDB  DFSB2     LOAD ADDR OF ARGUMENT VECTOR IN SUBROUTINE CALL
        MVW  NARGS     MOVE VECTOR FROM LINCA TO SUBROUTINE CALLING SEQUENCE
        LDA  ASUBN     LOAD ADDR OF SUBROUTINE NAME IN CALLING ROUTINE
        LDB  DFSBN     LOAD ADDR OF INTERNAL SUBROUTINE NAME ARRAY
        MVW  =D3       SAVE SUBROUTINE NAME 
        LDA  =D-1      SET FLAG 
        STA  RFLG      FOR LINCA CALL 
*       JSB  DUMP      DUMP SEG IN CORE, SUBR CALLED, SEG RETURN, SEG CALLED
        LDA  ASEGN     LOAD ADDR OF SEGMENT NAME
        LDB  DFSGN     LOAD ADDR OF NAME OF SEGMENT IN CORE 
        CMW  =D3       COMPARE NAMES
        JMP  MINCB     NAMES SAME - JMP TO GET PROPER ENTRY 
        NOP            NAMES NOT SAME - NEW SEGMENT NEEDED
        LDA  ASEGN     LOAD ADDR OF SEGMENT NAME
        LDB  DFSGN     LOAD ADDR OF NAME OF SEGMENT IN CORE 
        MVW  =D3       MOVE NAME
        LDB  XARG      LOAD POSSIBLE EXCESS ARGUMENT
        SZB            CHECK IF FILLED
        JMP  ERROR     TOO MANY ARGUMENTS 
EXEC8   JSB  SEGLD     CALL SEGLD(SEGNM)  
        DEF  *+2       TO GET SEGMENT 
DFSGN   DEF  SEGNM
* 
ATABL   BSS  1         ADDR OF SUBROUTINE LIST
AEXTS   BSS  20        ENTRY POINTS 
LINCB   NOP            ENTRY POINT FROM SEGMENT MAIN
        JSB  .ENTR     GET ARGUMENTS
        DEF  ATABL
        ISZ  RFLG      CHECK FLAG FOR LINCA OR SEGMENT RETURN 
        JMP  SGRTN     RETURN FROM SEGMENT TO SEGMENT 
MINCB   CLB            COMING FROM LINCA CALL 
        STB  NSUB      INITIALIZE SUBROUTINE POINTER
        LDA  ATABL,I   GET CHARACTER COUNT
        DIV  =D6       DIVIDE BY 6 TO GET SUBROUTINE TOTAL
        CAX            COPY COUNT TO X REG FOR SEARCH LOOP
        LDY  ATABL     LOAD ADDR OF NAME LIST 
        ISY            SKIP OVER CHARACTER COUNT
LPNAM   CYB            COPY ADDR TO B REG FOR COMPARE 
        LDA  DFSBN     LOAD ADDR OF SAVED SUBROUTINE NAME 
        CMW  =D3       COMPARE NAME TO LIST 
        JMP  FNAME     FOUND NAME 
        NOP            DID NOT FIND NAME
        ADY  =D3       INCREMENT ADDR TO NEXT NAME
        ISZ  NSUB      INCREMENT SUBROUTINE POINTER 
        DSX            DECREMENT COUNT
        JMP  LPNAM     LOOP TO COMPARE NEXT NAME IF COUNT NOT ZERO
        JMP  ERROR     LIST EXHAUSTED 
FNAME   LDB  DFEXT     LOAD ADDR OF ENTRY POINT VECTOR
        ADB  NSUB      INCREMENT BY SUBROUTINE POINTER
        LDA  1,I       LOAD PROPER ENTRY
        STA  AENTR     SAVE IN INTERNAL BP LINK FOR JSB IN CALLING SEQUENCE 
        ISZ  STACK     INCREMENT STACK POINTER
        STA  STACK,I   SAVE ENTRY POINT (1 WD) IN STACK 
SUBR    JSB  AENTR,I   CALL SUBROUTINE
        DEF  *+1       POINTER OVER ARGUMENT VECTOR 
        BSS  30        ARGUMENT VECTOR FOR ACTUAL SUBROUTINE CALL 
RETRN   LDA  STACK     INTERNAL RETURN - GET STACK POINTER
        ADA  =D-1      DECREMENT OVER ENTRY TO ADDR OF NUMBER OF ARGUMENTS
        LDB  0,I       LOAD NUMBER OF ARGUMENTS 
        ADB  =D3       INCREASE FOR SEGMENT NAME
        CMB            2'S COMPLEMENT 
        ADA  1         POINTER NOW AT RETURN ADDR IN STACK
        LDB  0,I       LOAD RETURN ADDR 
        STB  ARTRN     SAVE RETURN ADDR 
        ADA  =D-1      DECREMENT POINTER
        STA  STACK     REPLACE STACK POINTER
        CPA  STAK0     CHECK IF STACK IS EMPTY
        JMP  ARTRN,I   EMPTY - RETURN TO ROOT 
        LDA  STACK     SAVE STACK POINTER 
        STA  STAK1     FOR NEXT RETURN
        LDB  DFENT     LOAD ADDR OF INTERNAL BP LINK
        LDX  D1        LOAD COUNT FOR STACK RETRIEVAL 
        JLY  GSTK      RETRIEVE ENTRY POINT 
        LDB  DFNAR     LOAD ADDR OF NUMBER OF ARGUMENTS 
        LDX  D1        LOAD COUNT FOR STACK RETRIEVAL 
        JLY  GSTK      RETRIEVE NUMBER OF ARGUMENTS 
        LDA  NARGS     NUMBER OF ARGUMENTS TO SUBROUTINE
        SZA,RSS        CHECK IF NO ARGUMENTS SAVED
        JMP  LOSEG     NO ARGUMENTS 
        CAX            ARGUMENTS - COPY TO X REG FOR RETRIEVAL COUNT
        LDB  DFSB1     LOAD ADDR-1 OF ARGUMENT VECTOR IN INTERNAL CALL
        ADB  0         INCREMENT BY NUMBER OF ARGUMENTS 
        JLY  GSTK      RETRIEVE ARGUMENT VECTOR 
LOSEG   LDB  DFSG2     LOAD ADDR OF RETURN SEGMENT NAME 
        LDX  =D3       LOAD COUNT FOR STACK RETRIEVAL 
        JLY  GSTK      RETRIEVE SEGMENT NAME
        LDA  STAK1     RELOAD SAVED STACK POINTER 
        STA  STACK     RESTORE STACK POINTER
        CLA            ZERO A REG 
        STA  RFLG      SET FLAG FOR SEGMENT RETURN
*       JSB  DUMP      DUMP SEG IN CORE, SUBR CALLED, SEG RETURN, SEG CALLED
        LDA  DFSGR     LOAD ADDR OF RETURN SEGMENT
        LDB  DFSGN     LOAD ADDR OF SEGMENT IN CORE 
        CMW  =D3       COMPARE NAMES
        JMP  SGRTN     NAMES SAME - SEGMENT ALREADY IN CORE 
        NOP            NAMES NOT SAME - ANOTHER SEGMENT NEEDED
        LDA  DFSGR     LOAD ADDR OF RETURN SEGMENT
        LDB  DFSGN     LOAD ADDR OF SEGMENT IN CORE 
        MVW  =D3       MOVE SEGMENT NAME FOR EXEC(8,SEGNM)
        JMP  EXEC8     GET SEGMENT
* 
SGRTN   LDA  DFRTN     SEGMENT RETURN - LOAD INTERNAL RETURN ADDR 
        STA  AENTR,I   STORE IN ENTRY POINT 
        LDA  AENTR     LOAD ENTRY ADDR
        ADA  D2        STEP TO ADDR OF DEF ARGS 
        LDB  0,I       LOAD ADDR OF ARGUMENT VECTOR 
        LDA  DFSB2     LOAD ADDR OF RETRIEVED ARGUMENT VECTOR 
        MVW  NARGS     MOVE ARGUMENT VECTOR INTO EMPTY ARRAY
        JMP  ARTRN,I   JMP TO RETURN WITHIN SEGMENT 
* 
PSTK    LDA  STACK     LOAD STACK POINTER 
        CMA,INA        COMPLEMENT AND INCREMENT FOR DIFFERENCE
        ADA  STAKE     COMPARE WITH STACK LIMIT 
        SSA            SKIP IF POSITIVE, I.E., POINTER BELOW LIMIT
        JMP  ERROR     STACK OVERFLOW - MESSAGE AND ABORT 
        LDA  1,I       LOAD WORD USING B REG AS ADDR
        ISZ  STACK     INCREMENT STACK POINTER
        STA  STACK,I   STORE WORD IN STACK
        INB            INCREMENT FETCH ADDR 
        DSX            DECREMENT COUNT
        JMP  PSTK      LOOP FOR NEXT WORD IF COUNT NOT ZERO 
        JPY  0         RETURN 
* 
GSTK    LDA  STACK,I   LOAD WORD
        STA  1,I       PLACE WORD USING B REG AS ADDR 
        LDA  STACK     LOAD STACK POINTER 
        ADA  =D-1      DECREMENT
        STA  STACK     REPLACE STACK POINTER
        ADB  =D-1      DECREMENT ADDR 
        DSX            DECREMENT COUNT
        JMP  GSTK      LOOP FOR NEXT WORD IF COUNT NOT ZERO 
        JPY  0         RETURN 
* 
STAK0   DEF  STACK     EMPTY STACK POINTER
STAK1   BSS  1         TEMPORARY SAVED POINTER
STACK   DEF  STACK     STACK POINTER - INITIALIZED EMPTY
        BSS  110
STAKE   DEF  *-5       STACK UPPER LIMIT FOR TEST 
* 
ERROR   LDA  LINCA     ERROR - SUBROUTINE NOT FOUND OR STACK OVERFLOW 
        LDB  NARGS     OR TOO MANY ARGUMENTS
        JSB  EXEC 
        DEF  *+5
        DEF  D2        WRITE MESSAGE
        DEF  D1        ON SYSTEM CONSOLE
        DEF  ERMSS     "LINC SGMNM SUBNM" 
        DEF  D9 
        HLT 
D2      DEC  2
D1      DEC  1
D9      DEC  9
*DUMP    NOP            DUMP UTILITY FOR DEBUGGING
*        JSB  EXEC
*        DEF  *+5 
*        DEF  D2        WRITE 
*        DEF  D1        OUTPUT TO SYSTEM CONSOLE
*        DEF  SEGNM     SEGMENT IN CORE, SUBR CALLED, SEGMENT RETURN
*        DEF  D9        9 WORDS OUTPUT
*        LDA  ASEGN     LOAD ADDR OF CALLED SEGMENT 
*        STA  *+5       STORE FOR OUTPUT
*        JSB  EXEC
*        DEF  *+5 
*        DEF  D2        WRITE 
*        DEF  D1        OUTPUT TO SYSTEM CONSOLE
*        NOP            ADDR OF CALLED SEGMENT NAME 
*        DEF  D3        3 WORDS OUTPUT
*        JMP  DUMP,I    RETURN
*D3      DEC  3 
        END 
