FTN4,X
C@GETCM 
C 
      SUBROUTINE GETCM(ISTKSK,ISTKOP,LSTKSK,LSTKOP,IDCBP1,IDCBP2,IDCBSK,
     .            KBLKSK,KBLKOP,KHALT,KBREAK,ICLOPR,ICLOP2, 
     .            IBLEN,IBUF,NCHAR,LSOR,LPROCS,LPROCO,LPPARM,NCPARM,
     .            LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,NPROC2,ITMLOG, 
     .            MAXPR1,MAXPR2,IERR,ICURLN,ILSTLN) 
     .                 ,GET NEXT COMMAND C#870115:04:19#
C 
C     GETCM - gets the next command for BOSS to process 
C 
C     DATE   WHO CHANGES
C     810907 NRV Added procedure arrays 
C     840320 MWH Added support for specified number of schedule lines to execute
C  INPUT VARIABLES: 
C 
      DIMENSION ISTKSK(1),ISTKOP(1),LSTKSK(1),LSTKOP(1) 
C     Stacks for procedure names and parameters 
      DIMENSION IDCBP1(1),IDCBP2(1),IDCBSK(1) 
C     DCB'S for procedure files, schedule 
      DIMENSION LNAMES(5,1),LPROC1(5,1),LPROC2(5,1) 
C     Arrays with command names 
      LOGICAL KBLKSK,KBLKOP 
C     True when schedule/operator stream is blocked 
      LOGICAL KHALT 
C     True when HALT was issued to block schedule 
      LOGICAL KBREAK
C     True when operator asks for a procedure to be ended early 
C 
C  OUTPUT VARIABLES:
C 
      DIMENSION IBUF(1) 
C     Buffer with new command 
C     IBLEN  - max length of IBUF in words
C     NCHAR  - number of characters in command in IBUF
C     LSOR   - source of command - schedule, operator, procedure
      DIMENSION LPPARM(1) 
C     Parameters string 
C     NCPARM - number of chars in LPPARM
C     IERR  - error return, non-zero FMP error
C 
C  LOCAL VARIABLES: 
C 
      DIMENSION IREG(2) 
      EQUIVALENCE (IREG(1),REG) 
C 
D     DATA LU/24/ 
C  INITIALIZED VARIABLES: 
C 
C 
C 
C     1. Initialize error return and number of characters.
D     WRITE(LU,9601)
D9601 FORMAT("IN GETCM")
C 
      NCHAR = 0 
      IERR = 0
C 
C 
C     2. First sift through all of the operator class stack to see if 
C     there are any "immediate execution" commands to be processed
C     or any time-scheduling commands.
C     If so, then that's our highest priority.
C 
200   REG = EXEC(21,ICLOPR+120000B,IBUF,-IBLEN*2) 
      NCHAR = IFLCH(IBUF,MIN0(IREG(2),IBLEN*2)) 
      IF (IREG.LT.0) NCHAR = 0
D     WRITE(LU,9101) NCHAR
D9101 FORMAT("NCHAR FROM ICLOPR"I5) 
      IF (NCHAR.EQ.0) GOTO 300
C                   When there's nothing there, that's the
C                   end of the class records
      IF (ICHAR(IBUF,1).EQ.42B.OR.ICHAR(IBUF,1).EQ.41B) GOTO 210
C                           "                       ! 
C                   Don't bother with comments or wait commands 
      ICH = ISCNC(IBUF,1,NCHAR,75B) 
C                     Scan for = for getting name 
      IF (ICH.EQ.0) ICH = ISCNC(IBUF,1,NCHAR,100B)
      IF (ICH.EQ.0) ICH = NCHAR+1 
      CALL GTNAM(IBUF,1,ICH-1,LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,NPROC2,
     .IERR,ITYPE,INDEX) 
      LSOR = 2H;; 
D     WRITE(LU,9100) INDEX,ITYPE,IERR,LNAMES(2,INDEX) 
D9100 FORMAT(" FROM GTNAM INDEX,ITYPE,IERR,SEG:"I5,O7,I5,A2)
      IF (ITYPE.NE.106B.OR.IERR.NE.0) GOTO 210
C                     We only deal with recognized functions
      IF (ICHAR(LNAMES(2,INDEX)).EQ.52B) GOTO 900 
C                   In this case one of the immediate-execute functions 
C                   is in IBUF, so we've got something for BOSS to do 
      IF (ISCNC(IBUF,1,NCHAR,100B).NE.0) GOTO 900 
C                     In this case, we've got a time-scheduled function which 
C                     gets done immediately.
210   IERR = 0
C                   Reset the error flag from GTNAM, we'll discover it later
      CALL EXEC(20,0,IBUF,NCHAR,2HFS,0,ICLOP2)
C                   In this case, it's an ordinary command.  Put it into
C                   the secondary operator class for later pick-up. 
      GOTO 200
C 
C 
C     3. First try to read something into the schedule stream.
C     If the schedule is blocked or a HALT was issued, try the
C     operator stream.
C 
300   IF (KHALT.OR.KBLKSK) GOTO 400 
      IF (ISTKSK(2).EQ.2) GOTO 310
C                   If we have nothing in the procedure stack 
C                   try to get next line in schedule file 
D     WRITE(LU,9911)
D9911 FORMAT("READP FOR SKD") 
      CALL READP(IDCBP1,IDCBP2,ISTKSK,LSTKSK,LPROC1,LPROC2,KBREAK,
     .IBUF,IBLEN,NCHAR,LPROCS,LPPARM,NCPARM,IERR) 
D     WRITE(LU,9001) (LPROCS(I),I=1,6)
D9001 FORMAT("LPROCS/O AFTER READP="6A2)
      IF (ISTKSK(2).EQ.2.OR.IERR.EQ.-1) GOTO 310
C                   If there's nothing left, go back to schedule file 
      LSOR = 2H$: 
      GOTO 900
C 
310   CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     .NPROC2,IBUF,IBLEN,ISTKOP,ISTKSK)
      IF(ICURLN.LT.ILSTLN)GOTO 320
        KHALT=.TRUE.
        ILSTLN=32767
        GO TO 400 
320   CALL READS(IDCBSK,IBUF,IBLEN,NCHAR,IERR)
      CALL LOCF(IDCBSK,IERR,ICURLN) 
      IF(NCHAR.EQ.0) IERR = 0 
      ICURLN=ICURLN-1 
      LSOR = 2H:: 
      IF (NCHAR.EQ.0) KBLKSK = .TRUE. 
      NCPARM = 0
      GOTO 900
C 
C 
C     4. As second choice, try to get something into the operator stream. 
C     First, read from the operator-invoked procedure file. 
C     Then, check the operator mail-box for a command.
C 
400   IF (KBLKOP) GOTO 900
D     WRITE(LU,9803)
D9803 FORMAT("GETCM FOR OP")
      IF (ISTKOP(2).EQ.2) GOTO 410
C                   If there is nothing in the procedure stack, try to
C                   get something from mailbox
      CALL READP(IDCBP1,IDCBP2,ISTKOP,LSTKOP,LPROC1,LPROC2,KBREAK,
     .IBUF,IBLEN,NCHAR,LPROCO,LPPARM,NCPARM,IERR) 
D     WRITE(LU,9001) (LPROCO(I),I=1,6)
      IF (ISTKOP(2).EQ.2.OR.IERR.EQ.-1) GOTO 410
      LSOR = 2H$; 
      GOTO 900
C 
410   CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     .NPROC1,IBUF,IBLEN,ISTKOP,ISTKSK)
      NCPARM = 0
      REG = EXEC(21,ICLOP2+120000B,IBUF,-IBLEN*2) 
      NCHAR = IFLCH(IBUF,MIN0(IREG(2),IBLEN*2)) 
      IF (IREG.LT.0) NCHAR = 0
      LSOR = 2H;; 
C 
C 
900   IF (IERR.EQ.-1) IERR = 0
      RETURN
      END 
