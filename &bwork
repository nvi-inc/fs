FTN4,X
      SUBROUTINE BWORK(IP,LNAMES,NNAMES,LPROC1,MAXPR1,LPROC2,MAXPR2,
     .ITSCB,NTSCB,IDCBSK),BOSS' WORKING ROUTINE C#870115:04:17# 
C 
C     This is the working subroutine of the Field System BOSS program.
C 
C     DATE   WHO CHANGES
C     810906 NRV Added procedure lists, 12-char proc names. 
C     840217 MWH Modified procedure stack structure.
C     840320 MWH Added LIST and STATUS SNAP commands. 
C 
      INCLUDE #FSCOM::FS
C 
      DIMENSION IP(5) 
C                   Array for RMPAR parameters
      DIMENSION LNAMES(5,1),LPROC1(5,1),LPROC2(5,1) 
C                   Command names list, and procedure lists 
      DIMENSION ITSCB(13,1) 
C                   Time Scheduling Control Block 
      DIMENSION IBUF(50)
C                   Input buffer containing command 
      DIMENSION ITIME(9)
C                   Time array returned from SPARS
      DIMENSION IT(6) 
C                   Time from system EXEC(11) call
      DIMENSION IOTREF(3),ISTREF(3) 
C                   Ref times for operator and schedule streams 
      DIMENSION LNAMEF(3) 
C                   File name, general use
      DIMENSION IDCBP1(144),IDCBP2(144) 
C                   DCB's for procedures from lists 1 and 2 
      DIMENSION ISTKSK(42),ISTKOP(42) 
C                   Stacks for nested procedures
      DIMENSION LPROCN(6) 
C                     Name of currently-executing procedure 
      DIMENSION LPROCS(6),LPROCO(6) 
C                   Names of schedule, operator top-of-stack procedures 
      DIMENSION LSTKSK(26),LSTKOP(26),LPPARM(6) 
C                   Stacks for procedure parameters, parameter string 
C     NCPARM - # chars in procedure parameter string
      DIMENSION LEND(8),LDONE(8),LM1(14)
C                   Messages
      DIMENSION ITMLOG(6) 
C                   Time log file was opened, from EXEC(11) 
      DIMENSION IREG(2) 
      LOGICAL KRCUR,KPAST,KLAST,KTS,KSKBLK,KOPBLK,KBREAK
C                   KRCUR returns true if a procedure calls itself
C                   KPAST returns true if a given time is earlier than now
C                   KLAST true if this is last time scheduling of command 
C                   KTS true if command was time-scheduled
C                   KSKBLK true if schedule is blocked waiting for time 
C                   KOPBLK true if operator is blocked waiting for time 
C                   KBREAK is true if operator wants to break a proc
      LOGICAL KSTAK 
C       - function which is true if the stacks contain procs from 
C         one of the libraries
      LOGICAL KX
C      - temporary logical variable 
C     ICLASS - general variable for class with command/response 
C     ICLOP2 - secondary operator class after immediate commands
C             have been stripped
C     MAXPR1,2 - Maximum number of procs allowed in each lists
      EQUIVALENCE (IREG(1),REG) 
      DATA IBLEN/50/
      DATA LEND   /2H*B,2HOS,2HS ,2HTE,2HRM,2HIN,2HAT,2HED/ 
      DATA LDONE  /2H*E,2HND,2H O,2HF ,2HSC,2HHE,2HDU,2HLE/ 
      DATA LM1 /2HNO,2H S,2HCH,2HED,2HUL,2HE ,2HCU,2HRR,2HEN,2HTL,
     .   2HY ,2HAC,2HTI,2HVE/ 
      DATA KSKBLK/.TRUE./, KOPBLK/.FALSE./
      DATA ISTKSK/40,2,40*0/, ISTKOP/40,2,40*0/ 
      DATA LSTKSK/24,2,24*0/, LSTKOP/24,2,24*0/ 
C     DATA IOTREF/3*0/, ISTREF/3*0/ 
      DATA NPROC1/0/, NPROC2/0/ 
C 
C 
C********************************************************************** 
C 
C     1. Initialize . 
C 
C     WRITE(LU,9001)((LNAMES(I,J),I=1,5),J=1,NNAMES)
C9001 FORMAT("NAMES LIST"/40(O5,1X,2A2,2I5/)) 
      ICLASS = 0
      ICLOP2 = 0
      CALL EXEC(11,IT,IT(6))
      IOTREF(1) = (IT(6)-1970)*1024 + IT(5) 
      IOTREF(2) = IT(4)*60 + IT(3)  
      IOTREF(3) = IT(2)*100 
      ISTREF(1) = IOTREF(1) 
      ISTREF(2) = IOTREF(2) 
      ISTREF(2) = IOTREF(2) 
      LPRC = 2HXX 
      CALL OPNPF(LPRC,IDCBP2,IBUF,IBLEN,ICRPRC,LPROC2,MAXPR2,NPROC2,
     .IERR) 
      IF (IERR.LT.0) CALL LOGIT(0,0,0,1,-131,2HBO,IERR) 
      CALL EXEC(11,ITMLOG,ITMLOG(6))
C 
C 
C     2. First and always, check the time list for something to do. 
C     This is the highest priority.  Get next job, or next time to awaken.
C     Check for any newly edited proc files sent by PFMED.
C 
200   CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     .NPROC2,IBUF,IBLEN,ISTKOP,ISTKSK)
D     WRITE(LU,9001)NPROC1,NPROC2 
D9001 FORMAT("RETURNED FROM NEWPF:NPROC1&2="2I5)
      CALL GETTS(ITSCB,NTSCB,ITIME,ITYPE,INDEX,ICLASS,LSOR,INDTS,KLAST, 
     .ISTKSK,ISTKOP)
      ICHSOR = ICHAR(LSOR,2)
D     IF (INDTS.NE.0)WRITE(LU,9903) INDTS,ITYPE,INDEX,ICLASS,LSOR,KLAST 
D9903 FORMAT("FROM GETTS:"3I10,O8,A2,2X,L1) 
C 
C     2.1 If there's nothing to do (INDTS empty) go try 
C     getting a command from one of the main streams. 
C 
      IF (INDTS.EQ.0) GOTO 300
C 
C     2.2 If the time of a ! command has arrived, unblock 
C     the appropriate command stream. 
C 
220   IF (ICHAR(ITYPE,1).NE.41B) GOTO 230 
      IF (ICHSOR.EQ.73B) KOPBLK = .FALSE. 
      IF (ICHSOR.EQ.72B) KSKBLK = .FALSE. 
      GOTO 200
C 
C     2.3 We do have a time-scheduled function to execute (INDEX non-zero). 
C     First, log the command and then go to process.
C 
230   REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      CALL LOGIT(IBUF,NCHAR,LSOR,LPROCN)
      KTS = .TRUE.
      GOTO 500
C 
C 
C     3. Get a command from the schedule file or from a procedure file. 
C     Check it out, log it, parse it, time-list if necessary, and 
C     block command streams if appropriate.  Finally process. 
C 
300   CALL GETCM(ISTKSK,ISTKOP,LSTKSK,LSTKOP,IDCBP1,IDCBP2,IDCBSK,
     .    KSKBLK,KOPBLK,KHALT,KBREAK,ICLOPR,ICLOP2,IBLEN,IBUF,
     .    NCHAR,LSOR,LPROCS,LPROCO,LPPARM,NCPARM, 
     .    LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,NPROC2,ITMLOG, 
     .    MAXPR1,MAXPR2,IERR,ICURLN,ILSTLN) 
      ICHSOR = ICHAR(LSOR,2)
      IF (ICHSOR.EQ.73B) CALL ICHMV(LPROCN,1,LPROCO,1,12) 
      IF (ICHSOR.EQ.72B) CALL ICHMV(LPROCN,1,LPROCS,1,12) 
C                   Establish the current procedure name
D     WRITE(LU,9701) NCHAR,LSOR,LPROCN,NCPARM,LPPARM,KSKBLK,KOPBLK,   
D    .KHALT,IERR  
D9701  FORMAT("FROM GETCM NCHAR,LSOR,PROC,N,PARM,SK,OPBLK,HALT,IERR: "    
D    .I4,2X,A2,2X,6A2,I3,6A2,2X,3L1,I5)   
      IF (IERR.GE.0) GOTO 310 
      CALL LOGIT(0,0,0,1,-101,2HBO,IERR)
      GOTO 200
C 
C     3.1 If there is no work to do (NCHAR is zero), go to suspend
C     section.  The time to awaken was decided by GETTS already when
C     it passed on to this section. 
C 
310   IF (NCHAR.GT.0) GOTO 320
      IF (LSOR.NE.2H::) GOTO 900
      CALL LOGIT(LDONE,16,LSOR,LPROCN)
      LSKD = 0
      CALL CLOSE(IDCBSK)
      GOTO 900
C 
C     3.2 Log the command.  Parse it. 
C 
320   CALL SPARS(IBUF,1,NCHAR,LNAMES,NNAMES,LPROC1,NPROC1,LPROC2,NPROC2,
     .LPPARM,NCPARM,ITYPE,IERR,ITIME,INDEX,ICLASS)
C*****NOTE***** IBUF IS EXPANDED IF THE PROCEDURE HAS ANY 
C               PARAMETERS.  MAX 100 CHARS.  NCHAR IS MODIFIED. 
C 
D     WRITE(LU,9002) NCHAR,ITYPE,IERR,INDEX,ICLASS
D9002 FORMAT("FROM SPARS: NCHAR,ITYPE,IERR,INDEX,ICLASS=" 
D    .I5,1X,A2,3I5) 
      IF (ICLASS.EQ.0) GOTO 325 
      ICLASS = ICLASS+60000B
C     REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
C     NCHAR = IREG(2) 
325   CALL LOGIT(IBUF,NCHAR,LSOR,LPROCN)
      IF (IERR.EQ.0) GOTO 330 
      CALL LOGIT(0,0,0,0,IERR,2HSP,0) 
      CALL CLRCL(ICLASS)
      GOTO 200
C 
C     3.3 Check out the command.
C     If the command was a comment, we're done now. 
C 
330   KTS = .FALSE. 
      IF (ITYPE.EQ.2H C) GOTO 200 
C 
C     3.4 Handle the time parameters. 
C     If ! command has something after the !, adjust time 
C     parameters wrt reference time.  Do nothing further if the command 
C     was simply !*, otherwise block appropriate command stream.
C     If no time was specified, go to process.
C     If a time was specified, put command into time list.
C 
      ICHAR2 = ICHAR(ITYPE,2) 
      IF (ICHAR(ITYPE,1).NE.41B) GOTO 345 
      IF (ICHAR2.EQ.40B) GOTO 340 
      IF (ICHSOR.EQ.72B) CALL REFTM(ISTREF,ITIME,ICHAR2)
      IF (ICHSOR.EQ.73B) CALL REFTM(IOTREF,ITIME,ICHAR2)
  
      IF (ITIME.EQ.-1) GOTO 200 
340   IF (ICHSOR.EQ.72B) KSKBLK = .TRUE.
      IF (ICHSOR.EQ.73B) KOPBLK = .TRUE.
C 
345   IF ((ITIME.EQ.0.OR.ITIME.EQ.-1).AND.
     .     ITIME(4).EQ.0.AND.ITIME(7).EQ.0) GOTO 500
D     WRITE(LU,9902) ITYPE,INDEX,ICLASS 
D9902 FORMAT("PUTTING INTO ITSCB: "2I10,O8) 
      CALL PUTTS(ITSCB,NTSCB,ITIME,ITYPE,INDEX,ICLASS,LSOR,IERR)
      IF (IERR.LT.0) CALL LOGIT(0,0,0,1,-102,2HBO,ITIME(1)) 
      IF (IERR.LT.0) CALL CLRCL(ICLASS) 
      GOTO 200
C 
C 
C 
C     5. This is the processing section.
C     Sub-sections process the following: 
C                   5.1 Procedure set-up
C                   5.2 Functions - QUIKR segments
C                   5.3 CONT command to undo HALT 
C                   5.4 HALT command to stop schedule stream
C                   5.5 LOG command 
C                   5.6 SCHEDULE command
C                   5.71 XLOG command 
C                   5.72 XDISP command
C                   5.73 ECHO command 
C                   5.74 CHECK command
C                   5.8 FLUSH command 
C                   5.9 BREAK command 
C                   6.0 PROC commandd 
C 
C 
500   IF (ICHAR(ITYPE,2).EQ.106B) GOTO 510
C 
C     5.1 This is the procedure section.
C 
      INDEXP = INDEX
      IF (ICHAR(ITYPE,2).EQ.121B) INDEXP = -INDEXP
C                   Indicate the second list by <0
      IF (ICHSOR.EQ.73B.AND..NOT.KRCUR(ISTKOP,INDEXP)) GOTO 501 
      IF (ICHSOR.EQ.72B.AND..NOT.KRCUR(ISTKSK,INDEXP)) GOTO 501 
C                   Check for recursion -- not allowed
      CALL LOGIT(0,0,0,0,-103,2HBO) 
      GOTO 800
501   REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
C                   Get the command <name>=<parm> 
      ICH = ISCNC(IBUF,1,NCHAR,75B) 
C                               = 
      IF (ICH.EQ.0) GOTO 511
      NCPARM = NCHAR - ICH
      IF (NCPARM.GT.0.AND.NCPARM.LE.12) GOTO 513
      CALL LOGIT(0,0,0,1,-135,2HBO,12)
      GOTO 800
513   CALL ICHMV(LPPARM,1,IBUF,ICH+1,NCPARM)
      GOTO 512
511   NCPARM = 0
      ICH = NCHAR+1 
512   IF (ICHSOR.NE.73B) GOTO 509 
C     Get the operator stream procedure 
      CALL IFILL(LPROCO,1,12,40B) 
      CALL ICHMV(LPROCO,1,IBUF,1,ICH-1) 
      CALL NEWPR(IDCBP1,IDCBP2,ISTKOP,INDEXP, 
     .   LPPARM,NCPARM,LSTKOP,LPROC1,LPROC2,ITMLOG,IBUF,IBLEN,IERR) 
      GOTO 508
C     Get the schedule stream procedure 
509   CALL IFILL(LPROCS,1,12,40B) 
      CALL ICHMV(LPROCS,1,IBUF,1,ICH-1) 
      CALL NEWPR(IDCBP1,IDCBP2,ISTKSK,INDEXP, 
     .   LPPARM,NCPARM,LSTKSK,LPROC1,LPROC2,ITMLOG,IBUF,IBLEN,IERR) 
508   IF (IERR.GE.0) GOTO 800 
      IF (KTS) ICLASS = 0 
      CALL CLRCL(ICLASS)
      IF(KTS) CALL CANTS(ITSCB,NTSCB,5,INDEX,INDTS) 
      GOTO 200
C 
C     Now transfer to the appropriate processing section. 
C 
510   GOTO (520,530,540,550,560,571,572,573,574,990,
     .      580,610,620,590,600,630,640) LNAMES(5,INDEX)
C 
C 
C     5.2 This is the QUIKR processing section. 
C 
520   CONTINUE
      DO 521 I=1,5
        NAMQR(I) = LNAMES(I,INDEX)
521     CONTINUE
      CALL EXEC(9,6HQUIKR ,ICLASS)
      CALL RMPAR(IP)
      IF (IP(3).GE.0) GOTO 525
      IF (KTS) ICLASS=0 
C                   If we got ICLASS from time-scheduling, don't kill 
C                   it here, wait until CANTS 
      CALL LOGIT(0,0,0,0,IP(3),IP(4),IP(5)) 
      CALL CLRCL(ICLASS)
      IF(KTS) CALL CANTS(ITSCB,NTSCB,5,INDEX,INDTS) 
      IF (IP(1).EQ.0) GOTO 200
C                   Don't leave just yet!  See if there is any
C                   message in spite of our error.
525   IF (IP(1).EQ.0) GOTO 800
      DO 526 I=1,IP(2)
        REG = EXEC(21,IP(1),IBUF,-IBLEN*2)
        NCHAR = MIN0(IREG(2),IBLEN*2) 
      CALL LOGIT(IBUF,NCHAR,2H/ ,LPROCN)
526     CONTINUE
      GOTO 800
C 
C     5.3 Handle CONT command.  Set KHALT to false now. 
C 
530   CONTINUE
      KHALT = .FALSE. 
      GOTO 800
C 
C     5.4 This is for the HALT command
C 
540   CONTINUE
      KHALT = .TRUE.
      GOTO 800
C 
C 
C     5.5 This section processes the LOG=xx command.  Similar 
C     to initialization code in BINIT for log files.
C 
550   CONTINUE
      REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      ICH = 1+ISCNC(IBUF,1,NCHAR,75B) 
      IF (ICH.NE.1) GOTO 555
      NCH = ICHMV(IBUF,NCHAR+1,2H/ ,1,1)
      NCH = ICHMV(IBUF,NCH,LLOG,1,2)
      NCH = MCOMA(IBUF,NCH) 
      NCH = NCH+IB2AS(ICRLOG,IBUF,NCH,100000B+5)
      CALL LOGIT(IBUF,NCH-1,LSOR,LPROCN)
      GOTO 800
C                   User requested log name, format response and log it.
555   CALL GTPRM(IBUF,ICH,NCHAR,0,REG)
      LLOG = IREG(1)
      CALL GTPRM(IBUF,ICH,NCHAR,1,REG)
      IF (ICHAR(IREG,1).NE.54B) ICRLOG=IREG 
      CALL NEWLG(IBUF,LSOR) 
C                   Start the new log file
      CALL EXEC(11,ITMLOG,ITMLOG(6))
C                   Record the time the new log was started 
      GO TO 800 
C 
C     5.6 SCHEDULE command section. 
C 
560   CONTINUE
      REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      ICH = 1+ISCNC(IBUF,1,NCHAR,75B) 
      IF (ICH.NE.1) GOTO 566
      NCH = ICHMV(IBUF,NCHAR+1,2H/ ,1,1)
      NCH = ICHMV(IBUF,NCH,LSKD,1,2)
      NCH = MCOMA(IBUF,NCH) 
      CALL LOCF(IDCBSK,IERR,IREC) 
      IF (IERR.LT.0) IREC=0 
      NCH = NCH+IB2AS(IREC,IBUF,NCH,100000B+5)
      CALL LOGIT(IBUF,NCH-1,LSOR,LPROCN)
      GOTO 800
C                   User requested schedule name, format response and log it. 
566   CALL GTPRM(IBUF,ICH,NCHAR,0,REG)
      LSKD = 0
      NPROC1 = 0
      ISTKSK(2) = 2 
      LSTKSK(2) = 2 
      CALL CANTS(ITSCB,NTSCB,4,0,0) 
      CALL CANTS(ITSCB,NTSCB,2,0,0) 
C                   Initialize, if we've got this far we must be
C                   a valid schedule or all is set to zero. 
D     WRITE(LU,9401) ICH,NCHAR,IREG 
D9401 FORMAT("FROM GTPRM ICH,NCHAR,IREG: "2I5,1X,2A2) 
      LNAMEF(1) = 2H[S
      LNAMEF(2) = 2HKD
      LNAMEF(3) = IREG(1) 
      CALL OPEN(IDCBSK,IERR,LNAMEF,1,0,ICRPRC)
D     WRITE(LU,9402) LNAMEF,ICRPRC
D9402 FORMAT("OPENING "3A2,I6)
      IF (IERR.GE.0) GOTO 561 
      CALL LOGIT(0,0,0,1,-105,2HBO,IERR)
      GOTO 800
561   CALL NEWSK(IBUF,ICH,NCHAR,IDCBSK,IBLEN,IERR,ICURLN,ILSTLN)
      IF (IERR.NE.0) GOTO 800 
569   KSKBLK = .FALSE.
      KHALT = .FALSE. 
      CALL OPNPF(LNAMEF(3),IDCBP1,IBUF,IBLEN,ICRPRC,LPROC1,MAXPR1,
     .NPROC1,IERR)
      IF (IERR.LT.0) CALL LOGIT(0,0,0,1,-131,2HBO,IERR) 
      LSKD = LNAMEF(3)
      IF (LSKD.NE.LPRC) GOTO 562
C     If schedule and station same name, re-establish original station library(XX)
      CALL ICHMV(IBUF,1,7HPROC=XX,1,7)
      CALL EXEC(20,0,IBUF,-7,2HFS,IGID(0),ICLOPR) 
562   IF (LLOG.EQ.LSKD) GOTO 800
      LLOG = LSKD 
      CALL NEWLG(IBUF,LSOR) 
      GOTO 800
C 
C 
C     5.70 Commands which set switches
C 
C     5.71 XLOG command 
571   ICMD = 571
      GOTO 579
C 
C     5.72 ECHO command 
572   ICMD = 572
      GOTO 579
C 
C     5.73 XDISP command
573   ICMD=573
      GOTO 579
C 
574   CONTINUE
C 
579   REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      ICH = 1+ISCNC(IBUF,1,NCHAR,75B) 
      IF (ICH.NE.1) GOTO 5792 
      IERR = -1 
      GOTO 5799 
5792  IX = 99 
      IF (ICHCM(IBUF,ICH,2HON,1,2).EQ.0) IX = -1
      IF (ICHCM(IBUF,ICH,3HOFF,1,3).EQ.0) IX = 0
      IF (IX.NE.99) GOTO 5793 
      IERR = -2 
      GOTO 5799 
5793  KX=.FALSE.
      IF (IX.EQ.-1) KX=.TRUE. 
      IF (ICMD.EQ.571) KXLOG=KX 
      IF (ICMD.EQ.572) KXDISP=KX
      IF (ICMD.EQ.573) KECHO=KX 
      IF (ICMD.EQ.574) KCHECK=KX
      GOTO 800
5799  IF (IERR.EQ.-1) CALL LOGIT(0,0,0,0,-107,2HBO,0) 
      IF (IERR.EQ.-2) CALL LOGIT(0,0,0,0,-108,2HBO,0) 
      GOTO 800
C 
C 
C     5.8 FLUSH command to clear out the operator stream completely.
C     Reinitialize everything.
C 
580   CONTINUE
581   REG = EXEC(21,ICLOP2+120000B,IBUF,-IBLEN*2) 
      IF (IREG.LT.0) GOTO 582 
      NCHAR = IFLCH(IBUF,MIN0(IREG(2),IBLEN*2)) 
      CALL EXEC(2,LU,IBUF,-NCHAR) 
      GOTO 581
582   ISTKOP(2) = 2 
      LSTKOP(2) = 2 
      KOPBLK = .FALSE.
      CALL CANTS(ITSCB,NTSCB,3,0,0) 
      GOTO 800
C 
C 
C     5.9 BREAK command sets the variable KBREAK to true. 
C     This is passed to GETCM, thence to READP, and the 
C     "end of a procedure" condition is forced. 
C     Set this flag only if there's a procedure to be broken. 
C     Otherwise, no effect. 
C 
590   IF (ISTKOP(2).GT.2.OR.ISTKSK(2).GT.2) KBREAK = .TRUE. 
      GOTO 800
C 
C 
C     6.0 PROC command: new station procedure library 
C 
600   CONTINUE
      REG = EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      ICH = 1+ISCNC(IBUF,1,NCHAR,75B) 
      IF (ICH.NE.1) GOTO 605
      NCH = ICHMV(IBUF,NCHAR+1,2H/ ,1,1)
      NCH = ICHMV(IBUF,NCH,LPRC,1,2)
      CALL LOGIT(IBUF,NCH-1,LSOR,LPROCN)
      GOTO 800
C                   User requested proc name, format response and log it. 
605   CALL GTPRM(IBUF,ICH,NCHAR,0,REG)
      IF (.NOT.KSTAK(ISTKOP,ISTKSK,2)) GOTO 606 
      CALL LOGIT(0,0,0,0,-133,2HBO,0) 
      GOTO 800
606   IF (IREG(1).NE.LSKD) GOTO 607 
      CALL LOGIT(0,0,0,0,-136,2HBO,0) 
      GOTO 800
607   IF (LPRC.NE.IREG(1)) CALL CANTS(ITSCB,NTSCB,1,0,0)
C                   Cancel procs from the old library 
      LPRC = IREG(1)
      CALL OPNPF(LPRC,IDCBP2,IBUF,IBLEN,ICRPRC,LPROC2,MAXPR2,NPROC2,
     .IERR) 
      IF (IERR.EQ.0) GOTO 800 
      CALL LOGIT(0,0,0,1,-131,2HBO,IERR)
      LPRC = 0
      NPROC2 = 0
      GOTO 800
C 
C 
C     6.1 Section handling SY messages
C 
610   CONTINUE
      NCH = ISCNC(IBUF,1,NCHAR,75B) 
C                               = 
      IF (NCH.EQ.0) GOTO 800
      NCH = ICHMV(IBUF,1,IBUF,NCH+1,NCHAR-NCH)-1
      NCHAR = -MESSS(IBUF,NCH)
      IF (NCHAR.GT.0) CALL LOGIT(IBUF,NCHAR,2H/ ,LPROCN)
      GOTO 800
C 
C     6.2 Section to handle TS command to list time list
C 
620   CONTINUE
      CALL IFILL(IBUF,1,IBLEN*2,40B)
      DO 621 I=1,NTSCB
        IF (ITSCB(1,I).EQ.-1) GOTO 621
        CALL ICHMV(IBUF,1,ITSCB(10,I),1,2)
C                     First the type
        IF (ICHAR(IBUF,1).EQ.0) CALL ICHMV(IBUF,1,2H  ,1,1) 
        IF (ICHAR(IBUF,2).EQ.0) CALL ICHMV(IBUF,2,2H  ,1,1) 
        CALL ICHMV(IBUF,3,ITSCB(13,I),2,1)
C                     Next the source of the command
        CALL IB2AS(ITSCB(11,I),IBUF,4,2)
C                     The index in the function or proc lists 
        CALL ICHMV(IBUF,6,2H@ ,1,1) 
        CALL IB2AS(MOD(ITSCB(1,I),1024),IBUF,7,40000B+400B*3+3) 
        CALL IB2AS(ITSCB(2,I)/60,IBUF,10,40000B+400B*2+2) 
        CALL IB2AS(MOD(ITSCB(2,I),60),IBUF,12,40000B+400B*2+2)
        CALL IB2AS(ITSCB(3,I)/100,IBUF,14,40000B+400B*2+2)
C                     The time next scheduled 
        ICL = ITSCB(12,I) 
        NCH = 0 
        IF (ICL.EQ.0) GOTO 622
        REG = EXEC(21,ICL,IBUF(9),IBLEN-9)
        NCH = IREG(2) 
C                     Get the buffer in the class 
622     CALL LOGIT(IBUF,MIN0(16+NCH,IBLEN*2),LSOR,LPROCN) 
621     CONTINUE
      GOTO 800
C 
C     6.3  LIST Command.
C 
630   CONTINUE
      REG=EXEC(21,ICLASS,IBUF,-IBLEN*2) 
      NCHAR=MIN0(IREG(2),IBLEN*2) 
      IF(LSKD.NE.0)GOTO 631 
        CALL EXEC(2,LU,LM1,-28) 
        GO TO 800 
631   CALL LISTS(LU,IDCBSK,IBUF,NCHAR,ICURLN) 
      GO TO 800 
C 
C     6.4  STATUS Command.
C 
640   CONTINUE
      IF(LSKD.NE.0)GOTO 641 
        CALL EXEC(2,LU,LM1,-28) 
        GO TO 800 
641   CALL STAT(IBUF,LU,KHALT,KOPBLK,KSKBLK,ICURLN,IDCBSK,
     .ITSCB,NTSCB,LSKD) 
      GO TO 800 
C 
C     8. All working sections end up here.
C     Clear out class buffer now, if any, if this is not a
C     time-scheduled command (KTS FALSE)
C     Cancel this time-scheduled command if it is the last time for it. 
C     (KTS TRUE and KLAST TRUE) 
C     Return to time-scheduling check before suspending.
C 
800   IF (.NOT.KTS) CALL CLRCL(ICLASS)
      IF (KTS.AND.KLAST) CALL CANTS(ITSCB,NTSCB,5,INDEX,INDTS)
      IERR = 0
      GOTO 200
C 
C 
C     9. We are going to self-suspend until there is
C     something interesting to do.
C 
900   CONTINUE
      CALL NEWPF(IDCBP1,IDCBP2,LPROC1,MAXPR1,NPROC1,LPROC2,MAXPR2,
     .NPROC2,IBUF,IBLEN,ISTKOP,ISTKSK)
C                     Check one last time to see if perchance the stacks were 
C                     flushed with the last call to GETCM 
      CALL GETTS(ITSCB,NTSCB,ITIME,ITYPE,INDEX,ICLASS,LSOR,INDTS,KLAST, 
     .ISTKSK,ISTKOP)
      ICHSOR = ICHAR(LSOR,2)
C                     Also, check one last time for time-scheduled
C                     procs for the same reason 
      IF (INDTS.NE.0) GOTO 220
C                     Jump back into the command loop if there's
C                     something to do.  Not very elegant! 
      IH = MOD(ITIME(2)/60,24)
      IM = MOD(ITIME(2),60) 
      IS = ITIME(3)/100 
      IMS = MOD(ITIME(3),100) 
      INEXT(1) = IH 
      INEXT(2) = IM 
      INEXT(3) = IS 
      CALL EXEC(12,6HBOSS  ,1,99,IH,IM,IS,IMS)
C                   Put ourselves on the time list repeatedly, in case
C                   the IH,IM,IS is, by now due to our dallying, in the past. 
C                   We will be woken up sometime in the near future.
      IT(5) = 0 
      IF (KPAST(ITIME(1),ITIME(2),ITIME(3),IT)) GOTO 200
C                   But, just to be sure, check that the IH,IM,IS 
C                   is not in the past right now. 
      REG = 0.0 
      REG = EXEC(6,0,1) 
C                   Self-suspend, saving our suspension point 
C******************************************************************** 
C***************THIS IS THE WAKE-UP POINT**************************** 
C******************************************************************** 
C 
      CALL RMPAR(IP)
      IF (IREG(2).EQ.0) GOTO 200
C                   We have been awakened by our own wake-up call.
C                   Go to the time-scheduled block and check for
C                   something to do.
      IF (IP(1).EQ.2HOP) GOTO 200 
C                   We have been awakened by OPRIN.  The command is in
C                   a class buffer.  Go to time-schedule block and
C                   check that first, just as a matter of principle.
      IF (IP(1).EQ.2HPF) GOTO 200 
C                     We have been nudged by PFMED.  There must be
C                     a new procedure file ready for us.
C                     The usual route through the logic does it all.
      REG = EXEC(21,IP(2),IBUF,-IBLEN*2)
      NCHAR = MIN0(IREG(2),IBLEN*2) 
      CALL LOGIT(IBUF,NCHAR,2H/ ,LPROCN)
C                   This is a pre-formatted log entry.
C                   Log this as a response. 
      GOTO 200
C                   Then go check what else there is to do. 
C 
990   CALL CLOSE(IDCBSK)
      CALL CLOSE(IDCBP1)
      CALL CLOSE(IDCBP2)
      CALL CLRCL(ICLASS)
      CALL CLRCL(ICLOPR)
      CALL CLRCL(ICLOP2)
      CALL LOGIT(LEND,16,2H::,LPROCN) 
C 
C               NOW TERMINATE OPRIN (gracefully ?!) 
C 
        CALL EXEC(24,6HOPRIN ,LU,LU)
C 
      RETURN
      END 
