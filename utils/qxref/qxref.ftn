ftn77,L 
$files 0,3,1,11 
  
c***jims changes <860219.1125>
c  inserted $EMA /FREEEMA/ before every module
c  created new common freeema just for free, left other variables in free 
c  changed limem to vmast 
c  changed next initialization to next=0
c  multiplied freespace by 1000 to get it into words from pages 
  
  
$EMA /FREEEMA/
      program qxref(4,90),24999-16407 REV.2434 840820 
      implicit none 
  
*  NAME:    QXREF 
*  SOURCE:  24999-18407 
*  RELOC:   24999-16407 
*  PGMR:    B.G.
  
*  History of revisions 
*  Rev.2434  840820 - dhp 
*     Fixed the 'END without NAM' bug 
*     Added rev code info to the usage help message.
*     Increased file name size from 30 characters to 64 for new file system 
  
  
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      common /name/ name,name_len 
      character*16 name 
      common /record/ record(128) 
      integer record
      character record_s*256
      equivalence (record,record_s) 
  
      integer free,next,last,lgbuf_buffer(128)
  
      integer name_len,type,subtype,length,pnum,rcpar,itype 
  
      integer out_file_pos,ios,i,j,allocate,level,sym_level 
  
      integer*4 prog_sz,com_sz,bp_sz,save_sz,code_sz,ema_sz,rec_ema_sz
      character out_name*64,parameter*64,time*30,date_time*30 
      character mname*21,ename*33,uname*16
      equivalence (record(4),rec_ema_sz)
      logical command_file,search,ldum,skip,block_data
      logical scan,init_scan,more,first_file
      integer input_lu,pntr,temp,loc,nam_pntr,warn_count
      common /input/input_lu
      common /output/ out_name
      integer section,end,nam,alloc,ent,ext,width,sequence
      parameter (end=0,nam=1,alloc=2,ent=3,ext=4) 
      common /width/ width
      integer max_nams,refnam,refseq,word,bit,back,clen,cpos
      parameter (max_nams=1500) 
      integer bitmap(0:max_nams/16) 
      logical ent_head,common_head,undef_head 
      logical backward_ref,circular_ref 
      integer n_modules,n_entries,n_common,n_undef
      integer loglu,crt 
      data prog_sz,com_sz,bp_sz,save_sz,code_sz,ema_sz / 6*0 /
      data sequence,warn_count / 2*0 /
      data ent_head,common_head,undef_head / 3*.false. /
      data backward_ref,circular_ref / 2*.false. /
      data n_modules,n_entries,n_common,n_undef / 4*0 / 
      data first_file / .true. /
  
      crt = loglu(crt)
      width = 78
      call lgbuf(lgbuf_buffer,128)
  
*  If no parameters, tell the user how to run it. 
  
      if (rcpar(1,parameter).eq.0) then 
          write(1,1)
    1 format(/45x'Rev.2434'/'To run QXREF:'// 
     .  '    :QXREF,<namr1>,<namr2>,...,<last namr>'//
     .  'where each namr is an output file name, a relocatable file'/ 
     .  'name, or a command file name.  Only one output file allowed.'/ 
     .  'The files are distinguished as follows:'// 
     .  '    Output file:  LU or first char is '' or "'/
     .  '    Relocatable:  type 5 file'/
     .  '    Command file: all others'//
     .  'Command files have a list of file names, as for MERGE.'//
     .  'Example:'//
     .  '    :qxref,$mlib1,"map::xx,%myfil,=comnd::50'/)
          call exit 
      endif 
  
*  Set up the access to freespace.
  
      call init 
  
*  Search for output file name.  If none found, leave it LU 1.
  
      pnum = 1
      out_file_pos = 0
      out_name = '1'
      do while (rcpar(pnum,parameter).ne.0) 
          if (parameter(1:1).eq.'"' .or. parameter(1:1).eq.'''' .or.
     .        parameter(1:1).ge.'0' .and.parameter(1:1).le.'9') then
              if (out_file_pos.ne.0) then 
                  stop 'Multiple output file names.'
              else
                  out_name = parameter
                  call uppercase(out_name)
                  out_file_pos = pnum 
              endif 
          endif 
          pnum = pnum + 1 
      end do
      open(2000,file=out_name,bufsiz=2) 
      date_time = time()
      write(2000,*) 'QXREF object code cross-reference  ', date_time
      write(2000,'(1x,63(''-'')/)') 
  
*  Scan thru parameters.  Anything not type 5 assumed to be a command file. 
  
      pnum = 1
      do while (rcpar(pnum,parameter).ne.0) 
          if (pnum.ne.out_file_pos) then
              open(1000,file=parameter,bufsiz=1)
              if (itype(1000).eq.5) then
                  close(1000) 
                  command_file = .false.
              else
                  read(1000,'(a)') parameter
                  call uppercase(parameter) 
                  command_file = .true. 
              endif 
  
*  Open current input file. 
  
   10         if (first_file) then
                  first_file = .false.
              else
                  write(2000,'(//)')
              endif 
              write(2000,*) '>>> File: ', parameter 
              open(3000,file=parameter,bufsiz=8)
              input_lu = 3000 
              if (itype(3000).ne.5) stop 'Not type 5: ' // parameter
              section = end 
  
*  Skip until we get a new record; check for NAM, ALLOC, ENT, EXT, END. 
  
   20         call break_check
              call read(record,length,type,subtype,*99) 
              call newrec(record,length,type,subtype) 
              if (type.ne.7 .or. (skip .and. subtype.ne.5)) goto 20 
              skip = .false.
  
*  NAM. Get & print name, type, priority, and sizes; update sizes.
  
              if (subtype.eq.1) then
      if (section.eq.end) then
          section = nam 
      else
          stop 'Record out of sequence: missing END record.'
      endif 
      call get_name(25) 
      write(2000,*) 
      call init_out(3,' ')
      call out(name(1:name_len))
      call tack(',',record(10)+0j)
      if (record(11).ne.0)
     .    call tack(',',record(11)+0j)
      call tab(21)
      clen = ibits(record(25),8,8)*2
      cpos = ibits(record(25),0,8)*2 + 51 
      if (clen.ne.0) then 
          call out('   '//record_s(cpos:cpos+clen-1)) 
          call flush
          if ((record(4).or.record(5).or.record(6).or.record(7).or. 
     .        record(8).or.record(9).or.record(18)).ne.0) then
              call init_out(3,' ')
              call tab(21)
          endif 
      endif 
      call tack('   prog: ',record(7)+0j) 
      call tack('   com: ',record(9)+0j)
      call tack('   bp: ',record(8)+0j) 
      call tack('   save: ',record(6)+0j) 
      call tack('   code: ',record(18)+0j)
      call tack('   ema: ',rec_ema_sz)
      call flush
      prog_sz = prog_sz + record(7) 
      com_sz = com_sz + record(9) 
      bp_sz = bp_sz + record(8) 
      save_sz = save_sz + record(6) 
      code_sz = code_sz + record(18)
      ema_sz = ema_sz + rec_ema_sz
      section = nam 
      if (search(loc,.true.,.false.)) then
          write(2000,*) '*** Duplicate NAM, above module skipped.'
          warn_count = warn_count + 1 
          skip = .true. 
      else
          sequence = sequence + 1 
          if (sequence.ge.max_nams) stop 'Too many modules.'
          free(loc+2) = sequence
          free(loc+3) = 1 
          nam_pntr = loc
          block_data = btest(record(10),9)
      endif 
  
*  ALLOC. Get name & size.
  
              else if (subtype.eq.9) then 
      if (section.eq.nam) then
          section = alloc 
          call init_out(24,'lcom:') 
      else if (section.ne.alloc) then 
          stop 'Record out of order: ALLOC does not follow NAM.'
      endif 
      pntr = 4
      do while (pntr.lt.length) 
          temp = record(pntr+3) 
          record(pntr+3) = record(pntr+1) 
          call get_name(pntr+3) 
          record(pntr+3) = temp 
          temp = ibits(record(pntr),11,2) 
          if (temp.eq.1) then 
              call tack(' '//name(1:name_len)//'/s/',record(pntr+2))
          else if (temp.eq.2) then
              call tack(' '//name(1:name_len)//'/e/',record(pntr+2))
          else
              call tack(' '//name(1:name_len)//'/',  record(pntr+2))
          endif 
  
          if (search(loc,.false.,.true.)) then
              if (btest(free(loc+4),14)) then 
                  if (record(pntr+2).ne.free(loc-2) .or.
     .                record(pntr+3).ne.free(loc-1)) then 
                      write(2000,*) '*** Labelled common size ',
     .                    'mismatch: ', name(1:name_len)
                      warn_count = warn_count + 1 
                  endif 
              else
                  write(2000,*) '*** Labelled common matches ', 
     .                'ENT or EXT: ', name(1:name_len)
                  warn_count = warn_count + 1 
              endif 
          else
              free(loc+4) = ibset(free(loc+4),14) 
              free(loc-2) = record(pntr+2)
              free(loc-1) = record(pntr+3)
          endif 
  
          if (block_data) then
              if (free(loc+2).ne.0) then
                  write(2000,*) '*** Common block in more than one block
     . data: ' // name(1:name_len)
                  warn_count = warn_count + 1 
              else
                  free(loc+2) = nam_pntr
                  free(loc+1) = free(nam_pntr+1)
                  free(nam_pntr+1) = loc
              endif 
          else
              temp = allocate(2)
              free(temp) = free(loc+3)
              free(loc+3) = temp
              free(temp+1) = nam_pntr 
          endif 
          pntr = pntr + 4 + ibits(record(pntr+1),8,8) 
     .                    + ibits(record(pntr+1),0,8) 
      end do
  
*  ENT. Get name. 
  
              else if (subtype.eq.2) then 
      if (section.lt.ent) then
          section = ent 
          call flush
          call init_out(24,'ents:') 
      else if (section.ne.ent) then 
          stop 'Record out of order: ENT.'
      endif 
      pntr = 4
      do while (pntr.lt.length) 
          call get_name(pntr+3) 
          call out(' '//name(1:name_len)) 
  
          if (search(loc,.false.,.false.)) then 
              if (btest(free(loc+4),14)) then 
                  write(2000,*) '*** ENT matches labelled common: ',
     .                          name(1:name_len)
                  warn_count = warn_count + 1 
              endif 
          endif 
  
          if (free(loc+2).ne.0) then
              write(2000,*) '*** Duplicate ENT: ' // name(1:name_len) 
              warn_count = warn_count + 1 
          else
              free(loc+2) = nam_pntr
              free(loc+1) = free(nam_pntr+1)
              free(nam_pntr+1) = loc
          endif 
          pntr = pntr + 4 + ibits(record(pntr+3),8,8) 
     .                    + ibits(record(pntr+3),0,8) 
      end do
  
*  EXT. Get name. 
  
              else if (subtype.eq.4) then 
      if (section.lt.ext) then
          section = ext 
          call flush
          call init_out(24,'exts:') 
      else if (section.ne.ext) then 
          stop 'Record out of order: EXT.'
      endif 
      pntr = 4
      do while (pntr.lt.length) 
          call get_name(pntr+1) 
          call out(' '//name(1:name_len)) 
  
          if (search(loc,.false.,.false.)) then 
              if (btest(free(loc+4),14)) then 
                  write(2000,*) '*** EXT matches labelled common: ',
     .                          name(1:name_len)
                  warn_count = warn_count + 1 
              endif 
          endif 
          temp = allocate(2)
          free(temp) = free(loc+3)
          free(loc+3) = temp
          free(temp+1) = nam_pntr 
          pntr = pntr + 2 + ibits(record(pntr+1),8,8) 
     .                    + ibits(record(pntr+1),0,8) 
      end do
  
*  END.  Flush image buffer.
  
              else if (subtype.eq.5) then 
      if (section.ne.end) then
          section = end 
      else
          stop 'Record out of sequence: END without matching NAM.'
      endif 
      call flush
              endif 
      goto 20 
  
*  Get next file name.
  
   99         if (command_file) then
                  close(3000) 
                  read(1000,'(a)',end=98) parameter 
                  call uppercase(parameter) 
                  goto 10 
              endif 
          endif 
   98     pnum = pnum + 1 
      end do
  
*  Write size summary.
  
      write(2000,'(/1x,75(''*''))') 
      call init_out(2,'Size totals:') 
      call tack('   prog: ',prog_sz)
      call tack('   com: ',com_sz)
      call tack('   bp: ',bp_sz)
      call tack('   save: ',save_sz)
      call tack('   code: ',code_sz)
      call tack('   ema: ',ema_sz)
      call flush
      write(2000,'(1x,75(''*''))')
  
*  Compute level numbers. 
  
      ldum = init_scan(.false.) 
      do while (scan(loc))
          if (free(loc+3).ne.0) then
              if (free(loc+2).ne.0) free(free(loc+2)+3) = 0 
          endif 
      end do
  
      more = .true. 
      level = 2 
      do while (more) 
          more = .false.
          ldum = init_scan(.false.) 
          do while (scan(loc))
              nam_pntr = free(loc+2)
              if (nam_pntr.ne.0) then 
                  temp = free(loc+3)
                  do while (temp.ne.0)
                      sym_level = free(free(temp+1)+3)
                      if (sym_level.eq.level-1) then
                          free(nam_pntr+3) = level
                          more = .true. 
                          temp = free(temp) 
                      else if (sym_level.eq.0) then 
                          free(nam_pntr+3) = 0
                          temp = 0
                      else
                          temp = free(temp) 
                      endif 
                  end do
              endif 
          end do
          level = level + 1 
      end do
  
*  Write module cross-reference.
  
      call break_check
      call eject              
      write(2000,*) 'Module         Level  Referenced by' 
      write(2000,*) '------         -----  -------------' 
      write(2000,*) 
      ldum = init_scan(.true.)
      do while (scan(nam_pntr)) 
          call break_check
          call fetch_name(nam_pntr) 
          mname(1:16) = name
          level = free(nam_pntr+3)
          if (level.eq.0) then
              mname(17:21) = '***  '
              circular_ref = .true. 
          else
              write(mname(17:21),'(i3)') level
          endif 
  
*  First pass this name... reverse reference lists. 
  
          loc = free(nam_pntr+1)
          do while (loc.ne.0) 
              temp = free(loc+3)
              back = 0
              do while (temp.ne.0)
                  i = free(temp)
                  free(temp) = back 
                  back = temp 
                  temp = i
              end do
              free(loc+3) = back
              loc = free(loc+1) 
          end do
  
*  Output references for this name.  Use bitmap to avoid dups.
  
          do i=0,sequence/16
              bitmap(i) = 0       ! Duplicate entry flags.
          end do
  
          call init_out(2,mname)
          n_modules = n_modules + 1 
          loc = free(nam_pntr+1)
          do while (loc.ne.0) 
              temp = free(loc+3)
              do while (temp.ne.0)
                  refnam = free(temp+1) 
                  refseq = free(refnam+2) 
                  word = ibits(refseq,4,12) 
                  bit = ibits(refseq,0,4) 
                  if (.not.btest(bitmap(word),bit)) then
                      bitmap(word) = ibset(bitmap(word),bit)
                      call fetch_name(refnam) 
                      if (free(nam_pntr+2).gt.refseq) then
                          call out(' '//name(1:name_len)) 
                      else
                          call out(' '//name(1:name_len)//'*')
                          backward_ref = .true. 
                      endif 
                  endif 
                  temp = free(temp) 
              end do
              loc = free(loc+1) 
          end do
          call flush
      end do
      if (backward_ref) then
          write(2000,*) '*** Backward references (*).'
          warn_count = warn_count + 1 
      endif 
      if (circular_ref) then
          write(2000,*) '*** Circular references (***).'
          warn_count = warn_count + 1 
      endif 
  
*  Write defined entry cross-reference. 
  
      ename(17:17) = ' '
      ldum = init_scan(.false.) 
      do while (scan(loc))
          if (.not.btest(free(loc+4),14) .and. free(loc+2).ne.0) then 
              call break_check
              if (.not.ent_head) then 
                  call eject            
                  write(2000,*) 
     .             'Entry            Defined in       Referenced by'
                  write(2000,*) 
     .             '-----            ----------       -------------'
                  write(2000,*) 
                  ent_head = .true. 
              endif 
              call fetch_name(loc)
              ename(1:16) = name
              nam_pntr = free(loc+2)
              call fetch_name(nam_pntr) 
              ename(18:33) = name 
              call init_out(2,ename)
              n_entries = n_entries + 1 
  
*  Output references for this entry.  Use bitmap to avoid duplicates. 
  
              do i=0,sequence/16
                  bitmap(i) = 0       ! Duplicate entry flags.
              end do
              temp = free(loc+3)
              do while (temp.ne.0)
                  refnam = free(temp+1) 
                  refseq = free(refnam+2) 
                  word = ibits(refseq,4,12) 
                  bit = ibits(refseq,0,4) 
                  if (.not.btest(bitmap(word),bit)) then
                      bitmap(word) = ibset(bitmap(word),bit)
                      call fetch_name(refnam) 
                      if (free(nam_pntr+2).gt.refseq) then
                          call out(' '//name(1:name_len)) 
                      else
                          call out(' '//name(1:name_len)//'*')
                      endif 
                  endif 
                  temp = free(temp) 
              end do
              call flush
          endif 
      end do
  
*  Write labelled common cross-reference. 
  
      ename(17:17) = ' '
      ldum = init_scan(.false.) 
      do while (scan(loc))
          if (btest(free(loc+4),14)) then 
              call break_check
              if (.not.common_head) then
                  call eject
                  write(2000,*) 
     .             'Common block     Defined in       Referenced by'
                  write(2000,*) 
     .             '------------     ----------       -------------'
                  write(2000,*) 
                  common_head = .true.
              endif 
              call fetch_name(loc)
              ename(1:16) = name
              nam_pntr = free(loc+2)
              if (nam_pntr.ne.0) then 
                  call fetch_name(nam_pntr) 
                  ename(18:33) = name 
              else
                  ename(18:33) = ' '
              endif 
              call init_out(2,ename)
              n_common = n_common + 1 
  
*  Output references for this block.  Use bitmap to avoid duplicates. 
  
              do i=0,sequence/16
                  bitmap(i) = 0       ! Duplicate entry flags.
              end do
              temp = free(loc+3)
              do while (temp.ne.0)
                  refnam = free(temp+1) 
                  refseq = free(refnam+2) 
                  word = ibits(refseq,4,12) 
                  bit = ibits(refseq,0,4) 
                  if (.not.btest(bitmap(word),bit)) then
                      bitmap(word) = ibset(bitmap(word),bit)
                      call fetch_name(refnam) 
                      call out(' '//name(1:name_len)) 
                  endif 
                  temp = free(temp) 
              end do
              call flush
          endif 
      end do
  
*  Write undefined external cross-reference.
  
      ldum = init_scan(.false.) 
      do while (scan(loc))
          if (.not.btest(free(loc+4),14) .and. free(loc+2).eq.0) then 
              call break_check
              if (.not.undef_head) then 
                  call eject
                  write(2000,*) 'Undef External   Referenced by'
                  write(2000,*) '--------------   -------------'
                  write(2000,*) 
                  undef_head = .true. 
              endif 
              call fetch_name(loc)
              uname(1:16) = name
              call init_out(2,uname)
              n_undef = n_undef + 1 
  
*  Output references for this entry.  Use bitmap to avoid duplicates. 
  
              do i=0,sequence/16
                  bitmap(i) = 0       ! Duplicate entry flags.
              end do
              temp = free(loc+3)
              do while (temp.ne.0)
                  refnam = free(temp+1) 
                  refseq = free(refnam+2) 
                  word = ibits(refseq,4,12) 
                  bit = ibits(refseq,0,4) 
                  if (.not.btest(bitmap(word),bit)) then
                      bitmap(word) = ibset(bitmap(word),bit)
                      call fetch_name(refnam) 
                      call out(' '//name(1:name_len)) 
                  endif 
                  temp = free(temp) 
              end do
              call flush
          endif 
      end do
  
      write(2000,*) 
      write(2000,*) n_modules, ' modules, ',
     .              n_entries, ' entries, ',
     .              n_common,  ' common blocks, ',
     .              n_undef,   ' undefined externals.'
      if (warn_count.ne.0) write(2000,*) warn_count, ' warnings.' 
      if (out_name.ne.'1') then 
          call eject
          write(crt,*)
          write(crt,*) n_modules, ' modules, ', 
     .               n_entries, ' entries, ', 
     .               n_common,  ' common blocks, ', 
     .               n_undef,   ' undefined externals.' 
          if (warn_count.ne.0) write(crt,*) warn_count, ' warnings.'
      endif 
  
      end 
  
      subroutine break_check
     .,24999-16407 REV.2220 820518
      implicit none 
      logical ifbrk 
  
*     BREAK_CHECK checks for a break, and terminates QXREF if so. 
  
      if (ifbrk()) stop 'Break acknowledged.' 
  
      end 
  
      subroutine read(record,length,type,subtype,*) 
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     READ reads a relocatable record and returns:
*       length:  in words 
*       type:    main type; new records = 7 
*       subtype: only useful for new records. 
* 
*     the alternate return is taken on EOF. 
  
      integer record(0:127),length,type,subtype,itlog,ios,input_lu
      common/input/ input_lu
  
    5 read(input_lu,end=99,err=10,iostat=ios) record
   10 if (ios.ne.0 .and. ios.ne.496) stop 'I/O error.'
      length = (itlog()+1)/2
      if (length.eq.0) goto 5 
      if (ibits(record(0),8,8).ne.length) stop 'Length error.'
      type = ibits(record(1),13,3)
      subtype = ibits(record(1),6,7)
      return
  
   99 return 1
      end 
  
$alias iaddr='.DRCT',direct 
$EMA /FREEEMA/
      subroutine init 
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     INIT sets up the indices into the freespace access array FREE 
*     to point to the first and last words of freespace.
  
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      integer free,next,last,iaddr,fwa,freesize 
  
      INTEGER IVMA
  
*     Compute subscript for FREE which points to freespace. 
  
c     call limem(1,fwa,freesize)
      call vmast(ivma,freesize) 
      freesize = freesize*1000
C 
C     next = fwa - iaddr(free)
      next = 1
      last = next + freesize - 1
      WRITE (1,*) NEXT, FREESIZE
  
      end 
  
      subroutine get_name(pntr) 
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     GET_NAME gets a name from a (new) relocatable 
*     record. 
* 
*       pntr:  index into RECORD of the length word before symbol.
  
      common /name/ name,name_len 
      character*16 name   
      integer name_len,name_w(8)
      equivalence (name,name_w) 
      common /record/ record(128) 
      integer record
      integer words,i,last,pntr 
  
      words = ibits(record(pntr),0,8) 
      if (words.gt.8 .or. words.eq.0) stop 'Illegal symbol length.' 
      name = '                ' 
      do i=1,words
          name_w(i) = record(pntr+i)
      end do
      last = ibits(name_w(words),0,8) 
      if (last.eq.0 .or. last.eq.40B) then
          name_len = words*2 - 1
      else
          name_len = words*2
      endif 
  
      end 
  
$EMA /FREEEMA/
      subroutine fetch_name(loc)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     FETCH_NAME gets the name from the specified table entry 
*     and copies it to NAME, blank-filling to 16 characters,
*     and puts its length in characters into NAME_LEN.
  
      integer loc,i 
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      integer free,next,last
  
      common /name/ name,name_len 
      integer name_len,name_w(8)
      character*16 name 
      equivalence (name,name_w) 
  
      name = '                ' 
      name_len = (free(loc+4).and.17B)+1
  
      do i=1,(name_len+1)/2 
          name_w(i) = free(loc+4+i) 
      end do
  
      end 
  
      subroutine uppercase(c) 
     .,24999-16407 REV.2220 820518
      character c*(*) 
  
      do i=1,len(c) 
          if (c(i:i).ge.'a' .and. c(i:i).le.'z')
     .        c(i:i) = char(ichar(c(i:i))-40B)
      end do
  
      end 
  
      subroutine tack(string,number)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     TACK appends the string and number to the item IMAGE, 
*     updating its size, if the number is nonzero or the string 
*     is a comma. 
  
      character string*(*),digits*12,temp*40
      integer string_size,start 
      integer*4 number
  
      if (number.le.0 .and. string.ne.',') return 
  
      write(digits,'(i12)') number
      start = 1 
      do while (digits(start:start).eq.' ') 
          start = start + 1 
      end do
      temp = string 
      call out(temp(1:len(string))//digits(start:12)) 
  
      end 
  
      subroutine newrec(record,length,type,subtype) 
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     new modifies the record in RECORD to a new reloatable 
*     record.  Unrecognized records (and new records) are left unchanged. 
* 
*     Records modified:  NAM, ENT, EXT, END.
  
      integer record(*),length,type,subtype,new(128)
      integer i,clen,slen,in,out
      character newchar*256 
      equivalence (new,newchar) 
      integer mr(0:7) 
      data mr / 1,2,3,0,15,15,15,15 / 
  
*  Nam. 
  
      if (type.eq.1) then 
          new(2) = 160130B
          new(4) = 0
          new(5) = 0
          new(6) = 0
          do i=7,17 
              new(i) = record(i)
          end do
          do i=18,24
              new(i) = 0  
          end do
          if ((record(6).and.377B).eq.0) record(6) = record(6)+40B
          if (record(6).ne.2h  ) then 
              slen = 3
          else if (record(5).ne.2h  ) then
              slen = 2
          else
              slen = 1
          endif 
          clen = length - 17
          do i=1,slen 
              new(25+i) = record(3+i) 
          end do
          do i=1,clen 
              new(25+slen+i) = record(17+i) 
          end do
          new(25) = ishft(clen,8) .or. slen 
          length = 25+slen+clen 
          goto 90 
  
*  Ent. 
  
      else if (type.eq.2) then
          new(2) = 160200B + ibits(record(2),0,4) 
          out = 4 
          do in=4,length,4
              new(out+4) = record(in) 
              new(out+5) = record(in+1) 
              new(out+6) = (record(in+2) .and. 177400B) .or. 40B  
              clen = 1
              if (new(out+5).ne.2h  ) clen = 2
              if (new(out+6).ne.2h  ) clen = 3
              new(out+3) = clen 
              new(out+2) = record(in+3) 
              new(out+1) = 0
              new(out) = mr(ibits(record(in+2),0,3))
              out = out + 4 + clen
          end do
          length = out-1
  
*  Ext. 
  
      else if (type.eq.4) then
          new(2) = 160400B + ibits(record(2),0,5) 
          out = 4 
          do in=4,length,3
              new(out+2) = record(in) 
              new(out+3) = record(in+1) 
              new(out+4) = (record(in+2) .and. 177400B) .or. 40B
              clen = 1
              if (new(out+3).ne.2h  ) clen = 2
              if (new(out+4).ne.2h  ) clen = 3
              new(out+1) = clen 
              new(out) = ibits(record(in+2),0,8)
              out = out + 2 + clen
          end do
          length = out-1
      else if (type.eq.5) then
          new(2) = 160500B
          new(4) = 0              ! Punt on global checksum.
          if (.not.btest(record(2),0)) then 
              length = 4
          else
              new(5) = 0
              new(6) = mr(ibits(record(2),1,2)) 
              new(7) = record(4)
              length = 7
          endif 
      else
          return
      endif 
  
*  Copy back and form new checksum & length.
  
   90 record(1) = ishft(length,8) 
      record(2) = new(2)
      record(3) = record(2) 
      do i=4,length 
          record(i) = new(i)
          record(3) = record(3) + record(i) 
      end do
  
      type = ibits(record(2),13,3)
      subtype = ibits(record(2),6,7)
  
      end 
  
$EMA /FREEEMA/
      logical function search(loc,nam_flag,alloc_flag)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     SEARCH searches for a name in the name lists.  If the 
*     name is found, its location is returned.  If not, it is 
*     created & its location is returned.  The function result
*     if .true. if the name already existed.
* 
*       loc   (returned) symbol index 
*       nam_flag   whether in NAM (.true.) or ENT/EXT/ALLOC (.false.) 
*       alloc_flag whether in ALLOC.
* 
*     Format of table entries:
* 
*         -2: (alloc) first word of length. 
*         -1: (alloc) second word of length.
*     word 0: link to next entry. 
*          1: NAM: link to first ENT.   ENT: link next ENT
*          2: NAM: sequence #   ENT/EXT/ALLOC: link to defining module
*          3: NAM: level #      ENT/EXT/ALLOC: link to reference list 
*          4: flags;  bit 15 = 0 (NAM) or 1 (ENT/EXT/ALLOC) 
*                        3:0 = (# character in name) - 1
*         5+: name
  
      integer loc 
      logical nam_flag,alloc_flag 
      common /name/ name,name_len 
      integer name_len,name_w(8)
      character*16 name 
      equivalence (name,name_w) 
  
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      integer free,next,last
  
      common /hash/ hash(0:255) 
  
      integer hash,allocate 
  
      integer match,pointer,words,i 
      integer old_pntr,new_pntr,wlen,name2_w(8) 
      character name2*16
      equivalence (name2,name2_w) 
      wlen(i) = ((free(i+4).and.17B)+2)/2 
  
*  Set up match pattern & set up for list search. 
  
      if (nam_flag) then
          match = name_len-1
      else
          match = ibset(name_len-1,15)
      endif 
      pointer = hash(ichar(name)) 
      words = (name_len+1)/2
  
*  Search for name. 
  
      do while (pointer.ne.0) 
          if ((free(pointer+4).and.100017B).eq.match) then
              do i=1,words
                  if (name_w(i).ne.free(pointer+4+i)) goto 10 ! fail
              end do
              search = .true.  ! match
              goto 20 
          endif 
   10     pointer = free(pointer) 
      end do
  
*  Not found. Allocate space & create new entry.
  
      search = .false.
      if (alloc_flag) then
          pointer = allocate(7+words) + 2 
      else
          pointer = allocate(5+words) 
      endif 
      free(pointer+1) = 0 
      free(pointer+2) = 0 
      free(pointer+3) = 0 
      if (nam_flag) then
          free(pointer+4) = name_len-1
      else
          free(pointer+4) = ibset(name_len-1,15)
      endif 
      do i=1,words
          free(pointer+4+i) = name_w(i) 
      end do
  
*  Link it in in sorted order.
  
      old_pntr = 0
      new_pntr = hash(ichar(name))
      do while (new_pntr.ne.0)
          name2 = '                '
          do i=1,wlen(new_pntr) 
              name2_w(i) = free(new_pntr+4+i) 
          end do
          if (name.le.name2) goto 30
          old_pntr = new_pntr 
          new_pntr = free(old_pntr) 
      end do
  
   30 free(pointer) = new_pntr
      if (old_pntr.ne.0) then 
          free(old_pntr) = pointer
      else
          hash(ichar(name)) = pointer 
      endif 
  
*  Found or newly added.  Return location.
  
   20 loc = pointer 
  
      end 
  
$EMA /FREEEMA/
      logical function init_scan(nam_flag)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     INIT_SCAN initializes a full scan of the symbol list, returning 
*     NAM or ENT/EXT/ALLOC names according to nam_flag. 
  
      logical nam_flag,nam,scan 
      integer loc,next_pntr,next_hash,i 
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      integer free,next,last
  
      common /hash/ hash(0:255) 
      integer hash
  
      next_hash = 0 
      next_pntr = 0 
      nam = nam_flag
      init_scan = .true.
      return
  
*     SCAN returns the location of the next symbol. 
  
      entry scan(loc) 
  
   10 if (next_hash.gt.256) then
          loc = 0 
          scan = .false.
          return
      endif 
  
   20 if (next_pntr.eq.0) then
          next_pntr = hash(next_hash) 
          next_hash = next_hash + 1 
          goto 10 
      endif 
  
      loc = next_pntr 
      next_pntr = free(loc) 
      if (btest(free(loc+4),15) .eqv. nam) goto 20
      scan = .true. 
  
      end 
  
      block data
      implicit none 
      common /hash/ hash(0:255) 
      integer hash
      data hash / 256*0 / 
      end 
  
$EMA /FREEEMA/
      integer function allocate(words)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     ALLOCATE allocates (words) words from freespace, and returns
*     a pointer to them.
  
C     common /free/ free(32000),next,last 
      COMMON /FREEEMA/FREE(0:0) 
      COMMON /FREE/NEXT,LAST
  
      integer free,next,last,words
  
      allocate = next 
      next = next + words 
      IF (NEXT.GT.LAST) WRITE (1,*) NEXT,WORDS,LAST 
      if (next.gt.last) stop 'Space overflow.  Increase size.'
      end 
  
      subroutine init_out(col,label)
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     INIT_OUT, OUT, TAB and FLUSH are output primitives for QXREF. 
*     Calling sequences:
* 
*     CALL init_out(column #, label)
*     CALL out(string)
*     CALL tab(column #)
*     CALL flush
  
      integer col,saved_col,image_size,label_size,temp
      character label*(*),saved_label*40,string*(*),blanks*30,image*132 
      common /width/ width
      integer width 
      data blanks / ' ' / 
  
*  Initialize.
  
      saved_col = col 
      saved_label = label 
      label_size = len(label) 
      image_size = 0
      return
  
*  Output string. 
  
      entry out(string) 
  
      if (saved_col-1+label_size+image_size+len(string).gt.width) then
          write(2000,'(a,a,a)') blanks(1:saved_col-1),
     .                          saved_label(1:label_size),
     .                          image(1:image_size) 
          saved_label = ' ' 
          image_size = 0
      endif 
  
      image(image_size+1:image_size+len(string)) = string 
      image_size = image_size + len(string) 
      return
  
*  Tab to a specified column. 
  
      entry tab(col)
  
      temp = col - (saved_col+label_size+image_size)
      if (temp.gt.0) then 
          image(image_size+1:image_size+temp) = ' ' 
          image_size = image_size + temp
      endif 
      return
  
*  Flush buffer.
  
      entry flush 
  
      if (image_size.ne.0) then 
          write(2000,'(a,a,a)') blanks(1:saved_col-1),
     .                          saved_label(1:label_size),
     .                          image(1:image_size) 
      else if (saved_label.ne.' ') then 
          write(2000,'(a,a)')   blanks(1:saved_col-1),
     .                          saved_label(1:label_size) 
      endif 
  
      saved_label = ' ' 
      image_size = 0
  
      return
      end 
  
      subroutine eject
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     EJECT causes a page eject.  If out_name is not '1', a line
*     with a '1' in column 1 is written out.  If out_name is '1', 
*     four blank lines are written. 
  
      common /output/ out_name
      character out_name*30 
  
      if (out_name.ne.'1') then 
          write(2000,'(''1'')') 
      else
          write(2000,'(///)') 
      endif 
  
      end 
  
      character*30 function time()
     .,24999-16407 REV.2220 820518
      implicit none 
  
*     TIME returns the date & time in FCLB format, e.g. 
* 
*                   '  Thu Apr 30, 1981   1:36 pm  '
  
      integer array(5),year,minute,hour,day,month,day_of_week 
      integer month_lengths(12) 
      equivalence (array(3),minute),(array(4),hour),(array(5),day)
      character days(0:6)*3,months(12)*3,am_pm*2
      data days   / 'Fri','Sat','Sun','Mon','Tue','Wed','Thu' / 
      data months / 'Jan','Feb','Mar','Apr','May','Jun',
     .              'Jul','Aug','Sep','Oct','Nov','Dec' / 
      data month_lengths / 31,29,31,30,31,30,31,31,30,31,30,31 /
  
      call exec(11,array,year)
      day_of_week = mod(day+year+(year-1)/4,7)
      if (ibits(year,0,2).ne.0 .and. day.gt.59) day = day + 1 
      month = 1 
      do while (day.gt.month_lengths(month))
          day = day - month_lengths(month)
          month = month + 1 
      end do
      if (hour.lt.12) then
          am_pm = 'am'
      else
          am_pm = 'pm'
      endif 
      if (hour.gt.12) hour = hour - 12
      write(time,10) days(day_of_week),months(month),day,year,
     .               hour,minute,am_pm
   10 format(2x,a3,1x,a3,1x,i2,', ',i4,2x,i2,':',i2.2,1x,a2)
  
      end 
