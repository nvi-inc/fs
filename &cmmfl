FTN4
      PROGRAM CMMFL(3,99),FLOPPY CMM4 C#810413:22:01   #
C 
C     PROGRAM TO ALLOW ONE TO PERFORM LISTS AND MODS ON FLOPPY DISKS. 
C     IT TAKES NOTE OF THE FACT THAT YOU CAN ONLY READ/WRITE ENTIRE 
C     BLOCKS ON A FLOPPY, NOT A SINGLE SECTOR.  HOWEVER, THIS FACT IS 
C     MASKED FROM THE USER. 
C 
C     BRUCE SCHUPLER
C     15 AUGUST 1979
C 
C     LL COMMAND ADDED 810402 - BRS 
C     MS COMMAND ADDED 810410 - BRS 
C     RD COMMAND ADDED 810413 - BRS 
C 
C# LAST COMPC'ED  810413:22:01                                            # 
C 
      DIMENSION IBUF(128),IMPAR(5),LCOMND(25),LRETN(2),LVER(6)
      DIMENSION IBUF1(128)
      EQUIVALENCE(RRETN,LRETN(1)) 
      EQUIVALENCE(RRETN,IRETN)
      QDATA LGREE1 @GREETINGS FROM THE FLOPPY DISK LIST/MOD PROGRAM@
      QDATA LGREEA @VERSION XXXXXX@ 
      QDATA LGREE2 @WHAT DO YOU WANT TO DO?@
      QDATA LEQUAL @=_@ 
      QDATA LOK @IS THIS CORRECT (Y/N)? _@
      QDATA LEND @CMMFL ENDED@
      QDATA LCOMN1 @LEGAL COMMANDS ARE:@
      QDATA LCOMN2 @DL - DISK LIST     @
      QDATA LCOMN3 @DM - DISK MOD      @
      QDATA LCOMN4 @DS - DISK SEARCH          @ 
      QDATA LCOMN5 @EX - EXIT                 @ 
      QDATA LCOMN7 @LL - CHANGE LIST DEVICE   @ 
      QDATA LCOMN8 @MS - MOVE DISK SECTORS    @ 
      QDATA LCOMN9 @RD - READ DIRECTORY@
      QDATA LCOMN6 @??,XX FOR MORE INFORMATION@ 
      QDATA LDLHLP @DL,LU,TRK,SECTR, # OF SECTORS@
      QDATA LDMHLP @INTERACTIVE@
      QDATA LDSHLP @DS,LU,TRK,WORD TO FIND@ 
      QDATA LEXHLP @NO ARGUMENTS@ 
      QDATA LLLHLP @LL,LIST LU#@
      QDATA LMSHLP @MS,SOURCE LU,TRK,SECTR,DEST LU,TRK,SECTR,DEST #SECT/
     1TRK,#SECT TO MOVE@
      QDATA LRDHLP @RD,LU,DIR TRK@
      QDATA INSDM1 @DISK MOD!  ENTER A /D AT ANY TIME TO EXIT THIS MODE@
      QDATA INSDM2 @LU,TRK,SECTR,WORD,VALUE _@
      QDATA LDLHED @LUXXXXXX TRACKXXXXXX SECTOR XXXXXX@ 
      QDATA LDLLST @WORDXXXXXX VALUE(8) XXXXXX VALUE(10)  XXXXXX VALUE(A
     1S)  XX@ 
      QDATA LDMHED @LUXXXXXX TRACKXXXXXX SECTOR XXXXXX WORD XXXXXX@ 
      QDATA LDMNEW @NEW              NEW               NEW@ 
      QDATA LDMOLD @OLD              OLD               OLD@ 
      QDATA LDMLST @VALUE(8)  XXXXXX VALUE(10)  XXXXXX VALUE(AS)  XX@ 
      QDATA LDSLST @SECTORXXXXXX WORD XXXXXX@ 
      QDATA LDSNTF @NOT FOUND@
      QDATA LMSHD1 @FROM  LUXXXXXX TRACKXXXXXX SECTOR XXXXXX@ 
      QDATA LMSHD2 @TO    LUXXXXXX TRACKXXXXXX SECTOR XXXXXX WITH XXXXXX
     1 SEC / TRK@ 
      QDATA LMSHD3 @MOVE  XXXXXX SECTORS@ 
      QDATA LMSLST @LU  XXXXXX TRK  XXXXXX SECT XXXXXX MOVED TO LU  XXXX
     1XX TRK  XXXXXX SECT XXXXXX@ 
      QDATA LRDHD @   NAME      TYPE    SIZE          SCODE   TRACK    S
     1ECT     EXT@
      QDATA LRDLS @                          SECTRS 
     1                   @
C 
C     CAREFUL WHEN EDITING THE NEXT LINE.  THERE ARE NONPRINTING CHARACTERS 
C 
      QDATA LBADCM ~&dCCOMMAND ERROR!&d@~ 
C#    DATA LVER    /2H81,2H04,2H13,2H:2,2H2:,2H01/                        # 
C 
C     LET'S GET GOING 
C 
      CALL RMPAR(IMPAR) 
      LUSER = IMPAR(1)
      IF(LUSER .EQ. 0) LUSER = 1
      LUOUT = LUSER 
C 
C     SAY HELLO 
C 
      IDUM = ICHMV(LGREEA(6),1,LVER,1,6)
      CALL EXEC(2,LUSER,LGREE1(2),-LGREE1(1)) 
      CALL EXEC(2,LUSER,LGREEA(2),-LGREEA(1)) 
      CALL EXEC(2,LUSER,LGREE2(2),-LGREE2(1)) 
C 
C     FIND OUT WHAT IS TO BE DONE 
C 
100   CONTINUE
      CALL EXEC(2,LUSER,LEQUAL(2),-LEQUAL(1)) 
      CALL CLEAR(LCOMND,25) 
      CALL EXEC(1,400B+LUSER,LCOMND,25) 
C 
C     FIND OUT WHERE THE FIRST BLANK IS 
C     AND SET IBLNK1 TO 1 CHARACTER EARLIER 
C 
      IBLNK1 = ISCNC(LCOMND,1,50,40B) - 1 
C 
C     CHECK THE FIRST FIELD 
C 
      CALL CLEAR(LRETN,2) 
      IFCHAR = 1
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,0,LRETN)
      IF(LRETN(1) .EQ. 2H??) GO TO 200
      IF(LRETN(1) .EQ. 2HDL) GO TO 300
      IF(LRETN(1) .EQ. 2HDM) GO TO 400
      IF(LRETN(1) .EQ. 2HDS) GO TO 500
      IF(LRETN(1) .EQ. 2HLL) GO TO 600
      IF(LRETN(1) .EQ. 2HMS) GO TO 700
      IF(LRETN(1) .EQ. 2HRD) GO TO 800
      IF(LRETN(1) .EQ. 2HEX) GO TO 1000 
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     SOMEBODY NEEDS HELP 
C 
200   CONTINUE
C 
C     SEE IF THEY WANT TO KNOW ABOUT ALL THE COMMANDS OR JUST ONE 
C 
      CALL CLEAR(LRETN,2) 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,0,LRETN)
      IF(LRETN(1) .EQ. 2H, ) GO TO 210
      IF(LRETN(1) .EQ. 2HDL) GO TO 220
      IF(LRETN(1) .EQ. 2HDM) GO TO 230
      IF(LRETN(1) .EQ. 2HDS) GO TO 240
      IF(LRETN(1) .EQ. 2HEX) GO TO 250
      IF(LRETN(1) .EQ. 2HLL) GO TO 260
      IF(LRETN(1) .EQ. 2HMS) GO TO 270
      IF(LRETN(1) .EQ. 2HRD) GO TO 280
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     THE USER WANTS TO KNOW ALL THE COMMANDS 
C 
210   CONTINUE
      CALL EXEC(2,LUOUT,LCOMN1(2),-LCOMN1(1)) 
      CALL EXEC(2,LUOUT,LCOMN2(2),-LCOMN2(1)) 
      CALL EXEC(2,LUOUT,LCOMN3(2),-LCOMN3(1)) 
      CALL EXEC(2,LUOUT,LCOMN4(2),-LCOMN4(1)) 
      CALL EXEC(2,LUOUT,LCOMN7(2),-LCOMN7(1)) 
      CALL EXEC(2,LUOUT,LCOMN8(2),-LCOMN8(1)) 
      CALL EXEC(2,LUOUT,LCOMN9(2),-LCOMN9(1)) 
      CALL EXEC(2,LUOUT,LCOMN5(2),-LCOMN5(1)) 
      CALL EXEC(2,LUOUT,LCOMN6(2),-LCOMN6(1)) 
      GO TO 100 
C 
C     THE USER WANTS TO KNOW ABOUT DL 
C 
220   CONTINUE
      CALL EXEC(2,LUOUT,LDLHLP(2),-LDLHLP(1)) 
      GO TO 100 
C 
C     THE USER NEEDS HELP WITH DM 
C 
230   CONTINUE
      CALL EXEC(2,LUOUT,LDMHLP(2),-LDMHLP(1)) 
      GO TO 100 
C 
C     HOW DOES DS WORK? 
C 
240   CONTINUE
      CALL EXEC(2,LUOUT,LDSHLP(2),-LDSHLP(1)) 
      GO TO 100 
C 
C     THE USER WANTS TO KNOW ABOUT EX 
C 
250   CONTINUE
      CALL EXEC(2,LUOUT,LEXHLP(2),-LEXHLP(1)) 
      GO TO 100 
C 
C     TELL ALL ABOUT LL 
C 
260   CONTINUE
      CALL EXEC(2,LUOUT,LLLHLP(2),-LLLHLP(1)) 
      GO TO 100 
C 
C     THE POOR SOUL THINKS HE'S GOING TO USE MS 
C 
270   CONTINUE
      CALL EXEC(2,LUOUT,LMSHLP(2),-LMSHLP(1)) 
      GO TO 100 
C 
C     THE SUCKER NOW WANTS TO READ A DIRECTORY TRACK
C 
280   CONTINUE
      CALL EXEC(2,LUOUT,LRDHLP(2),-LRDHLP(1)) 
      GO TO 100 
C 
C     PROCESS THE DL COMMAND
C 
300   CONTINUE
C 
C     GET THE LU,TRACK,SECTOR, AND NUMBER OF SECTORS FROM LCOMND
C 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ILU = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ITRACK = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ISECTR = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      INUMBR = IRETN
C 
C     CHECK FOR OUT OF RANGE
C 
      IF((0 .GT. ILU) .OR. (ILU .GT. 63)) GO TO 390 
      IF((0 .GT. ITRACK) .OR. (ITRACK .GT. 66)) GO TO 390 
      IF((0 .GT. ISECTR) .OR. (ISECTR .GT. 59)) GO TO 390 
      IF((0 .GT. INUMBR) .OR. (INUMBR .GT. 3960)) GO TO 390 
      IF(IDTYP(ILU) .NE. 33B) GO TO 390 
C 
C     WELL, IT LOOKS LIKE WE HAVE A VALID COMMAND 
C 
      DO 380 I=1,INUMBR 
      ISECTA = ISECTR + I - 1 
      ISECT2 = (ISECTA / 2)*2 
      CALL EXEC(1,100B+ILU,IBUF,128,ITRACK,ISECT2)
      J1 = 1
      IF(ISECT2 .NE. ISECTA) J1 = 65
      J2 = J1 + 63
C 
C     WRITE A HEADER
C 
      CALL CNUMD(ILU,LDLHED(3)) 
      CALL CNUMD(ITRACK,LDLHED(9))
      CALL CNUMD(ISECTA,LDLHED(16)) 
      CALL EXEC(2,LUOUT,LDLHED(2),-LDLHED(1)) 
C 
C     WRITE THE CORRECT HALF OF THE BLOCK 
C 
               J0 = -1
               DO 310 J=J1,J2 
               J0 = J0 + 1
               CALL CNUMD(J0,LDLLST(4)) 
               CALL CNUMO(IBUF(J),LDLLST(12)) 
               CALL CNUMD(IBUF(J),LDLLST(21)) 
               LDLLST(30) = IBUF(J) 
               CALL EXEC(2,LUOUT,LDLLST(2),-LDLLST(1))
310            CONTINUE 
C 
C     BOTTOM OF LOOP
C 
380   CONTINUE
      GO TO 100 
C 
C     OOPS, AN INVALID COMMAND
C 
390   CONTINUE
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     DM
C 
400   CONTINUE
C 
C     TALK TO THE USER
C 
      CALL EXEC(2,LUSER,INSDM1(2),-INSDM1(1)) 
410   CONTINUE
      CALL EXEC(2,LUSER,INSDM2(2),-INSDM2(1)) 
C 
C     SEE WHAT THE USER SAYS
C 
      CALL CLEAR(LCOMND,10) 
      CALL EXEC(1,400B+LUSER,LCOMND,10) 
C 
C     IF THE USER SAYS /D, GET OUT
C 
      IF(LCOMND(1) .EQ. 2H/D) GO TO 100 
C 
C     CALCULATE IBLNK1
C 
      IBLNK1 = ISCNC(LCOMND,1,20,40B) - 1 
C 
C     GET THE PARAMETERS
C 
      IFCHAR = 1
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ILU = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ITRACK = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ISECTR = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      IWORD = IRETN 
C 
C     FIND OUT WHAT VALUE IS.  MORE LOGIC IS NEEDED SINCE IT MAY BE 
C     DECIMAL, OCTAL, OR ASCII
C 
      CALL GTVAL(LCOMND,IFCHAR,IBLNK1,IVALUE) 
C 
C     CHECK FOR VALID PARAMETERS
C 
      IF((0 .GT. ILU) .OR. (ILU .GT. 63)) GO TO 490 
      IF((0 .GT. ITRACK) .OR. (ITRACK .GT. 66)) GO TO 490 
      IF((0 .GT. ISECTR) .OR. (ISECTR .GT. 59)) GO TO 490 
      IF((0 .GT. IWORD) .OR. (IWORD .GT. 63)) GO TO 490 
      IF(IDTYP(ILU) .NE. 33B) GO TO 490 
C 
C     WE HAVE VALID PARAMETERS, ECHO THEM TO THE USER 
C 
      CALL CNUMD(ILU,LDMHED(3)) 
      CALL CNUMD(ITRACK,LDMHED(9))
      CALL CNUMD(ISECTR,LDMHED(16)) 
      CALL CNUMD(IWORD,LDMHED(22))
      CALL CNUMO(IVALUE,LDMLST(7))
      CALL CNUMD(IVALUE,LDMLST(16)) 
      LDMLST(25) = IVALUE 
      CALL EXEC(2,LUSER,LDMHED(2),-LDMHED(1)) 
      CALL EXEC(2,LUSER,LDMNEW(2),-LDMNEW(1)) 
      CALL EXEC(2,LUSER,LDMLST(2),-LDMLST(1)) 
C 
C     ALSO, WRITE OUT THE CURRENT VALUE 
C 
      ISECT2 = (ISECTR / 2) * 2 
      CALL EXEC(1,100B+ILU,IBUF,128,ITRACK,ISECT2)
      J1 = 1
      IF(ISECT2 .NE. ISECTR) J1 = 65
      CALL CNUMO(IBUF(J1 + IWORD),LDMLST(7))
      CALL CNUMD(IBUF(J1 + IWORD),LDMLST(16)) 
      LDMLST(25) = IBUF(J1 + IWORD) 
      CALL EXEC(2,LUSER,LDMOLD(2),-LDMOLD(1)) 
      CALL EXEC(2,LUSER,LDMLST(2),-LDMLST(1)) 
C 
C     ASK IF IT IS OK 
C 
      CALL EXEC(2,LUSER,LOK(2),-LOK(1)) 
      CALL EXEC(1,400B+LUSER,LCOMND,1)
      IF(LCOMND(1) .NE. 1HY) GO TO 410
C 
C     A GOOD COMMAND.  EXECUTE IT 
C 
      IBUF(J1 + IWORD) = IVALUE 
      CALL EXEC(2,100B+ILU,IBUF,128,ITRACK,ISECT2)
      GO TO 410 
C 
C     AN INVALID COMMAND
C 
490   CONTINUE
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     HERE WE TAKE CARE OF DS 
C 
500   CONTINUE
C     GET THE LU, TRACK, AND WORD(S) TO FIND FROM THE COMMAND 
C
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ILU = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ITRACK = IRETN
      CALL GTVAL(LCOMND,IFCHAR,IBLNK1,IWORD)
C 
C     CHECK FOR VALID PARAMETERS
C 
      IF((0 .GT. ILU) .OR. (ILU .GT. 63)) GO TO 590 
      IF((0 .GT. ITRACK) .OR. (ITRACK .GT. 66)) GO TO 590 
      IF(IDTYP(ILU) .NE. 33B) GO TO 590 
C 
C     TRY TO FIND IT
C 
      IFIND = 0 
      DO 520 I=1,59,2 
      CALL EXEC(1,100B+ILU,IBUF,128,ITRACK,I-1) 
        DO 510 ISRCH=1,128
        IF(IBUF(ISRCH) .NE. IWORD) GO TO 510
        IFIND = IFIND + 1 
        IF(ISRCH .LE. 64) CALL CNUMD(I-1,LDSLST(5)) 
        IF(ISRCH .GE. 65) CALL CNUMD(I,LDSLST(5)) 
        IF(ISRCH .LE. 64) CALL CNUMD(ISRCH-1,LDSLST(11))
        IF(ISRCH .GE. 65) CALL CNUMD(ISRCH-65,LDSLST(11)) 
        CALL EXEC(2,LUOUT,LDSLST(2),-LDSLST(1)) 
510     CONTINUE
520   CONTINUE
      IF(IFIND .EQ. 0) CALL EXEC(2,LUOUT,LDSNTF(2),-LDSNTF(1))
      GO TO 100 
C 
C     ERROR 
C 
590   CONTINUE
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     PROCESS THE LL COMMAND
C 
600   CONTINUE
C 
C     GET THE NEW LIST LU 
C 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      LUOUT = IRETN 
      GO TO 100 
C 
C     PROCESS THE MS COMMAND
C 
700   CONTINUE
C 
C     GET THE PARAMETERS FROM THE COMMAND 
C 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      LUSOU = IRETN 
      IF(IDTYP(LUSOU) .NE. 33B) GO TO 790 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ISTRK = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ISSEC = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      LUDEST = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      IDTRK = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      IDSEC = IRETN 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      NSPT = IRETN
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      NSECMV = IRETN
      CALL CNUMD(LUSOU,LMSHD1(6)) 
      CALL CNUMD(LUDEST,LMSHD2(6))
      CALL CNUMD(ISTRK,LMSHD1(12))
      CALL CNUMD(IDTRK,LMSHD2(12))
      CALL CNUMD(ISSEC,LMSHD1(19))
      CALL CNUMD(IDSEC,LMSHD2(19))
      CALL CNUMD(NSPT,LMSHD2(25)) 
      CALL CNUMD(NSECMV,LMSHD3(5))
      CALL EXEC(2,LUSER,LMSHD1(2),-LMSHD1(1)) 
      CALL EXEC(2,LUSER,LMSHD2(2),-LMSHD2(1)) 
      CALL EXEC(2,LUSER,LMSHD3(2),-LMSHD3(1)) 
      CALL EXEC(2,LUSER,LOK(2),-LOK(1)) 
      CALL EXEC(1,400B+LUSER,LCOMND,1)
      IF(LCOMND(1) .NE. 1HY) GO TO 100
C 
C     LOOP TO READ AND WRITE SECTORS
C 
      ISECTA = ISSEC - 1
      ISECTB = IDSEC - 1
      DO 780 I=1,NSECMV 
      ISECTA = ISECTA + 1 
      IF(ISECTA .GE. 60) ISTRK = ISTRK + 1
      IF(ISECTA .GE. 60) ISECTA = ISECTA - 60 
      ISECT2 = (ISECTA / 2) * 2 
      ISECTB = ISECTB + 1 
      IF(ISECTB .GE. NSPT) IDTRK = IDTRK + 1
      IF(ISECTB .GE. NSPT) ISECTB = ISECTB - NSPT 
      ISECT3 = (ISECTB / 2) * 2 
      CALL EXEC(1,100B+LUSOU,IBUF,128,ISTRK,ISECT2) 
      CALL EXEC(1,100B+LUDEST,IBUF1,128,IDTRK,ISECT3) 
      J1 = 1
      J2 = 1
      IF(ISECT2 .NE. ISECTA) J1 = 65
      IF(ISECT3 .NE. ISECTB) J2 = 65
      IDUM = ICHMV(IBUF1(J2),1,IBUF(J1),1,128)
      CALL EXEC(2,100B+LUDEST,IBUF1,128,IDTRK,ISECT3) 
      CALL CNUMD(LUSOU,LMSLST(4)) 
      CALL CNUMD(ISTRK,LMSLST(10))
      CALL CNUMD(ISECTA,LMSLST(16)) 
      CALL CNUMD(LUDEST,LMSLST(26)) 
      CALL CNUMD(IDTRK,LMSLST(32))
      CALL CNUMD(ISECTB,LMSLST(38)) 
      CALL EXEC(2,LUOUT,LMSLST(2),-LMSLST(1)) 
780   CONTINUE
      GO TO 100 
C 
C     BAD COMMAND 
C 
790   CONTINUE
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     PROCESS THE RD COMMAND
C 
800   CONTINUE
C 
C     GET THE PARAMETERS
C 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ILU = IRETN 
      IF(IDTYP(ILU) .NE. 33B) GO TO 890 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,IRETN)
      ITRACK = IRETN
C 
C     DO THE LIST 
C 
      CALL EXEC(2,LUOUT,LRDHD(2),-LRDHD(1)) 
      DO 880 I=1,30 
      ISECT = MOD(14 * (I-1),60)
      CALL EXEC(1,100B+ILU,IBUF,128,ITRACK,ISECT) 
      JENT = 1
      IF(ISECT .EQ. 0) JENT = 2 
      DO 810 J=JENT,8 
      IF(IBUF(((J-1)*16) + 1) .LE. 0) GO TO 810 
      CALL CLEAR(LRDLS(2),13) 
      CALL CLEAR(LRDLS(18),16)
      LRDLS(3) = IBUF(((J-1)*16) + 1) 
      LRDLS(4) = IBUF(((J-1)*16) + 2) 
      LRDLS(5) = IBUF(((J-1)*16) + 3) 
      CALL CNUMD(IBUF(((J-1)*16) + 4),LRDLS(7)) 
      CALL CNUMD(IBUF(((J-1)*16) + 7),LRDLS(11))
      ITEMP = IBUF(((J-1)*16) + 9)
      IF(ITEMP .LT. 0) ITEMP = -ITEMP 
      CALL CNUMD(ITEMP,LRDLS(19)) 
      IF(IBUF(((J-1)*16) + 9) .LT. 0) LRDLS(19) = IOR(26400B, 
     1    IAND(377B,LRDLS(19))) 
      CALL CNUMD(IBUF(((J-1)*16) + 5),LRDLS(23))
      CALL CNUMD(IAND(IBUF(((J-1)*16) + 6),377B),LRDLS(27)) 
      CALL CNUMD(IAND(IBUF(((J-1)*16) + 6),177400B)/256,LRDLS(31))
      CALL EXEC(2,LUOUT,LRDLS(2),-LRDLS(1)) 
810   CONTINUE
880   CONTINUE
      GO TO 100 
C 
C     AN ERROR
C 
890   CONTINUE
      CALL EXEC(2,LUSER,LBADCM(2),-LBADCM(1)) 
      GO TO 100 
C 
C     THE END 
C 
1000  CONTINUE
      CALL EXEC(2,LUSER,LEND(2),-LEND(1)) 
      CALL EXEC(6)
      END 
C 
      SUBROUTINE CLEAR(LBUFF,I),CLEAR BUFFER C#810413:22:01  #
      DIMENSION LBUFF(1)
      DO 100 J=1,I
100   LBUFF(J) = 2H 
      RETURN
      END 
C 
      SUBROUTINE GTVAL(LCOMND,IFCHAR,IBLNK1,IVALUE),GET IVALUE
     1C#810413:22:01  # 
C 
C     THIS SUBROUTINE WILL CHECK THE COMMAND
C     STRING AND RETURN EITHER THE INTEGER VALUE FROM DECIMAL OR OCTAL
C     INPUT OR THE FIRST 2 CHARACTERS FROM ASCII INPUT IN IVALUE
C 
C     BRUCE SCHUPLER       16 AUGUST 1979 
C 
C# LAST COMPC'ED  810413:22:01                                   #
C 
      DIMENSION LCOMND(1),ISPACE(2) 
C 
C     SAVE IFCHAR 
C 
      IFCHAS = IFCHAR 
C 
C     SEE IF THE NEXT PARAMETER IS DECIMAL
C 
      ISPACE(1) = 0 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,1,ISPACE) 
      IF(ISPACE(1) .EQ. 100000B) GO TO 200
      IF(ISPACE(1) .EQ. 26040B) GO TO 200 
C 
C     WELL, IT WAS DECIMAL.  PUT IT INTO IVALUE AND RETURN
C 
      IVALUE = ISPACE(1)
      RETURN
C 
C     IT WASN'T DECIMAL.  HOW ABOUT OCTAL?
C 
200   CONTINUE
      ISB = 0 
      IFCHAR = IFCHAS 
      LCHAR = ICHAR(LCOMND,IFCHAR)
      IF((LCHAR .LT. 60B) .OR. (LCHAR .GT. 67B)) GO TO 300
      ISPACE(1) = LCHAR - 60B 
      IFCHAR = IFCHAR + 1 
C 
C     LOOP TO GET THE NEXT CHARACTER UNTIL WE ENCOUNTER A "B" (SUCCESSFUL 
C     OCTAL FIND) OR A NON-"B" & NON-"0-7" (FAILURE)
C 
210   CONTINUE
      LCHAR = ICHAR(LCOMND,IFCHAR)
      IFCHAR = IFCHAR + 1 
      IF(((LCHAR .LT. 60B) .OR. (LCHAR .GT. 67B)) .AND. 
     1  (LCHAR .NE. 102B)) GO TO 300
      IF(LCHAR .EQ. 102B) GO TO 220 
      ISPACE(1) = ISPACE(1) * 8 + (LCHAR - 60B) 
      GO TO 210 
C 
C     SUCCESSFUL OCTAL FIND 
C 
220   CONTINUE
      IVALUE = ISPACE(1)
      RETURN
C 
C     WELL, WE JUST WANT 2 CHARACTERS 
C 
300   CONTINUE
      IFCHAR = IFCHAS 
      CALL GTPRM(LCOMND,IFCHAR,IBLNK1,0,ISPACE) 
      IVALUE = ISPACE(1)
      RETURN
C 
C     THE END 
C 
      END 
