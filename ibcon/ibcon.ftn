FTN77,I,Y
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
      PROGRAM IBCON(3,99)   ! HPIB ITF/C CNTRL V=2 #  <910329.2045>
C 
C 1.1.   IBCON controls the I/O to the HP Interface Bus 
C 
C 2.  IBCON INTERFACE 
C 
C 2.1.   CALLING SEQUENCE: EXEC(10,6HIBCON ,IP1,IP2,IP3,IP4,IP5)
C 
C     INPUT VARIABLES: (RMPAR)
C 
C        IP1    - class number of input buffer
C                   word1 is mode 
C                   1=read data, device mnemonic in word 2
C                   2=write data, device in word 2, data in words 3 - end 
C                   -1=read data, LU in word 2
C                   -2=write data, LU in word 2, data in words 3 - end
C        IP2    - number of records in class
C 
C     OUTPUT VARIABLES:   (RMPAR) 
C 
C        IP1    - "EN" (we are ENding)
C        IP2    - "IB" (who we are) 
C        IP3    - class number of output buffer 
C        IP4    - number of records in class
C        IP5    - error code
C                  0 - no error 
C                 -1 - trouble with class buffer
C                 -2 - illegal mode
C                 -3 - unrecognized device
C                 -4 - device time-out on response
C                 -5 - improper response (wrong number of chars)
C                 -6 - attempt to read from a listen-only device
C                 -7 - attempt to write to a talk-only device
C                 -8 - device is down
C
C 2.2.   COMMON BLOCKS USED
C
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C 2.5.   SUBROUTINE INTERFACE:
C
C     CALLING SUBROUTINES: BOSS ONLY
C
C     CALLED SUBROUTINES:  SYSTEM CALLS AND ICHMV
C
C 3.  LOCAL VARIABLES
C 
      DIMENSION IP(5) 
C               - RMPAR 
C        IMODE  - mode for transmission/reception 
C        MAXMOD,MINMOD
C               - maximum, minimum mode numbers allowed 
C        NCHAR  - # chars in class buffer we read 
C        NCH2   - # chars in buffer 2 
C        ICLASS - class # we read 
C        ICLASR - class # we respond with 
C        NCLREC - # class records 
C        ICLREC - counter for outer loop over class records 
C        NADEV  - mnemonic name of device, first word of table
C        LUDEV  - LU of device, found in table as second word 
C        IMDEV  - mode of device, from table's third word 
      DIMENSION IREG(2) 
C               - registers from EXEC 
      DIMENSION IBUF(20),IBUF2(20)
C               - buffers for reading, writing
C        ILEN   - length of above buffers 
      LOGICAL KINI
C               - TRUE once we have initialized 
C        NDEV   - # devices in module table 
      DIMENSION MODTBL(3,10)  
C               - module table, word 1 = mnemonic, word 2 = LU, 
C                 word 3 = 0 for talk/listen devices
C                          1 for talk-only devices 
C                          2 for listen-only devices
C 
      EQUIVALENCE (REG,IREG(1)) 
C 
C 4.  CONSTANTS USED
C 
C 5.  INITIALIZED VARIABLES 
C 
      DATA KINI/.FALSE./
C*******************************************************************
C*****************************NOTE THESE ARE LU'S SET UP AT******
C*****************GODDARD FOR TESTING PURPOSES.  ****************
C     DATA MODTBL/2HCL,11,0,2HC1,12,0,2HC2,13,0,2HC3,14,0,2HSW,15,2/
C                   Counter, clock, switch, relays
C     DATA NDEV/5/
C*************************************************************
      DATA MINMOD/-2/, MAXMOD/2/
      DATA MAXDEV/10/
      DATA ILEN/40/
C
C 6.  PROGRAMMER: NRV
C                 LNF - SET TIMEOUT RETURN TO USER
C     LAST MODIFIED:  791129
C  WHO  WHEN    DESCRIPTION
C  GAG  901220  Added a call to logit on error condition when initializing
C               MODTBL
C
C     PROGRAM STRUCTURE
C
C     1. First get parameters and initialize if necessary.
C
      CALL RMPAR(IP)
1     ICLASS = IP(1)
      NCLREC = IP(2)
      ICLASR = 0
      NCLRER = 0
      IERR = 0
C                   Initialize return class and number of records 
      IF (ICLASS.NE.0) GOTO 100 
      IERR = -1 
      GOTO 1090 
C 
100   IF (KINI) GOTO 200
C 
C     1.5  Read in device address table.
C     Read table from class buffer
C 
      DO I=1,NCLREC
        CALL EXEC(21,ICLASS,IBUF,-ILEN)
        IF (I.LE.MAXDEV) THEN
          MODTBL(1,I) = IBUF(1)
          MODTBL(2,I) = IAS2B(IBUF,4,2)
          MODTBL(3,I) = IAS2B(IBUF,7,1)
C
C               SET DEVICE TO RETURN TIME-OUTS TO PROGRAM
C
C         CALL EXEC(3,2500B+MODTBL(2,I),17400B)
C
C               SET TIMEOUT VALUE TO 500 FOR EACH LU (THUS COVERING ALL
C               EQT'S REFERENCED BY THIS ROUTINE)
C
          CALL EXEC(3,2200B+MODTBL(2,I),500)
        ENDIF
      ENDDO
      IF (NCLREC.GT.MAXDEV) CALL LOGIT(0,0,0,1,-101,2HIB,MAXDEV)
C
      NDEV = MIN0(NCLREC,MAXDEV)
C
      KINI = .TRUE.
      GOTO 1090
C
C
C     2. Begin the loop over class buffer records.
C     Read in the buffer, get the mode and module code.
C     Search the module table for a match.
C 
200   DO 900 ICLREC = 1,NCLREC
        REG = EXEC(21,100000B+ICLASS,IBUF,-ILEN)
        IF (IERR.LT.0) GOTO 900 
C                   If we got an error earlier, skip to end of loop 
        IF (IREG(1).GE.0) GOTO 210
        IERR = -1 
        GOTO 900
C 
210     NCHAR = IREG(2) 
        IMODE = IBUF(1) 
C     WRITE(LU,9001) NCHAR,IMODE,NDEV
C9001  FORMAT("NCHAR,IMODE,NDEV =",3I5)
        IF (IMODE.GE.MINMOD.AND.IMODE.LE.MAXMOD) GOTO 220 
        IERR = -2 
        GOTO 900
C 
C 
220   IW = 1
      IF (IMODE.LT.0) IW = 2
C                   Check device name (first word) or LU (second word)
        DO 230 I=1,NDEV 
          IF (MODTBL(IW,I).EQ.IBUF(2)) GOTO 221 
230       CONTINUE
        IERR = -3 
        GOTO 900
221     IDEV = I
      NADEV = MODTBL(1,I)
      LUDEV = MODTBL(2,I)
      IMDEV = MODTBL(3,I)
C***  CALL EXEC(3,LUDEV)
C                   Reset the HPIB
C     CALL EXEC(3,1600B+LUDEV)
C                   Enable the LUIB
C
C
      IMODE = IABS(IMODE)
      IF (IMODE.EQ.2) GOTO 400
C
C
C     3. Here we are reading data from a device.
C
      IF (IMDEV.EQ.0.OR.IMDEV.EQ.1) GOTO 301
      IERR = -6
      GOTO 900
301   CALL EXEC(140000B+1,20000B+LUDEV,IBUF,-ILEN,*303)
303   CONTINUE
      CALL ABREG(IREG(1),IREG(2))
      IF (IAND(IREG,2B).EQ.0) GOTO 305
      IERR = -8
C                   DEVICE IS DOWN
      GOTO 900
C
305   CONTINUE
      IF(IAND(IREG,1B).EQ.0) GOTO 310
      IERR = -4
C                TIMEOUT
      GO TO 900
C
310   NCH2 = IREG(2)
      IF (NCH2.EQ.0) GOTO 900
      NCLRER = NCLRER + 1
      CALL ICHMV(IBUF2,3,IBUF,1,NCH2)
      IBUF2(1) = NADEV
      CALL EXEC(20,0,IBUF2,-NCH2-2,0,0,ICLASR)
        GOTO 900
C
C
C     4.  Here we are writing data to the HPIB.
C
400   IF (IMDEV.EQ.0.OR.IMDEV.EQ.2) GOTO 401
      IERR = -7
      GOTO 900
401   IF (NCHAR.GT.4) GOTO 410
      IERR = -1
C                   We have no data to write
      GOTO 900
C
410   NCHAR = NCHAR - 4
      CALL EXEC(140000B+2,20000B+LUDEV,IBUF(3),-NCHAR,*413)
413   CONTINUE
      CALL ABREG(IREG(1),IREG(2))
      IF(IAND(IREG(1),3B).EQ.3B) IERR=-8
      IF(IAND(IREG(1),3B).EQ.1B) IERR=-4
      GOTO 900
C
C
C     9.  End of outer loop on class records.
C
900     CONTINUE
C
C
C     10. Now we have read all of the class records.  There may have
C     been an error in one record, and there may also be outstanding
C     response class numbers.  If so, do not send back partial classes
C     except in the case of mode 0. 
C 
      IF (IERR.GE.0) GOTO 1090
C                   If there was no error send any response classes on
C                   back to BOSS. 
      IF (ICLASR.EQ.0) GOTO 1090
      DO 1005 I=1,NCLRER
        CALL EXEC(21,ICLASR,IBUF,-ILEN) 
1005    CONTINUE
C                   Clear out all response classes
      ICLASR = 0
      NCLRER = 0
C
1090  IP(1) = ICLASR
      IP(2) = NCLRER
      IP(3) = IERR
      IP(4) = 2HIB
      CALL PRTN(IP)
      CALL EXEC(6,0,1)
C*************************** SUSPEND HERE **********************
      CALL RMPAR(IP)
      GOTO 1
      END
