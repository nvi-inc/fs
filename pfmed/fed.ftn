FTN77,I,Y
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE FED(LUI,LUO,IB,ICHX,LPROC,LDEF) !  <910204.1621>
C
C 1.  FED PROGRAM SPECIFICATION
C
C 1.1.   FED is a simplified editor for use with the Mark III field system.
C        The following commands are available: P,O,L,>,/,-,^,R, ,E,A.
C        The syntax and usage are similar to the corresponding EDIT commands.
C        P and O allow only character for character replacement or a single
C        use of controlS, controlC, or controlT.
C
C        Procedure files lacking DEFINE as the first record are amended.
C
C 1.2.   RESTRICTIONS - Only procedure files are accessible.  These have
C        the prefix "[PRC" which is transparent to the user.  Procedures are
C        available only on disc ICRPRC.  Two scratch files [____1 and [____2
C        must exist on ICRPRC before editing can take place.  They are
C        created if needed.
C
C 1.3.   REFERENCES - Field system manual
C
C 2.  FED INTERFACE
C
C 2.1.   CALLING SEQUENCE: CALL FED(LUI,LUO,IB,ICHX,LPROC,LDEF)
C
C     INPUT VARIABLES:
C        LUI, LUO  - input, output LU's
      DIMENSION IB(51)
      CHARACTER*74 IBC
C               - line and record buffer
C        ICHX   - number of characters from terminal
      CHARACTER*12 LPROC
C               - active procedure file
      CHARACTER*34 LDEF
C               - DEFINE line (name begins in col. 9)
C
C     OUTPUT VARIABLES: none
C
C 2.2.   COMMON BLOCKS USED
C
      INCLUDE PFMED.FTNI
C
C 2.3.   DATA BASE ACCESSES: none
C
C 2.4.   EXTERNAL INPUT/OUTPUT
C
C     INPUT VARIABLES:
C
C     TERMINAL   - IB
C
C     OUTPUT VARIABLES:
C
C     TERMINAL   - various messages
C
C 2.5.   SUBROUTINE INTERFACE:
C
C     CALLING SUBROUTINES: PFMED
C
C     CALLED SUBROUTINES: EXEC, FMP routines, IB2AS, JCHAR, ICHMV, IAS2B,
C                         IFTL, LTOF, IFTOF, PLIN, ETO, ICHCM,
C                         IFILL, ISCNC, GTFLD, PFBLK, PFCOP
C
C 3.  LOCAL VARIABLES
C
      LOGICAL KNEW
C               - flag for newly created procedure
      CHARACTER*12 LNAM1,LNAM2,CID
C               - procedure name
      DIMENSION JDCB(16),IP(5)
C               - buffer to save IDCB2
C        NN     - line number or count from command
C        ICHI   - character count of typed line
C        LCOM   - single character edit command
C        IERR   - FMP error flag
C        NPASS  - number of lines to pass over in positioning
C
C 4.  CONSTANTS USED
C
      DIMENSION LSLA(5)
      CHARACTER*12 LS1,LS2
      CHARACTER*8 LM8
      INTEGER*2 TRIMLEN,FMPREADSTRING,FMPWRITESTRING,FMPOPEN,FMPCLOSE
      INTEGER*2 FMPPURGE,FMPREWIND
      INTEGER*2 NCH,FNBLNK
      LOGICAL KERR
      CHARACTER*3 ME
      DATA ME/'FED'/
C
      DATA LSLA   /2H&,2HdB,2H/,2H&d,2H@_/
C               - EDITR-like prompt with reverse video
C
      DATA LS1    /'/PROC/[____1'/
      DATA LS2    /'/PROC/[____2'/
C               - scratch file names
C
C 5.  INITIALIZED VARIABLES: none
C
C 6.  PROGRAMMER: C. Ma
C     MODIFIED 840307 BY MWH To schedule EDIT/1000
C
C     PROGRAM STRUCTURE
C
C     Exit if no procedure file active.
      IF (LPROC(1:1).EQ.' ') THEN
        WRITE(LUI,'("NO PROCEDURE FILE ACTIVE")')
        GOTO 900
      ENDIF
C     Initialize and parse names.
      LNAM1 = ' '
      LNAM2 = ' '
C     Search for commas.
      IC1=ISCNC(IB,1,ICHX,54B)
C     No commas means no names.
C       Move name to buffer.
      IF (IC1.NE.0) THEN
        NCH = ICHX - IC1
        CALL HOL2CHAR(IB,IC1+1,ICHX,LNAM2)
      ELSE
        WRITE(LUI,'("ENTER PROCEDURE NAME(:: TO CANCEL): _")')
        READ(LUI,'(A)') LNAM2
      END IF
      IPOS = FNBLNK(LNAM2,1)
      NCH = TRIMLEN(LNAM2)
      IF (NCH.LE.0) THEN
        WRITE(LUI,'("ERROR ENTERING PROCEDURE NAME")')
        RETURN
      END IF
      LNAM1 = LNAM2(IPOS:NCH)
      CALL CASEFOLD(LNAM1)
      IF (LNAM1.EQ.'::') GOTO 390
C     Initialize flags and counters.
      KNEW = .FALSE.
      ID = FmpOpen(IDCB1,IERR,LS1,'rwo',IDCBX/128) !  Open 1st scratch fi
      IF (IERR.EQ.-6) THEN        !  Create scratch file if nonexistent
        ID = FmpOpen(IDCB1,IERR,LS1,'rwc',IDCBX/128)
        IF (IERR.LE.0) THEN
          WRITE(LUI,9100) IERR
9100      FORMAT('ERROR CREATING [____1 ',I4)
          GO TO 390
        ENDIF
      ELSE IF (IERR.LE.0) THEN
        WRITE(LUI,9200) IERR
9200    FORMAT('SCRATCH ERROR ',I4)
        GO TO 390
      ENDIF
C     Write EOF to initialize.
      ID = FmpRewind(IDCB3,IERR)
      IF(KERR(IERR,ME,'Rewinding',' ',0,0)) RETURN
C     Search for procedure name given.
      LEN=FmpReadString(IDCB3,IERR,IBC)
      IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      DO WHILE(IERR.GE.0.AND.LEN.GE.0)
        IF(IBC(1:6).EQ.'DEFINE'.AND.IBC(9:20).EQ.LNAM1) GOTO 130
        LEN = FmpReadString(IDCB3,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      ENDDO
      WRITE(LUI,'("NEW PROCEDURE")')
      KNEW = .TRUE.
      GO TO 150
c
130   CONTINUE
      LEN = FmpReadString(IDCB3,IERR,IBC)
      IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      DO WHILE(IBC(1:6).NE.'ENDDEF'.AND.IERR.GE.0.AND.LEN.GE.0)
        NCH = TRIMLEN(IBC)
        IF (NCH.GT.0) THEN
          LENW = FmpWriteString(IDCB1,IERR,IBC(:NCH))
          IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
        END IF
        LEN = FmpReadString(IDCB3,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      ENDDO
150   CONTINUE
      IERR = FmpRewind(IDCB3,IERR)
      IF(KERR(IERR,ME,'Rewinding',' ',0,0)) RETURN
      IERR = FmpClose(IDCB1,IERR)
      IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
C  Edit procedure
      IF (IDGET(6HEDIT  ).EQ.0) THEN
        CALL FmpRpProgram('EDIT','EDIT',' ',IERR)
        IF (IERR.NE.0) THEN
          WRITE(LUI,'(''EDIT/1000 not present'')')
          GOTO 390
        ENDIF
      ENDIF
      WRITE(LUI,9999)
9999  format(
     &'Scheduling EDIT/1000 - End with ER to save changes. End with',
     &' A to abort.')
      NCH=ICHMV(IB,1,20HRU,EDIT,/PROC/[____1,1,20)
      CALL IFILL(IB,NCH,72-NCH+1,40B)
      NCH=NCH-1
C
C  SCHEDULE EDIT
C
      CALL EXEC(23,6HEDIT  ,0,0,0,0,0,IB,NCH)
      CALL RMPAR(IP)
      IF (IP(1).EQ.0) THEN
      ID = FmpOpen(IDCB1,IERR,LS1,'rwo',IDCBX/128)
      IF (IERR.LE.0) THEN
        WRITE(LUI,9090) IERR
9090    FORMAT('ERROR ',I4,' OPENING [____1')
        GO TO 390
      ENDIF
C
C  Open/Create scratch file 2
C
      ID = FmpOpen(IDCB2,IERR,LSF2,'rwo',IDCBX/128)
      IF (IERR.EQ.-6) THEN
        ID = FmpOpen(IDCB2,IERR,LSF2,'rwc',IDCBX/128)
        IF (IERR.LE.0) THEN
          WRITE(LUI,9500) IERR
9500      FORMAT('ERROR ',I4,' CREATING OUTPUT FILE')
          GO TO 390
        ENDIF
      ELSE IF (IERR.LE.0) THEN
        WRITE(LUI,9200) IERR
        GO TO 390
      ENDIF
C
C  Replace/insert edited procedure
C
C   copy down to the old procedure if it existed, to the end otherwise
C
      LEN = FmpReadString(IDCB3,IERR,IBC)
      IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      DO while(ierr.ge.0.and.len.ge.0)
        if(IBC(1:6).eq.'DEFINE'.and.IBC(9:20).eq.LNAM1) goto 160
        NCH = TRIMLEN(IBC)
        IF (NCH.GT.0) LENW = FmpWriteString(IDCB2,IERR,IBC(:NCH))
        IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
        LEN = FmpReadString(IDCB3,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      ENDDO
160   continue
C
C   write the new DEFINE line
C
      LDEF(9:20) = LNAM1(1:12)
      LENW = FmpWriteString(IDCB2,IERR,LDEF(:34))
      IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
C
C  copy the new procedure in
C
      LEN = FmpReadString(IDCB1,IERR,IBC)
      IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      DO while(ierr.ge.0.and.len.ge.0)
        NCH = TRIMLEN(IBC)
        IF (NCH.GT.0) LENW = FmpWriteString(IDCB2,IERR,IBC(:NCH))
        IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
        LEN = FmpReadString(IDCB1,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
      ENDDO
C
C  Write the ENDDEF line
C
      LENW = FmpWriteString(IDCB2,IERR,'ENDDEF')
      IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
C
C  copy through the old routine if it existed, otherwise we are at EOF
C
      IF (.NOT.KNEW) THEN
        LEN = FmpReadString(IDCB3,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
        DO while(ibc(1:6).ne.'ENDDEF')
          IF(ierr.lt.0.or.len.lt.0) go to 180
          LEN = FmpReadString(IDCB3,IERR,IBC)
          IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
        ENDDO
C
C  okay, now copy the remaining procedures
C
        LEN = FmpReadString(IDCB3,IERR,IBC)
        IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
        do while(ierr.ge.0.and.len.ge.0)
          NCH = TRIMLEN(IBC)
          IF (NCH.GT.0) LENW = FmpWriteString(IDCB2,IERR,IBC(:NCH))
          IF(KERR(IERR,ME,'Writing',' ',0,0)) CONTINUE
          LEN = FmpReadString(IDCB3,IERR,IBC)
          IF(KERR(IERR,ME,'Reading',' ',0,0)) CONTINUE
        ENDDO
      END IF
C
180   continue
      IERR = FmpClose(IDCB3,IERR)
      IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
      IERR = FmpClose(IDCB1,IERR)
      IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
      IF (KNEW) THEN
        LM8(1:8) = 'inserted'
      ELSE
        LM8(1:8) = 'replaced'
      END IF
      NCH = TRIMLEN(LNAM1)
      IF (NCH.GT.0) WRITE(LUI,9800) LNAM1(1:NCH),LM8,LPROC(1:12)
9800  FORMAT('PROCEDURE ',A,' ',A8,' IN ',A)
C  Replace procedure file
      CALL PFBLK(3,LPROC,CID)
C  Copy to scratch 3
      CALL PFCOP(LPROC,LUI,ID)
      ENDIF
390   IERR = FmpClose(IDCB1,IERR)
      IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
      IERR = FmpPurge(LS1)    !IDCB1
      IF(KERR(IERR,ME,'Purging',' ',0,0)) RETURN
      IERR = FmpClose(IDCB2,IERR)
      IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
      IERR = FmpRewind(IDCB3,IERR)
      IF(KERR(IERR,ME,'Rewinding',' ',0,0)) RETURN
900   CONTINUE
      RETURN
      END
