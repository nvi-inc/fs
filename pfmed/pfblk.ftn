FTN77,I,Y  
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
      SUBROUTINE PFBLK(KBLK,LP,LFR)             ! <910322.0351>
C
C 1.  PFBLK PROGRAM SPECIFICATION
C
C 1.1.   PFBLK interfaces PFMED with BOSS using a resource number.
C        When PFMED is ready to read or alter a file, PFMED is called to
C        lock the status of the procedure files.  If there is a second copy,
C        PFBLK returns the correct file name for reading.
C
C 1.2.   RESTRICTIONS - Only procedure files are accessible.  These have
C        the prefix "[PRC" which is transparent to the user.  Procedures are
C        available only on disc ICRPRC.  The resource number must be
C        allocated by OPRIN.
C
C 1.3.   REFERENCES - Field System Manual
C
C 2.  PFBLK INTERFACE
C
C 2.1.   CALLING SEQUENCE: CALL PFBLK(KBLK,LP,LFR)
C
C     INPUT VARIABLES:
C
C        KBLK    - control flag (1 - about to read, 2 - finished reading,
C                  3 - about to replace file, 4 - error after 1 or 2)
      CHARACTER*(*) LP
C                - target procedure file
      CHARACTER*(*) LFR
C                - correct extent name for reading
      CHARACTER*18 FNAME
C
C 2.2.   COMMON BLOCKS USED:
C
      INCLUDE PFMED.FTNI
C
      INCLUDE /FS/INCLUDE/FSCOM.FTNI
C
C        LPRC    - current schedule procedure file
C        LNEWSK  - flag for 2nd copy of schedule procedure file
C                  (<>0 if copy exists)
C        LNEWPR  - flag for 2nd copy of station procedure file
C
C 2.4.   EXTERNAL INPUT/OUTPUT
C
C     CALLING SUBROUTINES: KCOPY, FFM, FFMP
C
C     CALLED SUBROUTINES: FMP routines
C
C 3.  LOCAL VARIABLES:
C
      LOGICAL KERR
      INTEGER*2 TRIMLEN
      CHARACTER*5 ME
      DATA ME/'PFBLK'/
C
C  WHO  WHEN    DESCRIPTION
C  GAG  901228  Changed IPGST calls to KBOSS calls to see if BOSS is running.
C
  
      GO TO (100,200,300),KBLK
C     Before reading a procedure file.
100   CONTINUE
C     If file to be read is not second copy, release lock.
      IF ((LP.NE.LNEWSK.AND.LP.NE.LNEWPR).OR.(.NOT.KBOSS_PF)) THEN
C     Set file name for reading.
        LFR(1:4)='.PRC'
      ELSE
C     Set name to second copy for reading.
        LFR(1:4)='.PRX'
      ENDIF
      RETURN
C     After reading - release lock and schedule BOSS if second copy used.
200   IF(LFR(1:4).NE.'.PRX') RETURN
      IF (KBOSS_PF) KNEWPF = .TRUE.
      RETURN
C
C     Replacing procedure file.
300   CONTINUE
C     Set name.
C     If file to be replaced is not current to BOSS, purge old and rename.
      IF((LP.NE.LSTP.AND.LP.NE.LPRC).OR.(.NOT.KBOSS_PF)) THEN
        LFR(1:4)='.PRC'
        IERR = FmpClose(IDCB1,IERR)
        IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
        NCH = TRIMLEN(LP)
        IF (NCH.GT.0) fname = '/PROC/' // LP(1:NCH) // LFR(1:4)
        IERR = FmpClose(IDCB2,IERR)
        IF(KERR(IERR,ME,'Closing',LP,0,0)) RETURN
        IF (IERR.LT.0) THEN
          WRITE(LUI,9100)
9100      FORMAT('PFBLK - Error closing file.')
        END IF
        IERR = FmpPurge(FNAME)
        IF(KERR(IERR,ME,'Purging',FNAME,0,0)) RETURN
        ID = FmpRename(LSF2,IERR1,FNAME,IERR2)
        IF (ID.NE.0) THEN
          IF(KERR(IERR1,ME,'Renaming',LSF2,0,0)) CONTINUE
          IF(KERR(IERR2,ME,'Renaming',FNAME,0,0)) RETURN
        END IF
C     If file is second copy, purge old, rename, and schedule BOSS.
      ELSE IF(LP.EQ.LNEWSK.OR.LP.EQ.LNEWPR) THEN
        LFR(1:4)='.PRX'
        IERR = FmpClose(IDCB1,IERR)
        IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
        NCH = TRIMLEN(LP)
        IF (NCH.GT.0) FNAME = '/PROC/' // LP(1:NCH) // LFR(1:4)
        IERR = FmpPurge(FNAME)
        IF(KERR(IERR,ME,'Purging',FNAME,0,0)) RETURN
        IERR = FmpClose(IDCB2,IERR)
        IF(KERR(IERR,ME,'Closing',LSF2,0,0)) RETURN
        ID = FmpRename(LSF2,IERR1,FNAME,IERR2)
        IF (ID.NE.0) THEN
          IF(KERR(IERR1,ME,'Renaming',LSF2,0,0)) CONTINUE
          IF(KERR(IERR2,ME,'Renaming',FNAME,0,0)) RETURN
        END IF
        IF (KBOSS_PF) KNEWPF = .TRUE.
C     If file is current to BOSS, rename to second copy, set flag, and
C     schedule BOSS.
      ELSE
        LFR(1:4)='.PRX'
        IERR = FmpClose(IDCB1,IERR)
        IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
        NCH = TRIMLEN(LP)
        IF (NCH.GT.0) FNAME = '/PROC/' // LP(1:NCH) // LFR(1:4)
        IERR = FmpPurge(FNAME)
        IF(KERR(IERR,ME,'Purging',FNAME,0,0)) RETURN
        IERR = FmpClose(IDCB2,IERR)
        IF(KERR(IERR,ME,'Closing',LSF2,0,0)) RETURN
        ID = FmpRename(LSF2,IERR1,FNAME,IERR2)
        IF (ID.NE.0) THEN
          IF(KERR(IERR1,ME,'Renaming',LSF2,0,0)) CONTINUE
          IF(KERR(IERR2,ME,'Renaming',FNAME,0,0)) RETURN
        END IF
        IF(LPRC.EQ.LP) LNEWSK=LP
        IF(LP.EQ.LSTP) LNEWPR=LP
        IF (KBOSS_PF) KNEWPF = .TRUE.
      ENDIF
      RETURN
      END
