FTN77,I,Y
$CDS ON
$ALIAS /FSCOM/ , NOALLOCATE
C
      SUBROUTINE FFM(LUI,LUO,IB,ICHI,LPROC,LPRC,LSTP,LNEWSK,LNEWPR)
C
C 1.  FFM PROGRAM SPECIFICATION
C
C 1.1.   FFM is a simplified FMGR for use with the Mark III field system.
C        There are two sets of commands available.  Commands with the
C        prefix PF (PF, PFCR, PFDL, PFPU, PFRN, PFST) apply to procedure
C        files as disk file units.
C
C 1.2.   RESTRICTIONS - Only procedure files are accessible.  These have
C        the prefix "[PRC" which is transparent to the user.  Procedures are
C        available only on disc ICRPRC.
C
C 1.3.   REFERENCES - Field system manual
C
C 2.  FFM INTERFACE
C
C 2.1.   CALLING SEQUENCE: CALL FFM(LUI,LUO,IB,ICHI,LPROC,LSTP,LNEWSK,LNEWPR)
C
C     INPUT VARIABLES:
C
C        LUI,LUO - input, output LU's
      DIMENSION IB(51)
C               - line and record buffer
C        ICHI   - number of characters from keyboard
      CHARACTER*12 LPROC,LNEWSK,LNEWPR,LSTP,LPRC
C               - procedure file currently active in PFMED
C               - 2nd copy of schedule procedure file
C               - 2nd copy of station procedure file
C               - station procedure library
C               - Field System procedure library
C
C 2.2.   COMMON BLOCKS USED:
C
      INCLUDE PFMED.FTNI
C
C 2.3.   DATA BASE ACCESSES: none
C
C 2.4.   EXTERNAL INPUT/OUTPUT
C
C     INPUT VARIABLES: none
C
C     OUTPUT VARIABLES:
C
C     TERMINAL   - error message
C
C 2.5.   SUBROUTINE INTERFACE:
C
C     CALLING SUBROUTINES: PFMED
C
C     CALLED SUBROUTINES: FMP routines, ICHMV, IB2AS, ISCNC, JCHAR,
C                         IDTYP, IFILL, MIN0, PFBLK, PFCOP
C
C 3.  LOCAL VARIABLES
C
      INTEGER*2 FmpRunProgram
      CHARACTER*12 LNAM1,LNAM2
C               - file names
      CHARACTER*12 LFR
C               - corrected procedure file name for reading
C        IR     - record count
C        IERR   - error flag
C        LEN    - record length
C        IDTK   - starting directory track of procedure LU
C        JT, JS, JO - track, sector, offset of procedure file entry
C        JX     - extent of procedure file
C
      INTEGER*2 IERR
      character*34 foostr
      CHARACTER*29 DLSTR
      character*12 dlfilenm
      character*74 IBC
      CHARACTER*80 DIRSTR
      character*12 twochr
      CHARACTER*28 PATHNAME,PATHNAME2
      integer*2 fmparm(5), fnblnk,TRIMLEN
      INTEGER*2 I2BYTE(6),FMPREADSTRING
      INTEGER*2 IRET
      CHARACTER*12 SL1,SL2,SL3,SL4
      CHARACTER*40 CMESSAGE
      LOGICAL KEX,KEST,KERR
      CHARACTER*3 ME
      equivalence (twochr,i2byte)
      equivalence (dlfilenm,dlstr(18:29))
C 4.  CONSTANTS USED
C
      DATA ME/'FFM'/
      data dirstr/' '/
C 5.  INITIALIZED VARIABLES: none
C
C 6.  PROGRAMMER: C. Ma
C     LAST MODIFIED: <910323.2042>
C
C     PROGRAM STRUCTURE
C
C     Initialize and parse names.
      LNAM1 = ' '
      LNAM2 = ' '
C     Search for commas.
      IC1=ISCNC(IB,1,ICHI,54B)
C     No commas means no names.
      IF(IC1.NE.0) THEN
        IC2=ISCNC(IB,IC1+1,ICHI,54B)
        IF(IC2.EQ.0) IC2=ICHI+1
C     Move first name to buffer with initialized prefix.
        NCH1 = IC2-IC1-1
        IF (NCH1.LE.0) THEN
          WRITE(LUI,'("No filename given")')
          RETURN
        ELSE IF (NCH1.GT.8) THEN
          WRITE(LUI,9100)
9100      FORMAT("File names must be 8 characters or less")
          RETURN
        END IF
        CALL HOL2CHAR(IB,IC1+1,IC2-1,LNAM1)
C     Move second name if present.
        IF (ICHI.GT.IC2) THEN
          NCH2 = ICHI-IC2
          IF ((NCH2.LE.0).OR.(NCH2.GT.8)) THEN
            WRITE(LUI,9100)
            RETURN
          END IF
          CALL HOL2CHAR(IB,IC2+1,ICHI,LNAM2)
        END IF
      ENDIF
  
C     PFCR - create new procedure file.
  
      IF(IB(2).EQ.2HCR) THEN
        IF (LNAM1.EQ.' ') THEN
          WRITE(LUI,'("SYNTAX ERROR")')
          GOTO 920
        END IF
        PATHNAME = '/PROC/' // LNAM1(1:NCH1) // '.PRC'
        ID = FmpOpen(IDCB1,IERR,PATHNAME // ':::4:50','rwcs',IDCBX/128)
        IF(IERR.LT.0) 800,900
      ENDIF
 
C     PFDL - list directory of procedure files
  
      IF(IB(2).EQ.2HDL) THEN
c  Have the OS issue directory command and send the results to file, FFMTMP
        WRITE (DLSTR,'(29HDL /PROC/@.PRC @ /proc/ffmtmp)')
        ierr = FmpRunProgram(dlstr,fmparm,foostr)
        IF(KERR(IERR,ME,'Running',' ',0,0)) RETURN
        open(UNIT=77,FILE=dlfilenm,STATUS='OLD',IOSTAT=ierr)
        if(ierr.ne.0) then
          write(LUI,7000)ierr
7000      format('Error = ',i5,' when attempting to open FFMTMP.')
          return
        endif
        SL1 = LPROC
        SL2 = LSTP
        SL4 = LPRC
c  Don't parse the directory line.
        read(77,7700,end=208)dirstr
        IX=3
        IBC = ' '
c  Top of "]PRC" filename get loop.
        DO WHILE (.TRUE.)
          read(77,7700,end=208) dirstr
7700      format(a80)
          ipos = 1
          DO WHILE (IPOS.GT.0)
            ipos = fnblnk(dirstr,ipos)
c  Are there any filenames left?
            if(ipos.ne.0) then
              twochr = dirstr(ipos:ipos+11)
              ILC = IFLCH(I2BYTE,12) - 4
c  Remember I2BYTE is equivalenced to TWOCHR
              ibc(ix:ix+ILC-1) = TWOCHR(1:ILC)
c space over past that name
C Add ">" for active, "s" for schedule 2nd copy.
C  "a" for active F.S. proc file
              IF(ibc(ix:ix+11).EQ.SL2(1:12)) IBC(IX-1:IX-1) = 's'
              IF(ibc(ix:ix+11).EQ.SL4(1:12)) IBC(IX-1:IX-1) = 'a'
              IF(ibc(ix:ix+11).EQ.SL1(1:12)) THEN
                IF ((SL4.EQ.SL1).or.(SL1.EQ.SL2)) THEN
                  IBC(IX-2:IX-2) = '>'
                ELSE
                  IBC(IX-1:IX-1) = '>'
                ENDIF
              ENDIF
              IX=IX+14
              IF (IX.GT.60) THEN
                NCH = TRIMLEN(IBC)
                IF (NCH.GT.0) WRITE(LUO,7701) IBC(:NCH)
                IX = 3
                IBC = ' '
              ENDIF
              ipos = ipos+12
            ENDIF
          ENDDO ! ipos.gt.0
        ENDDO !while .true.
208     Close(unit=77)
        IERR = FmpPurge(dlfilenm)
        IF(KERR(IERR,ME,'Purging',' ',0,0)) RETURN
        if(ix.gt.2) THEN
          NCH = TRIMLEN(IBC)
          IF (NCH.GT.0) WRITE(LUO,7701) IBC(:NCH)
7701      FORMAT(A)
        END IF
        RETURN
      ENDIF
  
C     PF - change procedure file active in PFMED.
  
      IF(JCHAR(IB,3).EQ.54B) THEN
        IF(LNAM1.NE.' ') THEN
          CALL PFCOP(LNAM1,LUI,IRET)
          IF (IRET.GE.0) LPROC = LNAM1
          RETURN
        ELSE
          WRITE(LUI,'("SYNTAX ERROR")')
          RETURN
        END IF
      END IF
  
C     PFPU - purge procedure file.
  
      IF(IB(2).EQ.2HPU) THEN
        IF (LNAM1.EQ.' ') THEN
          WRITE(LUI,'("SYNTAX ERROR")')
          RETURN
        END IF
        IERR = FmpClose(IDCB1,IERR)
        IF (IERR.LT.0) GOTO 800
        PATHNAME = '/PROC/' // LNAM1(1:NCH1) // '.PRC'
        CALL PURN(LUI,LNAM1,LPROC,LSTP,LPRC,PATHNAME,IERR)
        IF (IERR.NE.0) RETURN
        IERR = FmpPurge(PATHNAME)
        IF(IERR.NE.0) GOTO 800
        RETURN
      END IF
 
C     PFRN - rename procedure file.
  
      IF(IB(2).EQ.2HRN) THEN
        IF ((LNAM1.EQ.' ').OR.(LNAM2.EQ.' ')) THEN
          WRITE(LUI,'("SYNTAX ERROR")')
          RETURN
        END IF
  
        IF (LNAM1.EQ.LSTP) THEN
          WRITE(LUI,9200)
9200      FORMAT("CANNOT PERFORM OPERATION ON CURRENT STATION LIBRARY")
          RETURN
        ENDIF
        IF (LNAM1.EQ.LPRC) THEN
          WRITE(LUI,9300)
9300      FORMAT("CANNOT PERFORM OPERATION ON CURRENT ACTIVE "
     .           "FIELD SYSTEM PROC LIBRARY")
          RETURN
        ENDIF
 
        PATHNAME = '/PROC/' // LNAM1(1:NCH1) // '.PRC'
        INQUIRE(FILE=PATHNAME,EXIST=KEX)
        IF (.NOT.KEX) THEN
          NCH=TRIMLEN(PATHNAME)
          WRITE(LUI,'("FILE ",A," DOES NOT EXIST")') PATHNAME(:NCH)
          RETURN
        END IF
        PATHNAME2 = '/PROC/' // LNAM2(1:NCH2) // '.PRC'
        INQUIRE(FILE=PATHNAME2,EXIST=KEX)
        IF (KEX) THEN
          NCH = NCH2 + 10
          WRITE(LUI,'("FILE ",A," ALREADY EXISTS")') PATHNAME2(:NCH)
          RETURN
        END IF
        IERR = FmpClose(IDCB3,IERR)
        ID = FmpRename(PATHNAME,IERR1,PATHNAME2,IERR2)
        IF ((ID.NE.0).OR.((IERR1.NE.0).OR.(IERR2.NE.0))) THEN
          WRITE(LUI,'("ERROR RENAMING FILES")')
          RETURN
        END IF
        IF (LNAM1.EQ.LPROC) LPROC=LNAM2
        CALL PFCOP(LPROC,LUI,ID)
        GOTO 920
      END IF
  
C     PFST - transfer from existing file to file created by this command.
  
      IF(IB(2).EQ.2HST) THEN
        KEST = .FALSE.
        IF ((LNAM1.EQ.' ').OR.(LNAM2.EQ.' ')) THEN
          WRITE(LUI,'("SYNTAX ERROR")')
          RETURN
        END IF
C     Open file.
        CALL PFBLK(1,LNAM1,LFR)
        PATHNAME ='/PROC/' // LNAM1(1:NCH1) // LFR(1:4)
        ID = FmpOpen(IDCB1,IERR,PATHNAME,'rwos',IDCBX/128)
        IF(IERR.LT.0) THEN
          WRITE(LUI,'("ERROR OPENING FILE ",A)') PATHNAME
          KEST = .TRUE.
        END IF
C     Create new file.
        PATHNAME2 = '/PROC/' // LNAM2(1:NCH2) // '.PRC'
        ID = FmpOpen(IDCB2,IERR,PATHNAME2 // ':::4:50','rwcs',IDCBX/128)
        IF(IERR.LT.0) THEN
          INCH=TRIMLEN(PATHNAME2)
          WRITE(LUI,'("ERROR, FILE ",A," ALREADY EXISTS")')
     .                 PATHNAME2(:INCH)
          KEST = .TRUE.
        END IF
        IF (KEST) GOTO 900
        DO 710 IR=1,32767
          LEN = FmpReadString(IDCB1,IERR,IBC)
          IF(IERR.LT.0.OR.LEN.LT.0) GOTO 720
          NCH = TRIMLEN(IBC)
          IF (NCH.GT.0) ID = FmpWriteString(IDCB2,IERR,IBC(:NCH))
          IF(IERR.LT.0) GOTO 800
710     CONTINUE
720     CALL PFBLK(2,LNAM1,LFR)
        IERR = FmpClose(IDCB2,IERR)
        IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
        IERR=FmpClose(IDCB1,IERR)
        IF(KERR(IERR,ME,'Closing',' ',0,0)) RETURN
        GOTO 920
      END IF
  
C     Bad command
      WRITE(LUI,'("BAD COMMAND")')
      RETURN
C     FMP error condition.
800   CALL FmpError(IERR,CMESSAGE)
      WRITE(LUI,'(A)') CMESSAGE
  
900   ierr=FmpClose(IDCB1,IERR)
  
920   RETURN
      END
