FTN4,X
C@READP 
C 
      SUBROUTINE READP(IDCBP1,IDCBP2,ISTACK,LSTACK,LPROC1,LPROC2,KBREAK,
     .IBUF,IBLEN,NCHAR,LPROCN,LPARM,NPARM,IERR) 
     .,READ FROM PROCEDURE C#870115:04:22#
C 
C     READP - reads the next line from a procedure
C     The stack is popped as necessary. 
C 
C     DATE   WHO CHANGES
C     810907 NRV Modified for procedure files 
C     840217 MWH Modified stack structure 
C 
D     INCLUDE #FSCOM::FS,1,999
C     INPUT VARIABLES:
C 
C     IDCBP1,2 - DCBs for the two proc files
C     ISTACK - Stack for popping next procedure 
C     LSTACK - Stack for popping next parameters
C     LPROC1,2 - procedure directories
C     KBREAK - true if we are to end the current procedure now
C               We set this to false after doing our thing. 
C     IBUF - buffer for reading the command 
C     IBLEN  - length of IBUF in words
      DIMENSION IDCBP1(1),IDCBP2(1) 
      DIMENSION ISTACK(1),LSTACK(1) 
      DIMENSION LPROC1(5,1),LPROC2(5,1) 
      DIMENSION IBUF(1) 
      LOGICAL KBREAK
C 
C     OUTPUT VARIABLES: 
C 
C     NCHAR - Number of characters in the command in IBUF 
C     LPROCN - the full procedure name - this is unchanged if 
C              no new procedure is popped 
C     LPARM - parameter string for this procedure 
C     NPARM - number of characters in LPARM 
C     IERR  - error return, FMP error from READF
      DIMENSION LPARM(1),LPROCN(1)
C 
C 
C  LOCAL VARIABLES: 
C 
C     INDEXP - index of the procedure 
C     IREC - location informtion for current line of procedure
C     IL - length of record read from file
      DIMENSION IREC(4) 
C 
C  INITIALIZED VARIABLES: 
C 
C 
C 
C     1. First try simply reading the next line from the DCB. 
C     If that works, then we are done.
C 
100   NCHAR = 0 
D     WRITE(LU,9901)
D9901 FORMAT("AT TOP IN READP") 
      CALL PRGET(ISTACK,IREC,4,IERR)
      IF (IERR.LT.0) GOTO 800 
      INDEXP = IREC(4)
      IF(INDEXP.GT.0)CALL APOSN(IDCBP1,IERR,IREC(1),IREC(2),IREC(3))
      IF(INDEXP.LT.0)CALL APOSN(IDCBP2,IERR,IREC(1),IREC(2),IREC(3))
      IF(IERR.LT.0)GOTO 800 
      IF (INDEXP.GT.0) CALL READF(IDCBP1,IERR,IBUF,IBLEN,IL)
      IF (INDEXP.LT.0) CALL READF(IDCBP2,IERR,IBUF,IBLEN,IL)
D     WRITE(LU,9501) IERR,(IBUF(I),I=1,IL)  
D9501  FORMAT("IERR,BUF="I5,1X,20A2)    
      IF (IERR.LT.0) GOTO 800 
      IF (IL.LT.0.OR.ICHCM(IBUF,1,6HENDDEF,1,6).EQ.0.OR.KBREAK.OR.
     .   ICHCM(IBUF,1,6HDEFINE,1,6).EQ.0) GOTO 200
C                     These are the conditions for end-of-procedure 
C 
C     Get location of next record of the procedure and put into stack 
C 
      IF(INDEXP.GT.0)CALL LOCF(IDCBP1,IERR,IREC(1),IREC(2),IREC(3)) 
      IF(INDEXP.LT.0)CALL LOCF(IDCBP2,IERR,IREC(1),IREC(2),IREC(3)) 
      IF(IERR.LT.0)GOTO 800 
      INDX = ISTACK(2) - 4
      DO 110 I=1,3
        ISTACK(INDX+I) = IREC(I)
110   CONTINUE
      NCHAR = IFLCH(IBUF,IL*2)
      IF (NCHAR.EQ.0) GOTO 100
D     WRITE(LU,9802) NCHAR
D9802 FORMAT("COMMAND LENGTH="I3) 
C                   Get the last character in the line
      CALL PRPOP(LSTACK,NPARM,1,IERR) 
C                     Pop up the # parm ... 
D     WRITE(LU,9910) NPARM,IERR 
D9910 FORMAT("POPPING NPARM,IER="2I3) 
      IF (NPARM.NE.0) CALL PRGET(LSTACK,LPARM,(NPARM+1)/2,IERR) 
C                     Get the parameters for this procedure 
D     IF (NPARM.NE.0) WRITE(LU,9902) (LPARM(I),I=1,6),IERR
D9902 FORMAT("GETTING PARM = "6A2," IERR="I3) 
      CALL PRPUT(LSTACK,NPARM,1,IERR) 
C                     Re-place on stack 
D     WRITE(LU,9801) (ISTACK(I),I=1,14) 
D9801 FORMAT("STACK:"2I3,3(O8,2A2,I3))
D     WRITE(LU,9803) (LSTACK(I),I=1,22) 
D9803 FORMAT("LSTCK:"2I3,20A2)
      GOTO 900
C 
C 
C     2. This procedure is used up. 
C     Pop the index of the current proc to get rid of it. 
C     Pop the last line of the previous procedure.
C     Also pop up the old parameters, if any. 
C 
200   CONTINUE
      KBREAK = .FALSE.
D9904 FORMAT("READP - POPPED INDEX,NLINE="2I3", IERR="I3) 
D9905  FORMAT("STACK:"20I5)   
D     WRITE(LU,9502)  
D9502  FORMAT("END OF A PROCEDURE WAS FOUND")   
      CALL PRPOP(ISTACK,INDEXP,1,IERR)
C                     This is the index of the just-completed procedure 
      CALL PRPOP(ISTACK,IREC,3,IERR)  
C                     This is the location info for the previous procedure
D     WRITE(LU,9904) INDEXP,NLINE,IERR
D     WRITE(LU,9905) (ISTACK(I),I=1,14)   
      CALL PRPOP(LSTACK,NPARM,1,IERR) 
D     WRITE(LU,9906) NPARM,IERR 
D9906 FORMAT("READP - POPPED NPARM="I5" IERR="I3) 
      IF (NPARM.NE.0) CALL PRPOP(LSTACK,LPARM,(NPARM+1)/2,IERR) 
D     IF (NPARM.NE.0) WRITE(LU,9701) (LPARM(I),I=1,6),IERR
D9701 FORMAT("READP - POPPED LPARM="6A2," IERR="I3) 
D     WRITE(LU,9810) (LSTACK(I),I=1,22) 
D9810 FORMAT("LSTCK:"2I3,20I5)
      IF (ISTACK(2).EQ.2) GOTO 900
C                     This is the end of the stack
C 
C 
C     3. Re-position to the new procedure, then go back and try reading again.
C     If the nex procedure is used up too, continue to pop up 
C     the stacked names until we find one with more records.
C 
      CALL PRGET(ISTACK,INDEXP,1,IERR)
D     WRITE(LU,9507) INDEXP,IERR
D9507 FORMAT("GETTING NEW CURRENT INDEX,IERR="2I5)
      IF (INDEXP.LT.0) GOTO 320 
      CALL APOSN(IDCBP1,IERR,LPROC1(2,INDEXP),
     .LPROC1(3,INDEXP),LPROC1(4,INDEXP))
D     WRITE(LU,9503) IERR,(LPROC1(I,INDEXP),I=1,5)
D9503 FORMAT("IERR & LPROC USED FOR APOSN="6I6) 
      IF (IERR.LT.0) GOTO 800 
      CALL READF(IDCBP1,IERR,IBUF,IBLEN,IL) 
D     WRITE(LU,9504)IERR, (IBUF(I),I=1,IL)
D9504 FORMAT("IERR,BUFFER AFTER APOSN="I5,1X,20A2)
      IF (IERR.LT.0) GOTO 800 
      CALL ICHMV(LPROCN,1,IBUF,9,12)
D     WRITE(LU,9001) (LPROCN(I),I=1,6)
D9001 FORMAT("LPROCN="6A2)
      GOTO 100
C 
320   INDEXQ = IABS(INDEXP) 
      CALL APOSN(IDCBP2,IERR,LPROC2(2,INDEXQ),
     .LPROC2(3,INDEXQ),LPROC2(4,INDEXQ))
D     WRITE(LU,9503) IERR,(LPROC2(I,INDEXQ),I=1,5)
      IF (IERR.LT.0) GOTO 800 
      CALL READF(IDCBP2,IERR,IBUF,IBLEN,IL) 
D     WRITE(LU,9504)IERR, (IBUF(I),I=1,IL)
      IF (IERR.LT.0) GOTO 800 
      CALL ICHMV(LPROCN,1,IBUF,9,12)
D     WRITE(LU,9001) (LPROCN(I),I=1,6)
      GOTO 100
C 
C 
C     8. Abnormal error section.  There should be no errors, so 
C     this is serious.
C 
800   IF (IERR.EQ.-1) CALL LOGIT(0,0,0,0,-128,2HBO) 
      IF (IERR.LT.-1) CALL LOGIT(0,0,0,1,-129,2HBO,IERR)
      IF (IERR.EQ. 0) CALL LOGIT(0,0,0,1,-130,2HBO,IERR)
      ISTACK(2) = 2 
      LSTACK(2) = 2 
C 
900   RETURN
      END 
