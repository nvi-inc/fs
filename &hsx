FTN4X   
      PROGRAM HSX(3,80), POSITIONER WITH FIELD SYSTEM LOGGING 
C 
C     TO RUN: 
C              RU,HSX,HEAD #(1 OR 2), PASS #(1 TO 24), OFFSET 
C 
C# LAST COMPC'ED  870309:14:24                                # 
C  LAST EDITED                            <870309.1423> 
C 
C 
      DIMENSION ITIME(5),LUS(5),  
     + IBUF(40) 
      LOGICAL FSRUN 
$INCLUDE #HPOSX::-37  
$INCLUDE #FSCOM::FS 
      DATA FSRUN/.TRUE./
C 
      CALL RMPAR(LUS) 
C     LUL=LUOPR(IDUM) 
C     LUT=LUTRU(LUL)
      LUT=LUOPR(IDUM) 
C     CALL DTACH(IDUM)
      ISTART=0
      IHEAD=LUS(1)
      IF(IHEAD.EQ.1.OR.IHEAD.EQ.2) GO TO 100
      WRITE(LUT,2000) IHEAD 
2000  FORMAT(I6," is not a legal head number!") 
      STOP
100   ICR=-37 
      IHEAD=IHEAD-1 
      XINDEX=1
      IF(LUS(2).NE.0) XINDEX=LUS(2) 
      KNDEX=XINDEX
      IF(KNDEX.GT.0.AND.KNDEX.LT.25) GO TO 110
      IF(KNDEX.EQ.-1) THEN
        CALL POSIT(LUT,IHEAD,POS) 
        KNDEX=13
        LUS(3)=LUS(3)+POS+55
        GO TO 110 
      ENDIF 
      WRITE(LUT,2010) KNDEX 
2010  FORMAT(I6," is not a legal pass number!") 
110   HOFF=LUS(3) 
      IDEBUG=0
C DETERMINE IF FIELD SYSTEM IS RUNNING
      IF(IPGST(6HBOSS  ).EQ.-1) FSRUN=.FALSE. 
      CALL HPARM(LUT,ICR,IHEAD) 
      NDEX=XINDEX 
      XINDEX=(NDEX+1)/2 
      IDIR=2*IFIX(XINDEX)-NDEX
C 
C     XINDEX IS INDEX NUMBER (1-12) 
C     IDIR IS DIRECTION OF TAPE MOTION: 
C          1=FORWARD
C          0=REVERSE
C 
C     THIS IS A KLUGE FOR HEAD #1 EFFECT ON SCALE 
C 
C     IF(IDIR.EQ.0.AND.IHEAD.EQ.0) SLOPE1=SLOPE1/1.015
C     IF(IDIR.EQ.0.AND.IHEAD.EQ.0) SLOPE2=SLOPE2/1.010
      CALL HGO(LUT,IHEAD,XINDEX,IDIR,HOFF,ISTART,POFF)
C READ TEMPERATURE FOR THIS HEAD
      ITR=2 
      IF(IHEAD.EQ.1) ITR=3
      CALL HATOD(LUT,ITR,IST,T1)
      TLVDT=T1*10.
      IF(NOPOS.EQ.1) TLVDT=-TLVDT 
      NDEX=XINDEX 
C 
C LOG THE HEAD NUMBER, PASS NUMBER, TEMPERATURE, AND ERROR
C 
      CALL HATOD(LUT,5,I,POWER)     
      IHEADQ=IHEAD+1
      CALL CODE 
      WRITE(IBUF,1038) IHEADQ,KNDEX,POWER,TLVDT,POFF
1038  FORMAT(I1,",",I2,",",F7.3,",",F5.1,",",F5.1)
      IF(FSRUN) CALL LOGIT(IBUF,24) 
C     IF(.NOT.FSRUN) WRITE(LUT,1038) IHEADQ,KNDEX,POWER,TLVDT,POFF
1200  CONTINUE
C TURN OFF OSCILLATOR 
      CALL HATOD(LUT,9,I,POWER) 
      END 
      SUBROUTINE HMOVE(LUT,IHEAD,ISPEED,IDIRCT,IDURA,MODE)
      DIMENSION IOUT(9),IABRT(8),JDURA(3),IASC(2) 
$INCLUDE #HPOSX::-37  
      DATA IOUT/16,2H #,2HA7,2H=0,2H00,2H00,2H00,2H0$,2H(_/ 
      DATA IABRT/2H #,2HA7,2H=0,2H00,2H00,2H0$,2H!_,2H  / 
      DATA IASC/2,2H01/ 
      DATA JDURA/4,2H00,2H00/ 
      IOUT(3)=MATHED
      IABRT(2)=MATHED 
      IF(MODE.EQ.1) GO TO 10
C MODE.NE.1 means abort motion & reset controls 
      WRITE(LUI,1000) IABRT 
1000  FORMAT(8A2) 
      IF(IDEBUG.GT.1) WRITE(LUT,1010) IABRT 
1010  FORMAT("HMOVE/ abort output = ",7A2,A1) 
      RETURN
C This is a motion control command
10    CALL HEX(IDURA,JDURA(2),1)
      CALL MOVQQ(JDURA,1,IOUT,10,4) 
      CALL MOVQQ(IASC,ISPEED+1,IOUT,7,1)
      CALL MOVQQ(IASC,IDIRCT+1,IOUT,8,1)
C This is a temporary patch for single-channel Inchworm controllers 
C     IHEADQ=0  
      IHEADQ=IHEAD+1
C 
      CALL MOVQQ(IASC,IHEADQ,IOUT,9,1)      
      WRITE(LUI,1000) (IOUT(I),I=2,9) 
      IF(IDEBUG.GT.0) WRITE(LUT,1020) (IOUT(I),I=2,9) 
1020  FORMAT("HMOVE/ output = ",7A2,A1) 
      END 
      SUBROUTINE HATOD(LUT,ICHAN,ISTAT,DATA)
      DIMENSION IOUT(9),IRPORT(4),IN(5),IASC(2),ITEMP(2),IOFFOS(8)
      DIMENSION ICONV(3)
$INCLUDE #HPOSX::-37  
      EQUIVALENCE (IN(2),IN2),(ITEMP(2),ITEMP2),(IOUT(9),IREAD),
     + (IOUT(2),IOUT2)
      DATA IASC/2,2H01/ 
      DATA IRPORT/2H #,2HA7,2H =,2H?_/
      DATA IOUT/16,2H #,2HA7,2H=0,2H00,2H00,2H00,2H0$,2H__/ 
      DATA ICONV/2H%_,2H7=,2H% /
      DATA IOFFOS/2H #,2HA7,2H=0,2H00,2H10,2H00,2H0$,2H__/
      DATA ITEMP/2,2H00/
      DATA ITURN/020077B/ 
      IRPORT(2)=MATHED
      IOUT(3)=MATHED
      IOFFOS(2)=MATHED
      IF(ICHAN.LT.9.AND.ICHAN.GT.-1) GO TO 10 
      IF(ICHAN.EQ.9) GO TO 666
C Illegal channel means just report status
      CALL LURQ(10001B,LUI,1) 
      IF(IDEBUG.GT.1) WRITE(LUT,1020) IRPORT
1020  FORMAT("HATOD/ output = ",7A2,A1) 
      WRITE(LUI,1000) IRPORT
1000  FORMAT(8A2) 
      READ(LUI,1000) (IN(I),I=2,5)
      CALL LURQ(110000B,LUI,1)
      IF(IDEBUG.GT.1) WRITE(LUT,1030) (IN(I),I=2,5) 
1030  FORMAT("HATOD/ reply = ",4A2) 
      ISTAT=0 
      IF(IAND(IN2,177400B).EQ.1H8) ISTAT=1
      RETURN
C Request for data
10    CALL CODE 
      WRITE(ITEMP2,1010) ICHAN
1010  FORMAT(I2)
      CALL MOVQQ(ITEMP,2,IOUT,13,1) 
      CALL LURQ(10001B,LUI,1) 
      IF(IDEBUG.EQ.0) GO TO 20
      WRITE(LUT,1020) (IOUT(I),I=2,9) 
      WRITE(LUT,1020) IRPORT
20    CALL EXEC(2,LUI,IOUT2,-15)
      CALL SUSP(1,5)  
      CALL EXEC(2,LUI,ICONV,1)  
      CALL SUSP(1,5)  
      CALL EXEC(3,1200B+LUI,ITURN)
      REG=REIO(1,3200B+LUI,IN2,4) 
C     Turn off LVDT oscillator
      CALL EXEC(2,LUI,IOFFOS,-15) 
      CALL SUSP(1,5)  
      CALL LURQ(110000B,LUI,1)
      CALL HEXI(IN(4),IDATA,4,IERR) 
      DATA=IDATA*0.004882804
      IF(IDEBUG.GT.1) WRITE(LUT,1040) (IN(I),I=2,5),DATA
1040  FORMAT("HATOD/ reply = ",4A2," DATA=",F10.3)
      RETURN
C TURN OFF OSCILLATOR 
666   CALL LURQ(10001B,LUI,1) 
      CALL EXEC(2,LUI,IOFFOS,-15) 
      CALL SUSP(1,5)
      CALL EXEC(2,LUI,ICONV,1)
      CALL SUSP(1,5)
      CALL LURQ(110000B,LUI,1)
      END 
      SUBROUTINE POSIT(LUT,IHEAD,POS) 
$INCLUDE #HPOSX::-37  
C Returns head position from LVDT in um.
      CALL HATOD(LUT,IHEAD,I,V1)
      VHEAD=V1
      CALL HATOD(LUT,3,I,T1)
      TLVDT=T1*10.
      SLOPE=SLOPE1
      QUAD=QUAD1/SLOPE1 
      IF(V1.LT.0.) SLOPE=SLOPE2 
      IF(V1.LT.0.) QUAD=QUAD2/SLOPE2
      POS=SLOPE*V1*(1.+QUAD*V1)*(1.+TCOEFL*(TLVDT-TCOREF))
      IF(IDEBUG.LT.2) RETURN
      WRITE(LUT,1000) V1,TLVDT,LVDT,POS 
1000  FORMAT("POSIT/ LVDT voltage, temperature, position= ",F10.3,
     + 2F6.1,F8.1)  
      END 
      SUBROUTINE HGO(LUT,IHEAD,XINDEX,IDIR,HOFF,ISTART,POFF)
C Sets head to XINDEX, with tolerance PTOL
$INCLUDE #HPOSX::-37  
      DIMENSION PSET(13)  
      DATA PSET/-55.,0.,55.,110.,165.,220.,275.,330.,385.,440.,495.,  
     + 550.,605./ 
      NTRIES=-1 
      NOPOS=0 
C Convert from index # to position in um
      OFFSET=-330.0 
      INDEX=XINDEX+1. 
      POSN=PSET(INDEX)+OFFSET+HOFF  
      IF(IDIR.EQ.1) POSN=POSN+FOROFF
      IF(IDIR.EQ.0) POSN=POSN+REVOFF
C Get current position and compare to desired position
10    CALL POSIT(LUT,IHEAD,PNOW)
      IF(ISTART.NE.0) GO TO 11  
      ISTART=1
      CALL SUSP(1,25) 
      GO TO 10
11    POFF=PNOW-POSN
C If we are very close, average 4 readings
C This has been omitted 
C     IF(ABS(POFF).GT.5.*PTOL) GO TO 12 
C     PSUM=PNOW 
C     DO 11 I=1,3 
C     CALL POSIT(LUT,IHEAD,PNOW)
C11   PSUM=PSUM+PNOW
C     PNOW=PSUM/4.
C Set forward or reverse speeds according to sign of error
12    FASTSP=FASTFW 
      SLOWSP=SLOWFW 
      IF(POFF.GT.0.) GO TO 15 
      FASTSP=FASTRV 
      SLOWSP=SLOWRV 
15    IF(IDEBUG.GT.0) WRITE(LUT,1005) POSN,PNOW,POFF
1005  FORMAT("HGO/ desired, current, error= ",3F10.1) 
      NTRIES=NTRIES+1 
      IF(ABS(POFF).LE.PTOL) RETURN
      IF(NTRIES.LT.50) GO TO 20 
C Can't position within tolerance in 20 tries.  Give up and return. 
      WRITE(LUT,1000) POSN,PNOW,POFF,PTOL 
1000  FORMAT("Unable to position to ",F7.1," --achieved position= ",
     + F7.1/" for error= ",F4.1," which is > tolerance of ",F4.1) 
      NOPOS=1 
      RETURN
C Try to achieve position.  Assume slow speed first.
20    ISPEED=0
      TMOVE=ABS(POFF/SLOWSP)
      IF(IDEBUG.GT.0) WRITE(LUT,1010) TMOVE 
1010  FORMAT("HGO/ time at slow speed = ",F10.3)
      IF(TMOVE.LT.1.0) GO TO 30 
      ISPEED=1
      TMOVE=ABS(POFF /FASTSP )
      IF(IDEBUG.GT.0) WRITE(LUT,1020) TMOVE 
1020  FORMAT("HGO/ time at fast speed = ",F10.3)
C Need time in 40 usec increments.
30    TMOVE=TMOVE*25000.
      IF(IDEBUG.GT.0) WRITE(LUT,1030) TMOVE 
1030  FORMAT("HGO/ need ",F12.0," 40-usec increments")
      IDIRCT=0
      IF(POFF.GT.0.) IDIRCT=1 
C Count down 1-second moves 
40    IF(TMOVE.LT.24000.) GO TO 50
      IF(IDEBUG.GT.0) WRITE(LUT,1040) 
1040  FORMAT("HGO/ moving for 1 second")
      CALL HMOVE(LUT,IHEAD,ISPEED,IDIRCT,24000,1) 
C     CALL SUSP(2,1)
      CALL SUSP(1,5)
      NTRIES=NTRIES-1 
      GO TO 10
C This is the trim move for moves > 1 second duration 
50    IDURA=TMOVE 
      TMOV1=TMOVE/25000.
      IF(IDEBUG.GT.0) WRITE(LUT,1050) TMOV1 
1050  FORMAT("HGO/ trim move for ",F8.3," seconds") 
      CALL HMOVE(LUT,IHEAD,ISPEED,IDIRCT,IDURA,1) 
      IWAIT=TMOVE/250.
      IWAIT=IWAIT+5 
      CALL SUSP(1,IWAIT)
C Go see where we are and re-cycle if necesary
      GO TO 10
      END 
      SUBROUTINE HPARM(LUT,ICR,IHEAD) 
C   
C This subroutine picks up all the relevant headstack information 
C for setting positions from a file called #TPARM::ICR
C 
      REAL    NSLOP1,NSLOP2 
$INCLUDE #HPOSX 
      DIMENSION IPBUF(3),IDCB(144),IBUF(40),XPARM(25) 
      DATA IPBUF/6H#TPARM/
      CALL OPEN(IDCB,IERR,IPBUF,1,0,ICR,144)
      IF(IERR.GE.0) GO TO 100 
      WRITE(LUT,1000) IERR,ICR
1000  FORMAT("ERROR= ",I6," TRYING TO OPEN #TPARM::",I6)
      STOP
100   DO 200 I=1,25 
105   CALL READF(IDCB,IERR,IBUF,10) 
      IF(IERR.GE.0) GO TO 110 
      WRITE(LUT,1010) IERR,I
1010  FORMAT("ERROR= ",I6," TRYING TO READ #TPARM RECORD",I6) 
      STOP
110   IF(IBUF(1).EQ.2H* ) GO TO 105 
      CALL CODE 
      READ(IBUF,*,ERR=190) XPARM(I) 
      GO TO 200 
190   WRITE(LUT,1030) I,(IBUF(J),J=1,10)
1030  FORMAT("RECORD",I4," OF #TPARM UNREADABLE: ",10A2)
      STOP
200   CONTINUE
      FORFA1=XPARM(1) 
      FORSL1=XPARM(2) 
      REVFA1=XPARM(3) 
      REVSL1=XPARM(4) 
      FORFA2=XPARM(5) 
      FORSL2=XPARM(6) 
      REVFA2=XPARM(7) 
      REVSL2=XPARM(8) 
      PSLOP1=XPARM(9) 
      NSLOP1=XPARM(10)
      PSLOP2=XPARM(11)
      NSLOP2=XPARM(12)
      FOROF1=XPARM(13)
      FOROF2=XPARM(14)
      LUI=XPARM(15) 
      PTOL=XPARM(16)
      LUM3=XPARM(17)
      REVOF1=FOROF1+XPARM(18) 
      REVOF2=FOROF2+XPARM(19) 
      IF(IHEAD+1.EQ.2) GO TO 300
      SLOPE1=PSLOP1 
      QUAD1=0.
      SLOPE2=NSLOP1 
      QUAD2=0.
      TCOEFL=0. 
      TCOREF=20.
      FASTFW=FORFA1 
      FASTRV=REVFA1 
      SLOWFW=FORSL1 
      SLOWRV=REVSL1 
      FOROFF=FOROF1 
      REVOFF=REVOF1 
      GO TO 400 
300   SLOPE1=PSLOP2 
      QUAD1=0.
      SLOPE2=NSLOP2 
      QUAD2=0.
      TCOEFL=0. 
      TCOREF=20.
      FASTFW=FORFA2 
      FASTRV=REVFA2 
      SLOWFW=FORSL2 
      SLOWRV=REVSL2 
      FOROFF=FOROF2 
      REVOFF=REVOF2 
400   CALL READF(IDCB,IERR,IBUF,10) 
      IF(IERR.GE.0) GO TO 410 
      I=26  
      WRITE(LUT,1010) IERR,I
      STOP
410   IF(IBUF(1).EQ.2H* ) GO TO 400 
      MATHED=IBUF(3)
420   CALL READF(IDCB,IERR,IBUF,10) 
      IF(IERR.GE.0) GO TO 430 
      I=27
      WRITE(LUT,1010) IERR,I
      STOP
430   IF(IBUF(1).EQ.2H* ) GO TO 420 
      MATTAP=IBUF(3)
      END 
      BLOCK DATA NULL 
$INCLUDE #HPOSX 
      END 
        INTEGER FUNCTION IPGST(NAME),C#870309:14:20    GET PGM STATUS#
C 
C       This routine returns the status of porogram NAME where the
C       value will be the contents of the status field in the IDSEG 
C       if it is present else -1 will be returned.
C 
        IPGST=-1
C 
C               GET IDSEG ADDRESS 
C 
        IDAD=IGID(NAME) 
C 
C               CHECK PROGRAM IS PRESENT
C 
        IF(IDAD .EQ. 0)GO TO 99999
C 
C               GET PROGRAM STATUS
C 
        IPGST=IAND(IGET(IDAD+15),17B) 
C 
C               NOTE IF TIME SCHEDULED
C 
        IF(IAND(IGETS(IDAD+17),10000B) .NE. 0)IPGST=IOR(IPGST,20B)
C 
99999   CONTINUE
C 
        RETURN
        END 
